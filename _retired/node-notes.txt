package main




/**********************************************************************************************************************

A PLAN pnode runs in one of 3 modes, each layer-mode implying a set of services made available.

Each successive layer-mode requires use of the preceding layer (or access to another same-community pnode
offer that lower service layer available). Each set of services are made available to PLAN clients (or other pnodes) 
via either gRPC+protobufs or direct embedding.  

To start session with a pnode, the client must present credentials that confirm that the client is a member of the community
that she is requesting access to. This means a community's channel traffic patterns and organization 
is completely inaccessible to non-community members.  This is in contrast to systems where "the world"
has access to your traffic where an adversary could conduct correlation analysis (despite all traffic being encrypted).  

    1) Layer 1 -- Storage/Replication service layer
        - The pnode is running without any community or personal keys in hand.
        - Lowest security liability in this layer-mode since the pnode doesn't have any keys to lose and 
            all data stored is already all encrypted.
        - Storage and replication operates w/o restriction (though none of the newly arriving entries can be merged into the community's repo)
        - This layer is characterized by the storage/replication implementation with the L1 service implementation on top.
            (e.g local db, [matrix], DFINITY, Ethereum)

    2) Layer 2 -- Community service layer
        - When a L3 client starts a session, and after the challenge/response phase, the client gives the pnode 
            the community keyring for the duration of that session. 
        - With the community keyring in hand, L2 can now decrypt community data, making it possible to process community L1 entries.
        - Newly arriving entries from the repo's active pdi.StorageProvider(s) in L1 are validated then merged into the community's repo
        - The pnode serves sessions for community members:
            - requests/queries against channels and search params return encrypted entries (for the client to decrypt)
            - newly authored entries are encrypted by the client, sent over session to the pnode, and are:
                a) merged into the local community repo
                b) committed to the repo's active pdi.StorageProvider(s)
        - Web services can be attached to pnode, allowing a pnode with Layer II to serve outside-community requests
            (e.g. file/media serving services, html-based viewing of channels made public by community admins)
        - When there are no longer any member sessions active, the pnode burns the community keyring.
        - If the given pnode is to remain in active community service, then it retains the community keyring. 
        - When a pnode no longer has the community keyring (either because no no member sessions are open and it has been set to not
            retain the community keyring), then it only only offer L1 services (by definition).
        - In the event of a L2 security breach (and an adversary has the community keyring):
            a)  The adversary never has the ability to author community entries since he does not have a community member's personal keyring, 
                which is needed in order to sign/authenticate any such authored entries.  
            b)  The adversary's ability to decrypt newly authored community entries goes away once a community member 
                initiates a new community key epoch (and a new community key is reissued via the community's 
                community key distribution channel) 

    3) Layer 3 -- Gateway service layer
        - After the challenge/response phase, the client gives the pnode the community keyring AND the member's personal keyring.
        - For security, pnodes in this mode are typically on the same device as the client or a trusted LAN.
        - With the community keyring in hand, Layer II is activated
        - With the personal keyring in hand:
            a) newly authored entries from the client can be encrypted, signed and submitted to Layer II.
            b) newly received entries from Layer 2 are decrypted and passed back the client

This system multiple configurations based on device and security constraints.  
    - A pnode running on a public rackspace would likely be setup to only run in Layer 1 mode (to avert any security risk)
    - A pnode running on a lightweight machine (e.g. laptop) would connect to and use a pnode offering Layer 1 services.
    - A pnode running on a mobile device would run in a proxy-like mode, would start a session with a pnode that offers Layer 2 services.

PLAN's "community-private" compartmentalization is a major feature of PLAN that serves community privacy.

*/




/**********************************************************************************************************************

The purpose of this exe is to be a test/demo stand-in for the full PLAN Unity-based client.

Here's roughly what the order of events:
    1)  If not already running, the client starts a pgateway daemon
    2)  A gRPC session is started with pgateway. 
    3)  One of 2 authentication methods 
        - the client prompts the user to authenticate w/ a password that the gateway uses to unlock the personal keyring
        - the client uses their crypto device and unlocks their keyring that way
    4)  With the personal keyring unlocked, the gateway can now decrypt and encrypt community entries
    5)  pgateway starts a new session with a community pnode and authenticates by decrypting a challenge issued by pnode,
        encrypting using the client's public key
    6)  pgateway challenges the pnode back by using a key for specific pnode id.
    7)  With the pnode now verified, pgateway sends the pnode the community keyring
    8a) With the community keyring in hand, pnode can now process entries from the designated storage provider(s) in the background
        - During this time, pnode "syncs" up (relatively fast since the data is already locally within the storage layer)
    8)  The client issues channel queries and awaits decrypted entries
    9)  Pgateway passes on the clients requests to pnode
    9)  pnode sends responses (encrypted entries) to pgateway, 
    10) pgateway decrypts entries as they arrive and forwards them them to the client (decrypted)
    11)  When the client authors a new entry, it's sent to pgateway where it is encrypted and forwarded onto pnode for processing.  
    
    
The client has 3 main op modes:

A) admin mode -- assuming the user is an admin, new members can be created, etc
B) channel talk/interact mode 
    1) fetches the community registry (for step 3)
    2) opens the specified channel ID as a talk channel (hash of some input str)
    3) displays all entries in the cannel (mapping each author member ID to the member's alias using registry from step 1)
    4) newly typed entries are sent to the channel, etc
C) diagnostic (simulated traffic) mode -- sends and checks dense traffic for testing, etc.


Maybe pnode and pgateway are fused and it's storage layer this is remote (or is implmemented locally but uses RPC call to, say, matrix)


    1)  If not already running, the client starts pnode
    2)  The client starts a gRPC session is started with pnode
    3)  One of 2 authentication methods 
        - the client prompts the user to authenticate w/ a password that pnode uses to unlock the personal keyring
        - the client uses their crypto device and unlocks their keyring that way
    4)  With the personal keyring unlocked, the gateway can now decrypt and encrypt community entries and personal entries
    5a) With the community keyring in hand, pnode can now process entries from the designated storage provider(s) in the background
        - During this time, pnode "syncs" up (relatively fast since the data is already locally within the storage layer)
    6)  The client issues channel queries and awaits decrypted entries
    7)  pnode handle queries, decrypting entries on the fly and sending them to the client
    8)  When the client authors a new entry, it's sent to pnode where it is encrypted and forwarded onto pnode for processing.  


0) Unity client starts
    a) launches local pgateway
    b) which community IDs to unlock (and pw for each)
    c) pgateway.StartSession() w/ pws encrypted by pgateway's private key (a KeyList with an SKI invocation that makes is a key loaders)
1) pgateway instantiates new SKI provider based on 0.(c)
    a) provider loads keyrings from disk, dencrypting each w/ the given pws
    b) pgateway now has full user keyrings
2) gateway logs into pnode(s), passing it itx txn signing key 
3) newly authored entries are authored in the client and sent to pgateway
4) new entries are encrypted and signed with the gateway's keys
5) new entries are packaged into a plan.Block and committed to the StorageProvider. 

*/
