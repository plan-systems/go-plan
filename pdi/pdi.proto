// See plan-tools/plan-protobuf/README.md

syntax = "proto3";

package pdi;

import "github.com/plan-tools/go-plan/plan/plan.proto";


/**********************************************************************************************************************
A channel's access control channel effectively specifies an privilege access level for all member IDs in the community. 

A channel designated as an access control channel can be used for any number of channels, 
effectively allowing channels used to control access more multiple channels.  This "comes for free" since
access control channels don't contain any references to channels that use them to control access. */

enum ChannelAccess {

    // Not used
    NO_ACCESS                   = 0;

    // Has crypto to decrypt entries from the given channel
    READ_ACCESS                 = 1;

    // Permitted to author: POST_NEW_CONTENT, REMOVE_ENTRIES (for self), SUPERCEDE_ENTRY (for self) 
    READWRITE_ACCESS            = 2;

    // Permitted to author: POST_NEW_CONTENT, REMOVE_ENTRIES (for all), SUPERCEDE_ENTRY (for all), EDIT_CHANNEL_INFO, EDIT_ACCESS_GRANTS
    MODERATOR_ACCESS            = 3;

    // Same as MODERATOR_ACCESS plus can grant others MODERATOR_ACCESS and can issue EDIT_ACCESS_GRANTS
    SUPER_MODERATOR_ACCESS      = 4;

    // Same as SUPER_MODERATOR_ACCESS plus can grant others SUPER_MODERATOR_ACCESS and can author entry type NEW_CHANNEL_EPOCH
    ADMIN_ACCESS                = 5;

}


/**********************************************************************************************************************
EntryOp specifies a specific flavor of PDI transaction.  Although the PLAN UI will not allow the user to things 
she doesn't have permission to do, every pnode in the community rigorously verifies that the author of any given 
PDI entry has the permission they imply they do with the given entry they authored.  */

enum EntryOp {

    /*****************************************************
    ** Ops for ANY channel type
    **/

    // Appends this content entry to the specified channel.
    POST_NEW_CONTENT            = 0;

    // This entry's body lists one or more channel entries to effectively mark as removed/invisible.
    REMOVE_ENTRIES              = 1;

    // This entry's body should effectively replace a specified previous entry
    SUPERCEDE_ENTRY             = 2;

    /*  - This entry modifies one or more of a given channel's meta fields (e.g. channel description, icon, etc).
        - A ChannelInfo snapshot/composite can be reconstructed by sequentially applying every EDIT_CHANNEL_INFO 
    change to the previous ChannelInfo composite up to the present time.
        - Only channel admins or moderators are permitted to originate this op. */
    EDIT_CHANNEL_INFO           = 3;

    // This entry initiates a new channel epoch, inserting one or more changes to the channel's current ChannelEpoch.
    // This op is mostly issued to access channels since a new epoch is only needed in order to rekey a private access channel.
    // Only channel admins are permitted to originate this op.
    NEW_CHANNEL_EPOCH           = 4;


    /*****************************************************
    ** Ops for access channels ONLY 
    **/

    // Adds or removes access to given member IDs or wildcards.  Notes:
    //   - This entry type is only valid for use channels that are access control channels.
    //   - Members with MODERATOR_ACCESS can only grant/revoke READ_ACCESS and READWRITE_ACCESS.
    //   - Members with ADMIN_ACCESS can grant/revoke up to and including SUPER_MODERATOR_ACCESS.
    //   - ADMIN_ACCESS can ONLY be granted by members with ADMIN_ACCESS in the parent access control channel.
    //   - In some cases, this entry type MAY result a new channel epoch to be initiated (this is because
    //     a private channel must issue and distribute a new channel encryption key in order to effectively 
    //     remove access to members that are longer have channel access).
    EDIT_ACCESS_GRANTS          = 5;

}





// /plan/community/member/epoch
message MemberEpoch {

    // Random "name" for this member epoch -- must be unique for a member's epoch history (and not 0).  
                fixed64         epoch_id                = 1;

    // Names the previous epoch.  Set to 0 if there was no previous epoch.
                fixed64         prev_epoch_id           = 2;

    // Unix timestamp when this epoch entered into effect
                int64           time_started            = 3;

    // Specifies a UTF8 textual label that this member chooses to appear as in the community.
                string          alias                   = 4;

    // Public keys associated with the given revision
                bytes           pub_signing_key         = 5;
                bytes           pub_crypto_key          = 6;

    // The ChannelID of this member's "about" channel
                bytes           about_channel_id        = 7;

    // The ChannelID of this member's home channel -- where visitors should first go
                bytes           home_channel_id         = 8;

    // Future-proofing
                plan.Block      extensions              = 9;

}





message AccessGrant {

    // Specifies an access level granted to the liven list of grantees. If a pnode sees an access grant given by a member who does
    // not have permission to do so, the entry will be rejected. 
                ChannelAccess   access_grant            = 1;


    // This is a list of community member IDs being given the specified access grant. 
    // Note: if grantees[0] == "*" AND access_grant <= MODERATOR_ACCESS, then the grant implicitly applies to ALL community members. 
    repeated    bytes           grantees                = 2;

}



/*
    ChannelEpoch contains critical and security-related properties about a channel and is king while in effect.
    Other than access grants given or taken away, a ChannelEpoch is immutable and only a NEW_CHANNEL_EPOCH op can change things.
*/
message ChannelEpoch {

    // Random "name" for this channel epoch -- must be unique for a channel's epoch history (and not 0). 
                fixed64         epoch_id                    = 1;

    // Unix timestamp when this epoch entered into effect
                int64           time_started                = 2;

    // Names the previous epoch.  0 if there was no previous epoch.
                fixed64         prev_epoch_id               = 3;

    // Number of seconds the previous epoch can alternatively be used in place of this epoch.
                int32           epoch_transition_period     = 4;

    /*  Top-level string describing how entries on this channel are expected to conform.
        This allows a PLAN client to invoke the appropriate UI and data handlers. 
        e.g. 
            /plan/channel-protocol/talk/2
            /plan/channel-protocol/inventory/1   
            /plan/channel-protocol/cryptokitty/browser    */
                string          protocol                    = 5;

            // Specifies the channel that is serving as this channel's access control channel (and has entries that conform to that spec)
                bytes           access_channel_id           = 6;

    // If set, channel entries are not allowed to be removed/superceded.
                bool            entries_are_locked          = 7;

    // If set, entries_are_locked must/will always be true.
                bool            entries_are_locked_forever  = 8;

    // If set, pnodes with web services running will attempt to share this channel to outside the community
                bool            is_externally_shared        = 9;
                        
    /*  If set, this channel can be used to validate EntryOps applied to other channels (including other access channels).
        Entries in an access channel conform to a specific protocol and serve to:
            (a) allow one or more other channels to cite this channel as their access control (access_channel_id)
            (a) transport private channel keys and grants to community members that have been given access to this channel (by encrypting a channel's key using a member's public key)
            (b) publish and transfer write-access and ownership permissions to others (only permitted by owners)  */
                bool            is_access_channel           = 10;

    // Contains all the access grants published via EDIT_ACCESS_GRANTS sent to this channel (during this epoch).
    // If this channel is NOT an access channel (is_access_channel == false), then this field == nil
    repeated    AccessGrant     access_grants               = 11;

    // Future-proofing
                plan.Block      extensions                  = 12;

}



message ChannelInfo {

    // This channel ID (immutable)
                bytes           channel_id              = 1;

    // Container for all content-level properties (e.g. channel title, description, etc) 
                uint32          info_rev                = 7;
                plan.Block      info                    = 8;


}






message ChannelList {
    repeated    ChannelInfo     channels                = 1;
}


enum EntryVersion {
    V0                          = 0;
}



// Entry is a convenience container for the pieces/parts that a PDI entry may be at during processing or transmission.
message Entry {
                EntryCrypt      crypt                   = 1;
                EntryHeader     header                  = 2;
                plan.Block      body                    = 3;
}



/*
    EntryCrypt is the "wire" format for PLAN's Persistent Data Interface (PDI) entries.  It contains no revealing information and
    is what's sent to/from community data store replicators, such as NEM, DFINITY, and Ethereum.
*/
message EntryCrypt {
                uint64          crypt_info              = 1;        // Allows accessors to apply correct hash and crypto functions to this EntryCrypt 
                bytes           community_key_id        = 3;        // Needed to access header_crypt
                bytes           header_crypt            = 5;        // := Encrypt(<EntryHeader>.Marshal(), <EntryCrypt>.community_key_id)
                bytes           body_crypt              = 6;        // := Encrypt(<Body>.Marshal(), <EntryHeader>.body_key_id)
                bytes           sig                     = 7;        // := ComputeSig(<EntryCrypt>, GetKey(author_member_id,author_member_rev))
}


/*
    An encrypted PDI entry has two segments, its header and "body" (content) block.  The header, EntryHeader, is "community-private",
    meaning that it is encrypted using one of the community's shared symmetric keys.  The entry's body is either also community-private
    (encrypted with the same community key as EntryHeader), or it is encrypted using the key referenced by body_key_id.

    When a entry is authored, it is intended to be posted to the channel specified by EntryHeader.channel_id.  The current rev of that
    channel is also listed so that pdi nodes know which channel access rev to use when checking permissions.  
*/
message EntryHeader {
                int64           time_authored           = 1;        // Unix timestamp -- UTC in seconds elapsed since Jan 1, 1970.
                fixed32         time_authored_ns        = 2;        // [0,999999999] -- serves 
                int64           time_sealed             = 3;        // Unix timestamp
                EntryOp         entry_op                = 4;
                bytes           channel_id              = 5;        // Channel id this entry is posted to.
                fixed64         channel_epoch_id        = 6;        // Epoch of this channel in effect when this entry was sealed
                bytes           author_member_id        = 7;        // Creator of this entry (and signer of .Sig)
                fixed64         author_member_epoch     = 8;        // Which rev of the author's identity was used for encryption (or 0 if n/a)
                bytes           body_key_id             = 10;       // Specifies which key was used to encrypt 
                plan.Block      extensions              = 11;       // Available for unrestricted client use.
}





/*
enum TxnDataDesc {

    // The txn data has been omitted 
    DATA_OMITTED                = 0;

    // The segments, when reassembled together, form EntryCrypt.Marshal()
    PDI_ENTRY_CRYPT             = 1;

}
*/


// TxnStatus describes how far along a StorageTxn is on being stored on a PDI StorageProvider.
// Note: odd values reflect an error state
enum TxnStatus {

    // The txn is yet to be committed to storage
    AWAITING_COMMIT             = 0;

    // The txn has been committed and is in the process of being stored
    COMMITTING                  = 2;

    // The txn is yet to be committed to storage
    INVALID_TXN                 = 3;

    // This txn was lost or is otherwise not available 
    LOST                        = 5;

    // This txn has failed to commit because of an error (or the storage provider rejected it for some reason) 
    FAILED_TO_COMMIT            = 7;

    // The txn has been committed and has been confirmed as stored (but could still potentially be reverted)
    COMMITTED                   = 8;

    // The txn was confirmed COMMITTED earlier in time, but has since been revoked (and is in an equiivalent state to AWAITING_COMMIT)
    REVOKED                     = 9;

    // The txn has been committed, confirmed as stored, and faces no possibility of being reverted.
    FINALIZED                   = 16;

}



message StorageTxn {

    // Issued by the storage layer (not storage clients) some time after StorageSession.Commit()
    // Since a StorageProvier creates/assigns txn names, they can be any length (typically 8 to 32 bytes),
    //    but the length is *never* changes when a StorageProvier inits a new repo.
                bytes           txn_name                    = 1;

    // Unix timestamp of when this txn was committed for storage (0 if not committed)
                int64           time_committed              = 2;

    // Consensus-based unix timestamp for this txn (or 0 if not available).  
    // If txn_status == FINALIZED, then this timestamp:
    //      - won't ever change, 
    //      - is universal across storage peers
    //      - is trustworthy
                int64           time_consensus              = 3;

    // Describes the state of this txn segment number
                TxnStatus       txn_status                  = 4;

    // Txn payload (in PLAN, one or more serialized pdi.EntryCrypt)
                plan.Block      body                        = 5;     
}




