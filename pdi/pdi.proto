// See http://github.com/plan-systems/plan-protobufs/

syntax = "proto3";

package pdi;

import "github.com/plan-systems/go-plan/plan/plan.proto";
import "github.com/plan-systems/go-plan/ski/ski.proto";
import "github.com/plan-systems/go-plan/pservice/pservice.proto";




enum PayloadCodec {

    Unspecified             = 0;

    // A protobufs-encoded plan.Block
    PbBlock                 = 1;

    // A protobufs-encoded pdi.EntryCrypt
    PbEntryCrypt            = 2;

}


/**********************************************************************************************************************
A StorageProvider daemon sits on top or alongside a storage system.  It serves as an access
point to a community's shared data store, and a community's member nodes use a StorageProvider to:
    - Submit newly authored (and sealed) txns to the community's shared data store.
    - Query and receive txns that have been newly added or in the past. 
    
In order to allow a StorageProvider to be implemented by an append-only distributed ledger, 
newly submitted txns must already be ready to be committed to the the underlying storage implementation.

This means that for every StorageProvider implementation, there is an accompanying txn marshalling encoder
and decoder (TxnEncoder and TxnDecoder)

See go-plan/pdi/StorageProvider.go. */
service StorageProvider {

    // Starts a new client session.
    rpc         StartSession(pservice.SessionRequest)           returns (StorageSession);

    // Requests a sequence of txns starting with the specified time, txn name, bookmark, or other query criteria.
    rpc         Query(QueryTxns)                                returns (stream TxnBundle);

    // Submits a txn ready to be written to the StorageProvider's permanent txn store.
    // RawTxn is generated by this StorageProvider's corresponding TxnEncoder.
    rpc         CommitTxn(RawTxn)                               returns (stream TxnMetaInfo);


}

message StorageSession {

    // Identifies which TxnEncoder should be used to encode txn submitted via CommitTxn()
                string          encoder_invocation      = 1;
}



// RawTxn is a storage transaction intended for a given StorageProvider network/instance.
message RawTxn {

    // Native txn data (already conforms to native txn requirements, e.g. native max size)
                bytes           txn_data                = 1;
}

// Txn contains a readied txn native to the StorageProvider it is being submitted to or received from.
message Txn {

    // Info about raw_txn -- can always be regenerated via TxnDecoder.DecodeRawTxn()
                TxnInfo         txn_info                = 1;

    // Info about the status of the associated txn
                TxnMetaInfo     txn_meta_info           = 2;

    // Raw native txn data (already conforms to native txn requirements, e.g. native max size)
                bytes           raw_txn                 = 3;

}

// TxnMetaInfo is information *about* the status of a transaction 
message TxnMetaInfo {

   // Status information about the associated txn
                TxnStatus       txn_status              = 1;

    // Contains additional alert or status information
                plan.Status     alert                   = 2;

    // Consensus-based unix timestamp for this txn (or 0 if not available).  
    // If txn_status == FINALIZED, then this timestamp:
    //      - won't ever change, 
    //      - is universal across storage peers
    //      - is trustworthy
                int64           time_consensus          = 3;
}



// TxnInfo contains information derivable from EACH native/raw txn.
// It's typically used during txn processing or _about_ a Txn being processed.
message TxnInfo {

    // Segment info
                TxnSegInfo      seg_info                = 1;

    // ID/address/pubkey that is posting the to-be txn.  
                ski.PubKey      from                    = 2;

    // Transfer(s) (optional)
    repeated    Transfer        transfers               = 3;

    // TxnHashname is a hash digest of a to-be signed raw txn.  It is generated by TxnEncoder.EncodeToTxns()
    // This field is nil until the txn is packed since a hash digest isn't knowable until then.
                bytes           txn_hashname            = 8;

    // Unix timestamp of when this txn was signed for storage (or 0 if not available)
                int64           time_sealed             = 9;

    // Specifies which hash kit was (or should be) used to generate the sig for this txn
                ski.HashKitID   hash_kit_id             = 10;

}



enum Currency {

    // Gas is the unit of account for a txn to be committed to a StorageProvider.
    // Txns generally "cost" gas proportional to the byte size of the raw txn.
    Gas                     = 0;

    // CommunityFiat is an arbitrary unit for the community's coinage.
    CommunityFiat           = 1;


}


message Transfer {

    // Recipient
                ski.PubKey      to                      = 1;

   // Unit type string description (optional)
                Currency        currency                = 2;

    // Amount of transfer
                int64           amount                  = 3;

}





// TxnSegment represents part (or all) of the payload data in a RawTxn.  Although a TxnEncoder internally
//     encodes a TxnSegment into a Txn to be signed, that can only happen after the agent has segmented the payload 
//     buffer into sizes appropriate for storage medium. 
// For example, the Ethereum agent must break the payload into 31k pieces so that the byte size of 
//     Txn.TxnData is strictly less than 32k (Ethereum's txn size limit). 
message TxnSegment {

    // Segment info
                TxnSegInfo      seg_info                = 1;

    // The original payload is reconstructed by concatenating each TxnSegment.Data together.  
                bytes           seg_data                = 3;

}

// TxnSegInfo heads each segment 
message TxnSegInfo {

    // Describes how to to decode the payload data (this value is identical for each segment that comprises a reassembled payload)
                PayloadCodec    payload_codec           = 1;

    // Arbitrary binary label passed to TxnEncoder.EncodeToTxns() when this txn (and its other segments) were created.
    // During segment reassembly, it's used to sort out which segments belong with which other segments.
                bytes           payload_label           = 2;

    // Payload byte size 
                int32           payload_length          = 3;
                
    // Segment byte size 
                int32           segment_length          = 4;

    // When a client payload is large, it must be split into multiple native txns.
    // This info specifies which segment this is and how many total segments there are.
                uint32          segment_num             = 5;
                uint32          total_segments          = 6;
}



/*


message TxnCandidate {

    // ID/address/pubkey that will posting the to-be txn.  
                ski.PubKey      from                    = 1;

    // This will become the txn body -- sent via SubmitTxn()
    // This can be anything, but in practice it typically contains one or more serialized pdi.EntryCrypt.
                plan.Block      body                    = 2;

}

message StagedTxn {

    // Reports any error/state condition.
                plan.Status     status                  = 1;
                
    // Once the StorageProvider prepares/processes the txn body from SubmitTxn() into a native SP txn internally, 
    //    the native txn(s) needs to be signed since the ledger/authority it's using presumably requires that.
    // This happens by the SP handing back digest(s) for the client to sign.
                ski.SigBlock    sig_block               = 2;

}*/


message QueryTxns {

    // If set, unix timestamp in secs of the commit time of txn(s) to be read
                int64           time_committed          = 1;

   // If set, this is the txn name to be fetched.  
   // If omitted, all txns with the matching time committed. 
                bytes           txn_hashname            = 2;

    // If true, Txn.RawTxn will be set/sent for each txn returned.
    // If false, Txn.RawTxn == nil for each txn returned (saving bandwidth)
                bool            include_body            = 3;

    // If > 0, this caps the the number of txns returned until the requested is considered complete.
                uint64          max_txns                = 4;

    // If set, this specifies a state "bookmark" for the StorageProvider to resume reading from.
                plan.Block      bookmark                = 5;
}



message TxnBundle {

    // Zero or more txns
    repeated    Txn             txns                    = 1;

    // Intended to be passed in pdi.Query in order for a client to resume a txn stream/sequence -- optional.  
    // This Block is intended to be used by the originating StorageProvider, so it's opaque as far as the client is concerned.
                plan.Block      bookmark                = 2;

}




message StorageAccount {

    // Net gas available to be spent
                int64           gas_balance               = 1;

    // Community fiat available to be spent
                int64           fiat_balance              = 2;

}




// TxnStatus describes how far along a StorageTxn is on being stored on a PDI StorageProvider.
// Note: odd values reflect an error state
enum TxnStatus {

    // The txn is yet to be committed to storage
    AWAITING_COMMIT             = 0;

    // The txn has been committed and is in the process of being stored
    COMMITTING                  = 2;

    // This txn was lost or is otherwise not available 
    LOST                        = 5;

    // This txn has failed to commit because of an error (or the storage provider rejected it for some reason) 
    FAILED_TO_COMMIT            = 7;

    // The txn has been committed and has been confirmed as stored (but could still potentially be reverted)
    COMMITTED                   = 8;

    // The txn was confirmed COMMITTED earlier in time, but has since been revoked (and is in an equivalent state to AWAITING_COMMIT)
    REVOKED                     = 9;

    // The txn has been committed, confirmed as stored, and faces no possibility of being reverted/revoked.
    FINALIZED                   = 16;

}







/**********************************************************************************************************************
A channel's access control channel effectively specifies an privilege access level for all member IDs in the community. 

A channel designated as an access control channel can be used for any number of channels, 
effectively allowing channels used to control access more multiple channels.  This "comes for free" since
access control channels don't contain any references to channels that use them to control access. */

enum ChannelAccess {

    // Not used
    NO_ACCESS                   = 0;

    // Has crypto to decrypt entries from the given channel
    READ_ACCESS                 = 1;

    // Permitted to author: POST_NEW_CONTENT, REMOVE_ENTRIES (for self), SUPERCEDE_ENTRY (for self) 
    READWRITE_ACCESS            = 2;

    // Permitted to author: POST_NEW_CONTENT, REMOVE_ENTRIES (for all), SUPERCEDE_ENTRY (for all), EDIT_CHANNEL_INFO, EDIT_ACCESS_GRANTS
    MODERATOR_ACCESS            = 3;

    // Same as MODERATOR_ACCESS plus can grant others MODERATOR_ACCESS and can issue EDIT_ACCESS_GRANTS
    SUPER_MODERATOR_ACCESS      = 4;

    // Same as SUPER_MODERATOR_ACCESS plus can grant others SUPER_MODERATOR_ACCESS and can author entry type NEW_CHANNEL_EPOCH
    ADMIN_ACCESS                = 5;

}


enum EntryStatus {

    UNSPECIFIED                 = 0;

    // The given entry is considered authentic and a live operating part of the local community repo.
    LIVE                        = 1;

    // The given entry is currently in conflict with another entry having equal authority.
    AMBIGUOUS_CONFLICT          = 2;

    // The given entry is deferred as a result of one of many possibilities encountered during 
    //    Channel Entry Validation (see design-docs/PLAN-Proof-of-correctness.md).
    DEFERRED                    = 3;

    // The given entry is currently in conflict with its channel's parent access control channel.
    DISALLOWED                  = 4;

    // The given entry has been confirmed to be associated with unauthorized activity, a security breach, or inappropriate behavior.
    DISBARRED                   = 5;

    // One or more parts of this entry are not self-consistent or does not self-validate.
    MALFORMED                   = 6;

}


/**********************************************************************************************************************
EntryOp specifies a specific flavor of PDI transaction.  Although the PLAN UI will not allow the user to things 
she doesn't have permission to do, every pnode in the community rigorously verifies that the author of any given 
PDI entry has the permission they imply they do with the given entry they authored.  */

enum EntryOp {

    /*****************************************************
    ** Ops for ANY channel type
    **/

    // Appends this content entry to the specified channel.
    POST_CONTENT                = 0;

    // This entry's body lists one or more channel entries to effectively mark as removed/invisible.
    REMOVE_ENTRIES              = 1;

    // This entry's body should effectively replace a specified previous entry
    SUPERCEDE_ENTRY             = 2;

    /*  - This entry modifies one or more of a given channel's meta fields (e.g. channel description, icon, etc).
        - A ChannelInfo snapshot/composite can be reconstructed by sequentially applying every EDIT_CHANNEL_INFO 
    change to the previous ChannelInfo composite up to the present time.
        - Only channel admins or moderators are permitted to originate this op. */
    EDIT_CHANNEL_INFO           = 3;

    // This entry initiates a new channel epoch, inserting one or more changes to the channel's current ChannelEpoch.
    // This op is mostly issued to access channels since a new epoch is only needed in order to rekey a private access channel.
    // Only channel admins are permitted to originate this op.
    NEW_CHANNEL_EPOCH           = 4;


    /*****************************************************
    ** Ops for access channels ONLY 
    **/

    // Adds or removes access to given member IDs or wildcards.  Notes:
    //   - This entry type is only valid for use channels that are access control channels.
    //   - Members with MODERATOR_ACCESS can only grant/revoke READ_ACCESS and READWRITE_ACCESS.
    //   - Members with ADMIN_ACCESS can grant/revoke up to and including SUPER_MODERATOR_ACCESS.
    //   - ADMIN_ACCESS can ONLY be granted by members with ADMIN_ACCESS in the parent access control channel.
    //   - In some cases, this entry type MAY result a new channel epoch to be initiated (this is because
    //     a private channel must issue and distribute a new channel encryption key in order to effectively 
    //     remove access to members that are longer have channel access).
    EDIT_ACCESS_GRANTS          = 5;

}





// /plan/community/member/epoch
message MemberEpoch {

    // Random "name" for this member epoch -- must be unique for a member's epoch history (and not 0).  
                fixed64         epoch_id                = 1;

    // Names the previous epoch.  Set to 0 if there was no previous epoch.
                fixed64         prev_epoch_id           = 2;

    // Unix timestamp when this epoch entered into effect
                int64           time_started            = 3;

    // Specifies a UTF8 textual label that this member chooses to appear as in the community.
                string          alias                   = 4;

    // Public keys associated with the given revision
                bytes           pub_signing_key         = 5;
                bytes           pub_crypto_key          = 6;

    // The ChannelID of this member's "about" channel
                bytes           about_channel_id        = 7;

    // The ChannelID of this member's home channel -- where visitors should first go
                bytes           home_channel_id         = 8;

    // Future-proofing
                plan.Block      extensions              = 9;

}





message AccessGrant {

    // Specifies an access level granted to the liven list of grantees. If a pnode sees an access grant given by a member who does
    // not have permission to do so, the entry will be rejected. 
                ChannelAccess   access_grant            = 1;


    // This is a list of community member IDs being given the specified access grant. 
    // Note: if grantees[0] == "*" AND access_grant <= MODERATOR_ACCESS, then the grant implicitly applies to ALL community members. 
    repeated    bytes           grantees                = 2;

}



/*
    ChannelEpoch contains critical and security-related properties about a channel and is king while in effect.
    Other than access grants given or taken away, a ChannelEpoch is immutable and only a NEW_CHANNEL_EPOCH op can change things.
*/
message ChannelEpoch {

    // Random "name" for this channel epoch -- must be unique for a channel's epoch history (and not 0). 
                fixed64         epoch_id                    = 1;

    // Unix timestamp when this epoch entered into effect
                int64           time_started                = 2;

    // Names the previous epoch.  0 if there was no previous epoch.
                fixed64         prev_epoch_id               = 3;

    // Number of seconds the previous epoch can alternatively be used in place of this epoch.
                int32           epoch_transition_period     = 4;

    /*  Top-level string describing how entries on this channel are expected to conform.
        This allows a PLAN client to invoke the appropriate UI and data handlers. 
        e.g. 
            /plan/channel-protocol/talk/2
            /plan/channel-protocol/inventory/1   
            /plan/channel-protocol/cryptokitty/browser    */
                string          protocol                    = 5;

            // Specifies the channel that is serving as this channel's access control channel (and has entries that conform to that spec)
                bytes           access_channel_id           = 6;

    // If set, channel entries are not allowed to be removed/superceded.
                bool            entries_are_locked          = 7;

    // If set, entries_are_locked must/will always be true.
                bool            entries_are_locked_forever  = 8;

    // If set, nodes with web services running will attempt to share this channel to outside the community
                bool            is_externally_shared        = 9;
                        
    /*  If set, this channel can be used to validate EntryOps applied to other channels (including other access channels).
        Entries in an access channel conform to a specific protocol and serve to:
            (a) allow one or more other channels to cite this channel as their access control (access_channel_id)
            (a) transport private channel keys and grants to community members that have been given access to this channel (by encrypting a channel's key using a member's public key)
            (b) publish and transfer write-access and ownership permissions to others (only permitted by owners)  */
                bool            is_access_channel           = 10;

    // Contains all the access grants published via EDIT_ACCESS_GRANTS sent to this channel (during this epoch).
    // If this channel is NOT an access channel (is_access_channel == false), then this field == nil
    repeated    AccessGrant     access_grants               = 11;

    // Future-proofing
                plan.Block      extensions                  = 12;

}



message ChannelInfo {

    // This channel ID (immutable)
                bytes           channel_id              = 1;

    // Container for all content-level properties (e.g. channel title, description, etc) 
                uint32          info_rev                = 7;
                plan.Block      info                    = 8;


}






message ChannelList {
    repeated    ChannelInfo     channels                = 1;
}


enum EntryVersion {
    V0                          = 0;
}



// Entry is a convenience container for the pieces/parts that a PDI entry may be at during processing or transmission.
message Entry {
                EntryCrypt      crypt                   = 1;
                EntryHeader     header                  = 2;
                plan.Block      body                    = 3;
}



/*
    EntryCrypt is the "wire" format for PLAN's Persistent Data Interface (PDI) entries.  It contains no revealing information and
    is what's sent to/from community data store replicators, such as NEM, DFINITY, and Ethereum.
*/
message EntryCrypt {
                uint64          crypt_info              = 1;        // Allows accessors to apply correct hash and crypto functions to this EntryCrypt 
                bytes           community_key_id        = 3;        // Needed to access header_crypt
                bytes           header_crypt            = 5;        // := Encrypt(<EntryHeader>.Marshal(), <EntryCrypt>.community_key_id)
                bytes           body_crypt              = 6;        // := Encrypt(<Body>.Marshal(), <EntryHeader>.body_key_id)
                bytes           sig                     = 7;        // := ComputeSig(<EntryCrypt>, GetKey(author_member_id,author_member_epoch))
}


/*
    An encrypted PDI entry has two segments, its header and "body" (content) block.  The header, EntryHeader, is "community-private",
    meaning that it is encrypted using one of the community's shared symmetric keys.  The entry's body is either also community-private
    (encrypted with the same community key as EntryHeader), or it is encrypted using the key referenced by body_key_id.

    When a entry is authored, it is intended to be posted to the channel specified by EntryHeader.channel_id.  The current rev of that
    channel is also listed so that pdi nodes know which channel access rev to use when checking permissions.  
*/
message EntryHeader {
                int64           time_authored           = 1;        // Unix timestamp -- UTC in seconds elapsed since Jan 1, 1970.
                fixed32         time_authored_ns        = 2;        // [0,999999999] -- serves 
                int64           time_sealed             = 3;        // Unix timestamp
                EntryOp         entry_op                = 4;
                bytes           channel_id              = 5;        // Channel that this entry is posted to.
                fixed64         channel_epoch_id        = 6;        // Epoch of the channel in effect when this entry was sealed
                bytes           author_member_id        = 7;        // Creator of this entry (and signer of .Sig)
                fixed64         author_member_epoch     = 8;        // Epoch of the author's identity when this entry was sealed
                bytes           body_key_id             = 10;       // Specifies which key was used to encrypt EntryCrypt.body_crypt
                plan.Block      extensions              = 11;       // Available for unrestricted client use.
}



