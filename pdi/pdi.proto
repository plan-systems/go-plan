// See http://github.com/plan-systems/plan-protobufs/

syntax = "proto3";

package pdi;

import "github.com/plan-systems/go-plan/plan/plan.proto";
import "github.com/plan-systems/go-plan/ski/ski.proto";





/**********************************************************************************************************************
A StorageProvider is an access point to a community's append-only shared persistent data store. 
In addition to being a repository of community member txns, a StorageProvider (or set of
StorageProviders), serve as the community's validators.  This means they:
    (a) authenticate that a txn is officially part of the community record, and 
    (b) seal *when* a txn became part of the record (preventing inside "submarine" txns)  
    
Although the StorageProvider abstraction is *modeled* after a blockchain (an append-only ledger),
its implementation can either be centralized *or* decentralized.  This means a StorageProvider
implementation could be a blockchain or a conventional centralized server/cluster.

So in the StorageProvider model (as with a conventional blockchain model) trust is externalized
to outside the system by use of StorageProvider-maintained units of account: 
    (1) Kb - Number of kilobytes of txn data a given address can post.
    (2) Op - Number of "operations" a given address can perform.  Posting a new txn "costs" 1 Op.
These units of account are solely a mechanism for controlling who has append access to the community's shared data store.

See go-plan/pdi/StorageProvider.go. */
service StorageProvider {

    // Starts a new client session.
    rpc         StartSession(SessionReq)                        returns (StorageInfo);

    // Requests a sequence of txns within a specified time window and other query criteria.
    rpc         Scan(TxnScan)                                   returns (stream TxnList);

    // Requests a given set of txns to be sent back to the client
    rpc         SendTxns(TxnList)                               returns (stream RawTxn);

    // Submits a txn ready to be written to the StorageProvider's permanent txn store.
    // RawTxn is generated by this StorageProvider's corresponding TxnEncoder.
    // For each StorageProvider implementation, one uses the accompanying txn marshalling encoder
    //    and decoder (TxnEncoder and TxnDecoder).
    rpc         CommitTxn(RawTxn)                               returns (plan.Status);


    // TODO: SPs can offer peer discovery services

}



message SessionReq {

    // The requested storage epoch to be accessed.
                StorageEpoch    storage_epoch           = 1;

    // An empty but signed txn that demonstrates to the host StorageProvider that the client
    //    has an active account with this storage provider.
                RawTxn          proof_of_access         = 2;     

}




message StorageInfo {

    // This is a sig of SessionReq.ProofOfAccess, signed with the latest StorageProvider key.
    // This authenticates this StorageProvider (since a 3rd party attempting to impersonate a StorageProvider
    //    node would be unable to produce this signature).   
                bytes           sig_response           = 1;     


}



// TxnInfo contains information derivable from EACH native/raw txn.
// It's used during txn processing or _about_ a Txn being processed.
// Although a TxnEncoder internally encodes a payload segment into a Txn to be signed, 
//     that can only happen after the agent has segmented the payload 
//     buffer into sizes appropriate for storage medium. 
// For example, the Ethereum agent must break the payload into 31k pieces so that the byte size of 
//     Txn.TxnData is strictly less than 32k (Ethereum's txn size limit).
message TxnInfo {

    /*****************************************************
    ** StorageProvider Use
    **/

    // Transfer(s) (optional)
    repeated    Transfer        transfers               = 2;

    /*****************************************************
    ** Contents Info
    **/

    // Describes how to to decode the payload data (this value is identical for each segment that comprises a reassembled payload)
    // This should be identical for each segment
                plan.Encoding   payload_encoding        = 5;

    // Segment byte size
                uint32          seg_sz                  = 8;

    // When a client payload is large, it must be split into multiple native txns.
    // This info specifies which segment this is and how many total segments there are.
    // Note: SegmentIndex uses zero-based indexing 
                uint32          seg_index               = 9;
                uint32          seg_total               = 10;

    // Txn URID of the segment preceding this one (or nil if this is the first segment)
    // This allows an entire segment chain to be implicitly specified via the URID of the last segment.
                bytes           prevURID                = 11;

    // Unix timestamp of when this txn was encoded and signed for storage.
                int64           time_sealed             = 12;

    // Links this txn to a specific payload.
                bytes           payload_URID            = 13;


    /*****************************************************
    ** Regenerated Info (nil when encoding)
    **/

    // Address/pubkey that signed this txn
                bytes           from                    = 20;

    // A hash digest of a packed and readied raw txn.  It is generated by TxnEncoder.EncodeToTxns()
    // This is nil in packaged txns since its hash digest isn't knowable until after the txn is packaged.
                bytes           txn_hashname            = 21;

    // Binary URID of this txn, derived from time_sealed and txn_hashname.
                bytes           URID                    = 22;

}


message Transfer {

    // Pubkey/address of the recipient
                bytes           to                      = 1;

    // Kb is the storage unit of account on a StorageProvider.
    // Each txn "costs" Kb for each kb size of the txn.
                int64           kb                      = 2;

    // Ops refers to the energy and processing cost for operations requested of a StorageProvider (typically a txn commit)
    // Each txn committed "costs" 1 op for example.
                int64           ops                     = 3;
}



// RawTxn reflects a txn native to/from a community's StorageProvider network.
message RawTxn {

    // Always generate (or confirm) locally for security (set to nil for transport)
                bytes           URID                    = 1;

    // Info about the status this txn.  
    // Set to nil if n/a or if txn is not yet committed.
                TxnMetaInfo     txn_meta_info           = 2;

    // Raw native txn data and conforms to all native txn requirements (e.g. native max size).
                bytes           bytes                   = 3;

}


// TxnMetaInfo is information *about* the status of a transaction 
message TxnMetaInfo {

    // Txn ID
                bytes           URID                    = 1;

   // Status information about the associated txn
                TxnStatus       txn_status              = 2;

    // Contains additional alert or status information
                plan.Status     alert                   = 3;

    // Consensus-based unix timestamp for this txn (or 0 if not available).  
    // If txn_status == FINALIZED, then this timestamp:
    //      - won't ever change, 
    //      - is universal across StorageProvider peers
    //      - is as trustworthy as the StorageProvider network.
                int64           consensus_time          = 4;

    // Proof that this txn was indeed received and validated by a valid StorageProvider.
                bytes           txn_validation          = 5;
}






message TxnScan {

    // Specifies the bounding timestamps (TxnInfo.TimeSealed) of txns to consider (inclusive).
                int64           timestamp_start         = 1;
                int64           timestamp_stop          = 2;
  
    // If set, this query will remain active/open even after there are no more entries to return.
    // All txn status changes or updates will be reported, regardless of timestamp.
    // This is a how client is notified about newly committed txns and status changes in previously committed txns.
                bool            send_txn_updates        = 5;    

    // If > 0, this limits the the number of txn URIDs returned until the request is considered complete.
                int32           max_txns                = 7;

}

message TxnList {

    // Batch of txn URIDs (binary form)
    // Entries that are zero-length should be considered valid "no-ops".
    repeated    bytes           URIDs                   = 2;

    // len(statuses) == len(URIDs): the ith byte of is the TxnStatus of URIDs[i].
    // Note: this field is ignored for SendTxns() 
                bytes           statuses                = 3;
}


message StorageAccount {

    // Kilobytes able to be used for txns
                int64           kb_balance              = 1;

    // Number of "operations" able to be posted to a StorageProvider network.
                int64           op_balance             = 2;

    // Set if this account is permitted to transfer to other accounts.
                bool            can_transfer            = 3;

}




// TxnStatus describes the status of a txn on a StorageProvider.
// Note: odd values reflect an error state
enum TxnStatus {

    // The txn is yet to be committed to storage
    AWAITING_COMMIT             = 0;

    // The txn is in the process of being committed
    COMMITTING                  = 2;

    // This txn was lost or is otherwise not available 
    LOST                        = 5;

    // This txn has failed to commit because of a server-side error, failure, or shutdown
    COMMIT_FAILED               = 7;    
    
    // The txn has been committed and has been confirmed as stored (but could still potentially be reverted)
    COMMITTED                   = 8;

    // The txn was confirmed COMMITTED earlier in time, but has since been revoked (and is in an equivalent state to AWAITING_COMMIT)
    REVOKED                     = 9;

    // The txn has been committed, confirmed as stored, and faces no possibility of being reverted/revoked.
    FINALIZED                   = 16;

}







/**********************************************************************************************************************
A channel's access control channel effectively specifies an privilege access level for all member IDs in the community. 

A channel designated as an access control channel can be used for any number of channels, 
effectively allowing channels used to control access more multiple channels.  This "comes for free" since
access control channels don't contain any references to channels that use them to control access. */

enum ChannelAccess {

    // Not used
    NO_ACCESS                   = 0;

    // Has crypto to decrypt entries from the given channel
    READ_ACCESS                 = 1;

    // Permitted to author: POST_NEW_CONTENT, REMOVE_ENTRIES (for self), SUPERCEDE_ENTRY (for self) 
    READWRITE_ACCESS            = 2;

    // Permitted to author: POST_NEW_CONTENT, REMOVE_ENTRIES (for all), SUPERCEDE_ENTRY (for all), EDIT_CHANNEL_INFO, EDIT_ACCESS_GRANTS
    MODERATOR_ACCESS            = 3;

    // Same as MODERATOR_ACCESS plus can grant others MODERATOR_ACCESS and can issue EDIT_ACCESS_GRANTS
    SUPER_MODERATOR_ACCESS      = 4;

    // Same as SUPER_MODERATOR_ACCESS plus can grant others SUPER_MODERATOR_ACCESS and can author entry type NEW_CHANNEL_EPOCH
    ADMIN_ACCESS                = 5;

}


enum EntryStatus {

    UNSPECIFIED                 = 0;

    // The given entry is considered authentic and a live operating part of the local community repo.
    LIVE                        = 1;

    // The given entry is currently in conflict with another entry having equal authority.
    AMBIGUOUS_CONFLICT          = 2;

    // The given entry is deferred as a result of one of many possibilities encountered during 
    //    Channel Entry Validation (see design-docs/PLAN-Proof-of-correctness.md).
    DEFERRED                    = 3;

    // The given entry is currently in conflict with its channel's parent access control channel.
    DISALLOWED                  = 4;

    // The given entry has been confirmed to be associated with unauthorized activity, a security breach, or inappropriate behavior.
    DISBARRED                   = 5;

    // One or more parts of this entry are not self-consistent or does not self-validate.
    MALFORMED                   = 6;

}


/**********************************************************************************************************************
EntryOp specifies a specific flavor of PDI transaction.  Although the PLAN UI will not allow the user to things 
she doesn't have permission to do, every pnode in the community rigorously verifies that the author of any given 
PDI entry has the permission they imply they do with the given entry they authored.  */

enum EntryOp {

    /*****************************************************
    ** Ops for ANY channel type
    **/

    // Appends this content entry to the specified channel.
    POST_CONTENT                = 0;

    // This entry's body lists one or more channel entries to effectively mark as removed/invisible.
    REMOVE_ENTRIES              = 1;

    // This entry's body should effectively replace a specified previous entry
    SUPERCEDE_ENTRY             = 2;

    /*  - This entry modifies one or more of a given channel's meta fields (e.g. channel description, icon, etc).
        - A ChannelInfo snapshot/composite can be reconstructed by sequentially applying every EDIT_CHANNEL_INFO 
    change to the previous ChannelInfo composite up to the present time.
        - Only channel admins or moderators are permitted to originate this op. */
    EDIT_CHANNEL_INFO           = 3;

    // This entry initiates a new channel epoch, inserting one or more changes to the channel's current ChannelEpoch.
    // This op is mostly issued to access channels since a new epoch is only needed in order to rekey a private access channel.
    // Only channel admins are permitted to originate this op.
    NEW_CHANNEL_EPOCH           = 4;

    /*****************************************************
    ** Ops for access channels ONLY 
    **/

    // Adds or removes access to given member IDs or wildcards.  Notes:
    //   - This entry type is only valid for use channels that are access control channels.
    //   - Members with MODERATOR_ACCESS can only grant/revoke READ_ACCESS and READWRITE_ACCESS.
    //   - Members with ADMIN_ACCESS can grant/revoke up to and including SUPER_MODERATOR_ACCESS.
    //   - ADMIN_ACCESS can ONLY be granted by members with ADMIN_ACCESS in the parent access control channel.
    //   - In some cases, this entry type MAY result a new channel epoch to be initiated (this is because
    //     a private channel must issue and distribute a new channel encryption key in order to effectively 
    //     remove access to members that are longer have channel access).
    EDIT_ACCESS_GRANTS          = 6;

}









message AccessGrant {

    // Specifies an access level granted to the liven list of grantees. If a pnode sees an access grant given by a member who does
    // not have permission to do so, the entry will be rejected. 
                ChannelAccess   access_grant            = 1;


    // This is a list of community member IDs being given the specified access grant. 
    // Note: if grantees[0] == "*" AND access_grant <= MODERATOR_ACCESS, then the grant implicitly applies to ALL community members. 
    repeated    bytes           grantees                = 2;

}



/*
    ChannelEpoch contains critical and security-related properties about a channel and is king while in effect.
    Other than access grants given or taken away, a ChannelEpoch is immutable and only a NEW_CHANNEL_EPOCH op can change things.
*/
message ChannelEpoch {

    // Random "name" for this channel epoch -- must be unique for a channel's epoch history (and not 0). 
                fixed64         epoch_id                    = 1;

    // Unix timestamp when this epoch entered into effect
                int64           time_started                = 2;

    // Names the previous epoch.  0 if there was no previous epoch.
                fixed64         prev_epoch_id               = 3;

    // Number of seconds the previous epoch can alternatively be used in place of this epoch.
                int32           epoch_transition_period     = 4;

    /*  Top-level string describing how entries on this channel are expected to conform.
        This allows a PLAN client to invoke the appropriate UI and data handlers. 
        e.g. 
            /plan/channel-protocol/talk/2
            /plan/channel-protocol/inventory/1   
            /plan/channel-protocol/cryptokitty/browser    */
                string          protocol                    = 5;

    // Specifies the channel that is serving as this channel's access control channel (and has entries that conform to that spec)
                bytes           channel_id                  = 6;

    // Specifies the channel that is serving as this channel's access control channel (and has entries that conform to that spec)
                bytes           access_channel_id           = 7;

    // If set, channel entries are not allowed to be removed/superceded.
                bool            entries_are_locked          = 8;

    // If set, entries_are_locked must/will always be true.
                bool            entries_are_locked_forever  = 9;

    // If set, nodes with web services running will attempt to share this channel to outside the community
                bool            is_externally_shared        = 10;
                        
    /*  If set, this channel can be used to validate EntryOps applied to other channels (including other access channels).
        Entries in an access channel conform to a specific protocol and serve to:
            (a) allow one or more other channels to cite this channel as their access control (access_channel_id)
            (a) transport private channel keys and grants to community members that have been given access to this channel (by encrypting a channel's key using a member's public key)
            (b) publish and transfer write-access and ownership permissions to others (only permitted by owners)  */
                bool            is_access_channel           = 11;

    // If set, entries in this channel are "private", meaning that each entry body is encrypted using the key
    //   identified by this pub key (stored in the keyring with a name formed by the community ID and channel ID).
    // Key distribution occurs when the new channel epoch was posted (and when new members are given private channel access).
                bytes           body_pub_key                = 12;

    // Contains all the access grants published via EDIT_ACCESS_GRANTS sent to this channel (during this epoch).
    // If this channel is NOT an access channel (is_access_channel == false), then this field == nil
    repeated    AccessGrant     access_grants               = 13;

    // Future-proofing
                plan.Block      extensions                  = 14;

}



message ChannelInfo {

    // This permanently identifies a channel (immutable)
                bytes           channel_id              = 1;

    // Container for all content-level properties (e.g. channel title, description, etc) 
                uint32          info_rev                = 7;
                plan.Block      info                    = 8;


}






message ChannelList {
    repeated    ChannelInfo     channels                = 1;
}


enum EntryVersion {
    V0                          = 0;
}


/*
    EntryCrypt is the "wire" format for PLAN's Persistent Data Interface (PDI) entries.  It contains no revealing information and
    is what's sent to/from community data store replicators, such as NEM, DFINITY, and Ethereum.
*/
message EntryCrypt {
                bytes           community_pub_key       = 1;        // Needed to access header_crypt
                bytes           packed_entry            = 2;        // Wrapped w/ ski.SigHeader
}


/*
    An encrypted PDI entry has two segments, its header and "body" (content) block.  The header, EntryInfo, is "community-private",
    meaning that it is encrypted using one of the community's shared symmetric keys.  The entry's body is either also community-private
    (encrypted with the same community key as EntryInfo), or it is encrypted using the key referenced by body_key_id.

    When a entry is authored, it is intended to be posted to the channel specified by EntryInfo.channel_id.  The current rev of that
    channel is also listed so that pdi nodes know which channel access rev to use when checking permissions.  
*/
message EntryInfo {
                int64           time_authored           = 1;        // Unix timestamp -- UTC in seconds elapsed since Jan 1, 1970.
                uint32          time_authored_frac      = 2;        // [0,0xFFFF] -- fraction of a second when authored 
                EntryOp         entry_op                = 4;
                bytes           channel_id              = 5;        // Channel that this entry is posted to.
                fixed64         channel_epoch           = 6;        // Epoch of the channel in effect when this entry was sealed
                fixed64         author_member_id        = 7;        // Creator (and signer) of this entry 
                int32           author_member_epoch     = 8;        // Epoch of the author's identity when this entry was sealed
                plan.Encoding   body_encoding           = 9;

                plan.Block      extensions              = 11;       // Available for unrestricted client use.


}








// StorageEpoch contains core params req'd for a community (and StorageProviders for that community) 
message StorageEpoch {

    // OriginKey is a signing key that:
    //    a) models for others how to generate their own signing key for use with this StorageProvider network.
    //    b) uniquely identifies this StorageEpoch (useful as a keyring name specific to this storage epoch).
                ski.KeyInfo     origin_key              = 1;

    // Identifies a txn encoding schema and storage behavior.
    // Multicodec-style construction, e.g. "plan/storage/pdi-eth/1"
                string          storage_protocol        = 2;

    // Which community this storage provider hosts.
                bytes           communityID             = 3;

    // Human-readable name of this storage epoch (not necessarily the community's name)
                string          name                    = 4;

   // Hash kit used to hash PDI txns
                ski.HashKitID   txn_hash_kit            = 6;

    // Max byte size of txns allowed to be posted to StorageProviders with this epoch.
                uint32          txn_max_size            = 7;
}



message CommunityEpoch {

   // Immutable -- the community ID and community keyring name.
                bytes           communityID             = 1;

    // Official community name
                string          community_name          = 2;

    // Unix timestamp -- UTC in seconds elapsed since Jan 1, 1970.
                int64           time_started            = 3;

    // The community key associated with this epoch, identifying this epoch.
    // KeyInfo.KeyType_SymmetricKey
                ski.KeyInfo     key_info                = 4;

    // Identifies which epoch this epoch succeeds
                bytes           epoch_prev              = 5;

    // Hash kit used to hash PDI entries
                ski.HashKitID   entry_hash_kit          = 7;

    // Max delay (in secs) allowed between pdi.EntryInfo.TimeAuthored of an incoming entry
    //    and the TimeAuthored value of the most recently witnessed entry.  The idea is, how
    //    can entries arrive days or weeks and then a back-dated entry arrives (preventing 
    //    "submarine" attacks). 
    // Note: this only applies to non-private ACCs.
                int64           max_member_latency      = 8;

    // Max number of seconds delay between pdi.EntryInfo.TimeAuthored and its corresponding TxnInfo.TimeSealed.
    // Otherwise, entries that are sealed too late are auto-rejected during entry processing.
    // The downside of larger number is that it limits how long members can be offline until
    //     newly authored entries will be auto-rejected due to this security constraint.
    // Tier 0: posts to reserved community channels
    // Tier 1: posts to public ACCs 
    repeated    int64           max_entry_latency       = 9;

}




message MemberEpoch {

    // Immutable -- generated during member genesis
                fixed64         memberID                = 2;    

    // Increments for each member epoch (0 meaning the creation, 1, 2, ...)
                int32           epoch_num               = 3;

    // Unix timestamp when this epoch entered into effect
                int64           time_started            = 5;

    // Specifies a UTF8 textual label that this member chooses to appear as in the community.
                string          alias                   = 6;

    // Public keys associated with this member epoch
                bytes           pub_signing_key         = 7;
                bytes           pub_encrypt_key         = 8;

    // The ChannelID of this member's "about" channel
                bytes           about_channel_id        = 9;

    // The ChannelID of this member's home channel -- where visitors should first go
                bytes           home_channel_id         = 10;

    // Future-proofing
                plan.Block      extensions              = 11;

}





// ServiceInfo contains descriptions, network addresses, ports, and connection info for remote services.
message ServiceInfo {
                string          addr                    = 1;
                string          network                 = 2;
}



message RepoSeed {
                StorageEpoch    storage_epoch           = 1;
                CommunityEpoch  community_epoch         = 2;
    repeated    ServiceInfo     services                = 5;
}


// GuestInvite -- STEP 1
// A community issues this to a person they want to invite into their community.  A copy of this record is written to member registry channel.
// This is passed in the clear and is used by a prospective member or guest's client to connect to a community.
message MemberSeed {
                RepoSeed        repo_seed               = 1;

                ski.KeyTome     key_tome                = 3;    // Contains community keyring and first-issue sending, signing, and txn signing keys.

                MemberEpoch     member_epoch            = 6;

    // WHO sent this invitation (note: the member's signing key is used to create this invite)
                fixed64         origin_member_id        = 7;
                ski.KeyInfo     origin_signing_key      = 8;

    // A asym key used to encrypt an InvitationResponse
                ski.KeyInfo     reply_to                = 9;

}


/*
New member steps:
1) Alice is community member of C and has member invite privs
2) Alice generates a new MemberSeed ("MS") and writes it to the member registry channel (Alice locks the MS with a password)
3) Alice gives Bob the MS (and the password)
4) Bob installs PLAN
5) Bob is prompted for a seed file and he selects it (and enters the decrypt password)
6) Bob's client can now seed a new repo R, rebuilding from scratch
7) When complete (when R sees the MemberEpoch record entry show up)
8) Bob's client prompts him to enter his alias, member info, etc -- and generates and inserts a new MemberEpoch into the Community member epoch channel
9) Bob picks up his lambo.

*/