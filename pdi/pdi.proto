// See http://github.com/plan-systems/plan-protobufs/

syntax = "proto3";

package pdi;

import "github.com/plan-systems/go-plan/plan/plan.proto";
import "github.com/plan-systems/go-plan/ski/ski.proto";
import "github.com/plan-systems/go-plan/pservice/pservice.proto";




enum PayloadCodec {

    Unspecified             = 0;

    // A protobufs-encoded plan.Block
    Pb_Block                = 1;

    // A protobufs-encoded pdi.EntryCrypt
    Pb_EntryCrypt           = 2;

}


/**********************************************************************************************************************
A StorageProvider is an access point to a community's shared data store, and a community's member nodes access
one in order to:
    - Submit newly authored (and "sealed") txns to the community's shared data store.
    - Query and receive txns
    
Although the StorageProvider abstraction is *modeled* after a blockchain (an append-only ledger),
its implementation can either be centralized *or* decentralized.  This allows a StorageProvider
implementation to actually be a blockchain in addition to a conventional centralized server or cluster.

So in the StorageProvider model, as with a conventional blockchain model, trust is externalized
to outside the system by use of a unit of account called "fuel".  This is comparable to Ethereum's gas, 
however unlike gas, fuel is not related or connected to a currency in any other way.  It is solely mechanism
for controlling who has append access to the community's shared data store.

See go-plan/pdi/StorageProvider.go. */
service StorageProvider {

    // Starts a new client session.
    rpc         StartSession(pservice.SessionRequest)           returns (StorageInfo);

    // Requests a sequence of txns within a specified time window and other query criteria.
    rpc         Query(TxnQuery)                                 returns (stream TxnBatch);

    // Requests a given set of txns to be sent back to the client
    rpc         SendTxns(TxnBatch)                              returns (stream Txn);

    // Submits a txn ready to be written to the StorageProvider's permanent txn store.
    // RawTxn is generated by this StorageProvider's corresponding TxnEncoder.
    // For each StorageProvider implementation, one uses the accompanying txn marshalling encoder
    //    and decoder (TxnEncoder and TxnDecoder).
    rpc         CommitTxn(RawTxn)                               returns (stream TxnMetaInfo);


}

message StorageInfo {

    // Specifies which TxnEncoder and TxnDecoder should be used with this StorageProvider
                string          encoding_desc           = 1;
}



// TxnInfo contains information derivable from EACH native/raw txn.
// It's typically used during txn processing or _about_ a Txn being processed.
// Although a TxnEncoder internally encodes a TxnSegment into a Txn to be signed, 
//     that can only happen after the agent has segmented the payload 
//     buffer into sizes appropriate for storage medium. 
// For example, the Ethereum agent must break the payload into 31k pieces so that the byte size of 
//     Txn.TxnData is strictly less than 32k (Ethereum's txn size limit).
message TxnInfo {

    /*****************************************************
    ** StorageProvider Use
    **/

    // Address/pubkey that is posting the to-be txn.  
                bytes           from                    = 1;

    // Transfer(s) (optional)
    repeated    Transfer        transfers               = 2;

    /*****************************************************
    ** Contents Info
    **/

    // Describes how to to decode the payload data (this value is identical for each segment that comprises a reassembled payload)
    // This should be identical for each segment
                PayloadCodec    payload_codec           = 5;

    // Segment byte size
                int32           seg_sz                  = 8;

    // When a client payload is large, it must be split into multiple native txns.
    // This info specifies which segment this is and how many total segments there are.
    // Note: SegmentIndex uses zero-based indexing 
                uint32          seg_index               = 9;
                uint32          seg_total               = 10;

    // Txn UTID of the segment preceding this one (or nil if this is the first segment)
    // This allows an entire segment chain to be implicitly specified via the UTID of the last segment.
                string          seg_prev                = 11;

    // Unix timestamp of when this txn was encoded and signed for storage.
                int64           time_sealed             = 12;

    // Specifies which hash kit was (or should be) used to generate the hash digest for this txn.
                ski.HashKitID   hash_kit_id             = 13;

    /*****************************************************
    ** Regenerated Info
    **/

    // A hash digest of a packed and readied raw txn.  It is generated by TxnEncoder.EncodeToTxns()
    // This is nil in packaged txns since its hash digest isn't knowable until after the txn is packaged.
                bytes           txn_hashname            = 20;

}


message Transfer {

    // Pubkey/address of the recipient
                bytes           to                      = 1;

    // Fuel is the unit of account for a txn to be committed to a StorageProvider.
    // Txns "cost" fuel proportional to the byte size of the raw txn.
                int64           fuel                    = 2;

    // Mana is an arbitrary unit for the community's coinage.
                int64           mana                    = 3;

}


message RawTxn {

    // Raw native txn data and conforms to all native txn requirements (e.g. native max size).
                bytes           bytes                   = 4;

}



// Txn reflects a txn native to/from a community's StorageProvider network.
message Txn {

    // Always generate locally for security (set to nil for transport)
                string          UTID                    = 2;

    // Info about the status this txn.  
    // Set to nil if n/a or if txn is not yet committed.
                TxnMetaInfo     txn_meta_info           = 3;

    // Raw native txn data and conforms to all native txn requirements (e.g. native max size).
                bytes           raw_txn                 = 4;

}

// TxnMetaInfo is information *about* the status of a transaction 
message TxnMetaInfo {

   // Status information about the associated txn
                TxnStatus       txn_status              = 2;

    // Contains additional alert or status information
                plan.Status     alert                   = 3;

    // Consensus-based unix timestamp for this txn (or 0 if not available).  
    // If txn_status == FINALIZED, then this timestamp:
    //      - won't ever change, 
    //      - is universal across storage peers
    //      - is trustworthy
                int64           consensus_time          = 4;
}





enum TxnOrdering {

    // Txns that appear first are oldest
    OldestFirst             = 0;

    // Txns that appear first are newest
    NewestFirst             = 1;

}


message TxnQuery {

    // Required -- specifies the bracketing timestamp (TxnInfo.TimeSealed) of txns to consider (inclusive).
                int64           timestamp_min           = 1;
                int64           timestamp_max           = 2;

    // If set, query results are returned from newest to oldest.
                TxnOrdering     txn_ordering            = 4;      

    // If set, this query will remain active/open even after there are no more entries to return.
    // Any newly committed txns from other clients will be returned, regardless of timestamp.
                bool            report_new_commits      = 5;    

    // If > 0, this limits the the number of txn UTIDs returned until the request is considered complete.
                int32           max_txns                = 7;

}

message TxnBatch {

    // Batch of txn UTIDs (binary form)
    // Entries that are zero-length should be considered valid "no-ops".
    repeated    bytes           UTIDs                   = 2;
}


message StorageAccount {

    // Net fuel available to be spent
                int64           fuel_balance            = 1;

    // Community mana available to be spent
                int64           mana_balance            = 2;

}




// TxnStatus describes how far along a StorageTxn is on being stored on a PDI StorageProvider.
// Note: odd values reflect an error state
enum TxnStatus {

    // The txn is yet to be committed to storage
    AWAITING_COMMIT             = 0;

    // The txn has been committed and is in the process of being stored
    COMMITTING                  = 2;

    // This txn was lost or is otherwise not available 
    LOST                        = 5;

    // This txn has failed to commit because of an error (or the storage provider rejected it for some reason) 
    FAILED_TO_COMMIT            = 7;

    // The txn has been committed and has been confirmed as stored (but could still potentially be reverted)
    COMMITTED                   = 8;

    // The txn was confirmed COMMITTED earlier in time, but has since been revoked (and is in an equivalent state to AWAITING_COMMIT)
    REVOKED                     = 9;

    // The txn has been committed, confirmed as stored, and faces no possibility of being reverted/revoked.
    FINALIZED                   = 16;

}







/**********************************************************************************************************************
A channel's access control channel effectively specifies an privilege access level for all member IDs in the community. 

A channel designated as an access control channel can be used for any number of channels, 
effectively allowing channels used to control access more multiple channels.  This "comes for free" since
access control channels don't contain any references to channels that use them to control access. */

enum ChannelAccess {

    // Not used
    NO_ACCESS                   = 0;

    // Has crypto to decrypt entries from the given channel
    READ_ACCESS                 = 1;

    // Permitted to author: POST_NEW_CONTENT, REMOVE_ENTRIES (for self), SUPERCEDE_ENTRY (for self) 
    READWRITE_ACCESS            = 2;

    // Permitted to author: POST_NEW_CONTENT, REMOVE_ENTRIES (for all), SUPERCEDE_ENTRY (for all), EDIT_CHANNEL_INFO, EDIT_ACCESS_GRANTS
    MODERATOR_ACCESS            = 3;

    // Same as MODERATOR_ACCESS plus can grant others MODERATOR_ACCESS and can issue EDIT_ACCESS_GRANTS
    SUPER_MODERATOR_ACCESS      = 4;

    // Same as SUPER_MODERATOR_ACCESS plus can grant others SUPER_MODERATOR_ACCESS and can author entry type NEW_CHANNEL_EPOCH
    ADMIN_ACCESS                = 5;

}


enum EntryStatus {

    UNSPECIFIED                 = 0;

    // The given entry is considered authentic and a live operating part of the local community repo.
    LIVE                        = 1;

    // The given entry is currently in conflict with another entry having equal authority.
    AMBIGUOUS_CONFLICT          = 2;

    // The given entry is deferred as a result of one of many possibilities encountered during 
    //    Channel Entry Validation (see design-docs/PLAN-Proof-of-correctness.md).
    DEFERRED                    = 3;

    // The given entry is currently in conflict with its channel's parent access control channel.
    DISALLOWED                  = 4;

    // The given entry has been confirmed to be associated with unauthorized activity, a security breach, or inappropriate behavior.
    DISBARRED                   = 5;

    // One or more parts of this entry are not self-consistent or does not self-validate.
    MALFORMED                   = 6;

}


/**********************************************************************************************************************
EntryOp specifies a specific flavor of PDI transaction.  Although the PLAN UI will not allow the user to things 
she doesn't have permission to do, every pnode in the community rigorously verifies that the author of any given 
PDI entry has the permission they imply they do with the given entry they authored.  */

enum EntryOp {

    /*****************************************************
    ** Ops for ANY channel type
    **/

    // Appends this content entry to the specified channel.
    POST_CONTENT                = 0;

    // This entry's body lists one or more channel entries to effectively mark as removed/invisible.
    REMOVE_ENTRIES              = 1;

    // This entry's body should effectively replace a specified previous entry
    SUPERCEDE_ENTRY             = 2;

    /*  - This entry modifies one or more of a given channel's meta fields (e.g. channel description, icon, etc).
        - A ChannelInfo snapshot/composite can be reconstructed by sequentially applying every EDIT_CHANNEL_INFO 
    change to the previous ChannelInfo composite up to the present time.
        - Only channel admins or moderators are permitted to originate this op. */
    EDIT_CHANNEL_INFO           = 3;

    // This entry initiates a new channel epoch, inserting one or more changes to the channel's current ChannelEpoch.
    // This op is mostly issued to access channels since a new epoch is only needed in order to rekey a private access channel.
    // Only channel admins are permitted to originate this op.
    NEW_CHANNEL_EPOCH           = 4;

    /*****************************************************
    ** Ops for access channels ONLY 
    **/

    // Adds or removes access to given member IDs or wildcards.  Notes:
    //   - This entry type is only valid for use channels that are access control channels.
    //   - Members with MODERATOR_ACCESS can only grant/revoke READ_ACCESS and READWRITE_ACCESS.
    //   - Members with ADMIN_ACCESS can grant/revoke up to and including SUPER_MODERATOR_ACCESS.
    //   - ADMIN_ACCESS can ONLY be granted by members with ADMIN_ACCESS in the parent access control channel.
    //   - In some cases, this entry type MAY result a new channel epoch to be initiated (this is because
    //     a private channel must issue and distribute a new channel encryption key in order to effectively 
    //     remove access to members that are longer have channel access).
    EDIT_ACCESS_GRANTS          = 6;

}





// /plan/community/member/epoch
message MemberEpoch {

    // Random "name" for this member epoch -- must be unique for a member's epoch history (and not 0).  
                fixed64         epoch_id                = 1;

    // Names the previous epoch.  Set to 0 if there was no previous epoch.
                fixed64         prev_epoch_id           = 2;

    // Unix timestamp when this epoch entered into effect
                int64           time_started            = 3;

    // Specifies a UTF8 textual label that this member chooses to appear as in the community.
                string          alias                   = 4;

    // Public keys associated with the given revision
                bytes           pub_signing_key         = 5;
                bytes           pub_crypto_key          = 6;

    // The ChannelID of this member's "about" channel
                bytes           about_channel_id        = 7;

    // The ChannelID of this member's home channel -- where visitors should first go
                bytes           home_channel_id         = 8;

    // Future-proofing
                plan.Block      extensions              = 9;

}





message AccessGrant {

    // Specifies an access level granted to the liven list of grantees. If a pnode sees an access grant given by a member who does
    // not have permission to do so, the entry will be rejected. 
                ChannelAccess   access_grant            = 1;


    // This is a list of community member IDs being given the specified access grant. 
    // Note: if grantees[0] == "*" AND access_grant <= MODERATOR_ACCESS, then the grant implicitly applies to ALL community members. 
    repeated    bytes           grantees                = 2;

}



/*
    ChannelEpoch contains critical and security-related properties about a channel and is king while in effect.
    Other than access grants given or taken away, a ChannelEpoch is immutable and only a NEW_CHANNEL_EPOCH op can change things.
*/
message ChannelEpoch {

    // Random "name" for this channel epoch -- must be unique for a channel's epoch history (and not 0). 
                fixed64         epoch_id                    = 1;

    // Unix timestamp when this epoch entered into effect
                int64           time_started                = 2;

    // Names the previous epoch.  0 if there was no previous epoch.
                fixed64         prev_epoch_id               = 3;

    // Number of seconds the previous epoch can alternatively be used in place of this epoch.
                int32           epoch_transition_period     = 4;

    /*  Top-level string describing how entries on this channel are expected to conform.
        This allows a PLAN client to invoke the appropriate UI and data handlers. 
        e.g. 
            /plan/channel-protocol/talk/2
            /plan/channel-protocol/inventory/1   
            /plan/channel-protocol/cryptokitty/browser    */
                string          protocol                    = 5;

    // Specifies the channel that is serving as this channel's access control channel (and has entries that conform to that spec)
                bytes           access_channel_id           = 6;

    // If set, channel entries are not allowed to be removed/superceded.
                bool            entries_are_locked          = 7;

    // If set, entries_are_locked must/will always be true.
                bool            entries_are_locked_forever  = 8;

    // If set, nodes with web services running will attempt to share this channel to outside the community
                bool            is_externally_shared        = 9;
                        
    /*  If set, this channel can be used to validate EntryOps applied to other channels (including other access channels).
        Entries in an access channel conform to a specific protocol and serve to:
            (a) allow one or more other channels to cite this channel as their access control (access_channel_id)
            (a) transport private channel keys and grants to community members that have been given access to this channel (by encrypting a channel's key using a member's public key)
            (b) publish and transfer write-access and ownership permissions to others (only permitted by owners)  */
                bool            is_access_channel           = 10;

    // Contains all the access grants published via EDIT_ACCESS_GRANTS sent to this channel (during this epoch).
    // If this channel is NOT an access channel (is_access_channel == false), then this field == nil
    repeated    AccessGrant     access_grants               = 11;

    // Future-proofing
                plan.Block      extensions                  = 12;

}



message ChannelInfo {

    // This permanently identifies a channel (immutable)
                bytes           channel_id              = 1;

    // Container for all content-level properties (e.g. channel title, description, etc) 
                uint32          info_rev                = 7;
                plan.Block      info                    = 8;


}






message ChannelList {
    repeated    ChannelInfo     channels                = 1;
}


enum EntryVersion {
    V0                          = 0;
}


/*
    EntryCrypt is the "wire" format for PLAN's Persistent Data Interface (PDI) entries.  It contains no revealing information and
    is what's sent to/from community data store replicators, such as NEM, DFINITY, and Ethereum.
*/
message EntryCrypt {
                uint64          crypt_info              = 1;        // Allows accessors to apply correct hash and crypto functions to this EntryCrypt 
                bytes           community_key_id        = 3;        // Needed to access header_crypt
                bytes           header_crypt            = 5;        // := Encrypt(<EntryHeader>.Marshal(), <EntryCrypt>.community_key_id)
                bytes           body_crypt              = 6;        // := Encrypt(<Body>.Marshal(), <EntryHeader>.body_key_id)
                bytes           sig                     = 7;        // := ComputeSig(<EntryCrypt>, GetKey(author_member_id,author_member_epoch))
}


/*
    An encrypted PDI entry has two segments, its header and "body" (content) block.  The header, EntryHeader, is "community-private",
    meaning that it is encrypted using one of the community's shared symmetric keys.  The entry's body is either also community-private
    (encrypted with the same community key as EntryHeader), or it is encrypted using the key referenced by body_key_id.

    When a entry is authored, it is intended to be posted to the channel specified by EntryHeader.channel_id.  The current rev of that
    channel is also listed so that pdi nodes know which channel access rev to use when checking permissions.  
*/
message EntryHeader {
                int64           time_authored           = 1;        // Unix timestamp -- UTC in seconds elapsed since Jan 1, 1970.
                fixed32         time_authored_ns        = 2;        // [0,999999999] -- serves 
                int64           time_sealed             = 3;        // Unix timestamp
                EntryOp         entry_op                = 4;
                bytes           channel_id              = 5;        // Channel that this entry is posted to.
                fixed64         channel_epoch_id        = 6;        // Epoch of the channel in effect when this entry was sealed
                bytes           author_member_id        = 7;        // Creator of this entry (and signer of .Sig)
                fixed64         author_member_epoch     = 8;        // Epoch of the author's identity when this entry was sealed
                bytes           body_key_id             = 10;       // Specifies which key was used to encrypt EntryCrypt.body_crypt
                plan.Block      extensions              = 11;       // Available for unrestricted client use.
}



