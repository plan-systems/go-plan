// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pdi.proto

/*
	Package pdi is a generated protocol buffer package.

	It is generated from these files:
		pdi.proto

	It has these top-level messages:
		SessionReq
		StorageInfo
		TxnInfo
		Transfer
		RawTxn
		TxnMetaInfo
		TxnScan
		TxnList
		StorageAccount
		AccessControls
		AccessGrant
		ChannelEpoch
		ChannelInfo
		EntryCrypt
		EntryInfo
		StorageEpoch
		CommunityEpoch
		MemberEpoch
*/
package pdi

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import plan "github.com/plan-systems/go-plan/plan"
import ski "github.com/plan-systems/go-plan/ski"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// TxnStatus describes the status of a txn on a StorageProvider.
// Note: odd values reflect an error state
type TxnStatus int32

const (
	// The txn is yet to be committed to storage
	TxnStatus_AWAITING_COMMIT TxnStatus = 0
	// The txn is in the process of being committed
	TxnStatus_COMMITTING TxnStatus = 2
	// This txn was lost or is otherwise not available
	TxnStatus_LOST TxnStatus = 5
	// This txn has failed to commit because of a server-side error, failure, or shutdown
	TxnStatus_COMMIT_FAILED TxnStatus = 7
	// The txn has been committed and has been confirmed as stored (but could still potentially be reverted)
	TxnStatus_COMMITTED TxnStatus = 8
	// The txn was confirmed COMMITTED earlier in time, but has since been revoked (and is in an equivalent state to AWAITING_COMMIT)
	TxnStatus_REVOKED TxnStatus = 9
	// The txn has been committed, confirmed as stored, and faces no possibility of being reverted/revoked.
	TxnStatus_FINALIZED TxnStatus = 16
)

var TxnStatus_name = map[int32]string{
	0:  "AWAITING_COMMIT",
	2:  "COMMITTING",
	5:  "LOST",
	7:  "COMMIT_FAILED",
	8:  "COMMITTED",
	9:  "REVOKED",
	16: "FINALIZED",
}
var TxnStatus_value = map[string]int32{
	"AWAITING_COMMIT": 0,
	"COMMITTING":      2,
	"LOST":            5,
	"COMMIT_FAILED":   7,
	"COMMITTED":       8,
	"REVOKED":         9,
	"FINALIZED":       16,
}

func (x TxnStatus) String() string {
	return proto.EnumName(TxnStatus_name, int32(x))
}
func (TxnStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorPdi, []int{0} }

type AccessLevel int32

const (
	// Not used
	AccessLevel_NO_ACCESS AccessLevel = 0
	// Has crypto to decrypt entries from the given channel
	AccessLevel_READ_ACCESS AccessLevel = 1
	// Permitted to author: POST_NEW_CONTENT, REMOVE_ENTRIES (for self), SUPERSEDE_ENTRY (for self)
	AccessLevel_READWRITE_ACCESS AccessLevel = 2
	// Permitted to author: POST_NEW_CONTENT, REMOVE_ENTRIES (for all), SUPERSEDE_ENTRY (for self), EDIT_CHANNEL_INFO, EDIT_ACCESS_GRANTS
	AccessLevel_MODERATOR_ACCESS AccessLevel = 3
	// Same as MODERATOR_ACCESS plus can grant others MODERATOR_ACCESS and can issue EDIT_ACCESS_GRANTS
	AccessLevel_SUPER_MODERATOR_ACCESS AccessLevel = 4
	// Same as SUPER_MODERATOR_ACCESS plus can grant others SUPER_MODERATOR_ACCESS and can author entry type NEW_CHANNEL_EPOCH
	AccessLevel_ADMIN_ACCESS AccessLevel = 5
)

var AccessLevel_name = map[int32]string{
	0: "NO_ACCESS",
	1: "READ_ACCESS",
	2: "READWRITE_ACCESS",
	3: "MODERATOR_ACCESS",
	4: "SUPER_MODERATOR_ACCESS",
	5: "ADMIN_ACCESS",
}
var AccessLevel_value = map[string]int32{
	"NO_ACCESS":              0,
	"READ_ACCESS":            1,
	"READWRITE_ACCESS":       2,
	"MODERATOR_ACCESS":       3,
	"SUPER_MODERATOR_ACCESS": 4,
	"ADMIN_ACCESS":           5,
}

func (x AccessLevel) String() string {
	return proto.EnumName(AccessLevel_name, int32(x))
}
func (AccessLevel) EnumDescriptor() ([]byte, []int) { return fileDescriptorPdi, []int{1} }

// *********************************************************************************************************************
// EntryOp specifies a specific flavor of PDI transaction.  Although the PLAN UI will not allow the user to things
// she doesn't have permission to do, every pnode in the community rigorously verifies that the author of any given
// PDI entry has the permission they imply they do with the given entry they authored.
type EntryOp int32

const (
	// Appends this content entry to the specified channel.
	EntryOp_POST_CONTENT EntryOp = 0
	// This entry's body lists one or more channel entry IDs to mark as removed/invisible.
	EntryOp_REMOVE_ENTRIES EntryOp = 1
	// This entry's body replaces the specified previous entry.
	EntryOp_SUPERSEDE_ENTRY EntryOp = 2
	//  - This entry modifies one or more of a given channel's meta fields (e.g. channel description, icon, etc).
	// - A ChannelInfo snapshot/composite can be reconstructed by sequentially applying every EDIT_CHANNEL_INFO
	// change to the previous ChannelInfo composite up to the present time.
	// - Only channel admins or moderators are permitted to originate this op.
	EntryOp_EDIT_CHANNEL_INFO EntryOp = 3
	// This entry initiates a new channel epoch, inserting one or more changes to the channel's current ChannelEpoch.
	// This op is mostly issued to access channels since a new epoch is only needed in order to rekey a private access channel.
	// Only channel admins are permitted to originate this op.
	EntryOp_NEW_CHANNEL_EPOCH EntryOp = 4
	// Adds or removes access to given member IDs or wildcards.  Notes:
	//   - This entry type is only valid for use channels that are access control channels.
	//   - Members with MODERATOR_ACCESS can only grant/revoke READ_ACCESS and READWRITE_ACCESS.
	//   - Members with ADMIN_ACCESS can grant/revoke up to and including SUPER_MODERATOR_ACCESS.
	//   - ADMIN_ACCESS can ONLY be granted by members with ADMIN_ACCESS in the parent access control channel.
	//   - In some cases, this entry type MAY result a new channel epoch to be initiated (this is because
	//     a private channel must issue and distribute a new channel encryption key in order to effectively
	//     remove access to members that are longer have channel access).
	EntryOp_EDIT_ACCESS_GRANTS EntryOp = 6
)

var EntryOp_name = map[int32]string{
	0: "POST_CONTENT",
	1: "REMOVE_ENTRIES",
	2: "SUPERSEDE_ENTRY",
	3: "EDIT_CHANNEL_INFO",
	4: "NEW_CHANNEL_EPOCH",
	6: "EDIT_ACCESS_GRANTS",
}
var EntryOp_value = map[string]int32{
	"POST_CONTENT":       0,
	"REMOVE_ENTRIES":     1,
	"SUPERSEDE_ENTRY":    2,
	"EDIT_CHANNEL_INFO":  3,
	"NEW_CHANNEL_EPOCH":  4,
	"EDIT_ACCESS_GRANTS": 6,
}

func (x EntryOp) String() string {
	return proto.EnumName(EntryOp_name, int32(x))
}
func (EntryOp) EnumDescriptor() ([]byte, []int) { return fileDescriptorPdi, []int{2} }

type EntryVersion int32

const (
	EntryVersion_V0 EntryVersion = 0
)

var EntryVersion_name = map[int32]string{
	0: "V0",
}
var EntryVersion_value = map[string]int32{
	"V0": 0,
}

func (x EntryVersion) String() string {
	return proto.EnumName(EntryVersion_name, int32(x))
}
func (EntryVersion) EnumDescriptor() ([]byte, []int) { return fileDescriptorPdi, []int{3} }

// EntryTID identifies the contained IDs in EntryInfo.TIDs.
type EntryTID int32

const (
	// The ID of this entry.  It can only be formed AFTER an entry is sealed since the "sig" portion is derived from the entry's hash..
	EntryTID_EntryID EntryTID = 0
	// Entry reference to the member record used to sign and authorize this entry.
	EntryTID_AuthorEntryID EntryTID = 1
	// A reference to to the ChannelEpoch that was in effect when this entry was authored.
	EntryTID_ChannelEpochEntryID EntryTID = 2
	// Entry ID of the receiving chanel's ACC that authorizes this entry
	EntryTID_ACCEntryID EntryTID = 3
	// The number of TIDs in a normal entry
	EntryTID_NormalNumTIDs EntryTID = 4
)

var EntryTID_name = map[int32]string{
	0: "EntryID",
	1: "AuthorEntryID",
	2: "ChannelEpochEntryID",
	3: "ACCEntryID",
	4: "NormalNumTIDs",
}
var EntryTID_value = map[string]int32{
	"EntryID":             0,
	"AuthorEntryID":       1,
	"ChannelEpochEntryID": 2,
	"ACCEntryID":          3,
	"NormalNumTIDs":       4,
}

func (x EntryTID) String() string {
	return proto.EnumName(EntryTID_name, int32(x))
}
func (EntryTID) EnumDescriptor() ([]byte, []int) { return fileDescriptorPdi, []int{4} }

type CommunityChID int32

const (
	// RootACC is the community's root access-level channel, meaning this channel effectively
	// specifies which community members are "community admins".  All other channels and access channels
	// are ultimately controlled by the community members listed in this root channel.  This means
	// the hierarchy of access channels is rooted in this channel.
	//
	// Unlike every other ACC in a given community, the root ACC has no parent governing ACC
	CommunityChID_RootACC CommunityChID = 0
	// MemberRegistry is the community's master (community-public) member registry.  Each entry specifies a
	// each community member's member ID, latest public keys, and member info (e.g. home ChannelID).  This allows each of the
	// community's pnodes to verify member signatures and enable the passing of secrets to other members or groups
	// via asymmetric encryption. Naturally, this channel is controlled by an access channel that is controlled only
	// by community admins and is set to RootAccessChannel by default.  Since each entry in this channel represents
	// an official community record (that only a community admin can edit), entries can also contain additional
	// information desired that community admins wish (or require) to be publicly available (and unforgeable).
	CommunityChID_MemberRegistry CommunityChID = 1
	// EpochHistory identifies the channel where successive CommunityEpoch entries are posted
	CommunityChID_EpochHistory CommunityChID = 2
	// The total number of community-global channels needed in order to administer a PLAN community.
	CommunityChID_NumChannels CommunityChID = 3
)

var CommunityChID_name = map[int32]string{
	0: "RootACC",
	1: "MemberRegistry",
	2: "EpochHistory",
	3: "NumChannels",
}
var CommunityChID_value = map[string]int32{
	"RootACC":        0,
	"MemberRegistry": 1,
	"EpochHistory":   2,
	"NumChannels":    3,
}

func (x CommunityChID) String() string {
	return proto.EnumName(CommunityChID_name, int32(x))
}
func (CommunityChID) EnumDescriptor() ([]byte, []int) { return fileDescriptorPdi, []int{5} }

type SessionReq struct {
	// The requested storage epoch to be accessed.
	StorageEpoch *StorageEpoch `protobuf:"bytes,1,opt,name=storage_epoch,json=storageEpoch" json:"storage_epoch,omitempty"`
	// An empty but signed txn that demonstrates to the host StorageProvider that the client
	//    has an active account with this storage provider.
	ProofOfAccess *RawTxn `protobuf:"bytes,2,opt,name=proof_of_access,json=proofOfAccess" json:"proof_of_access,omitempty"`
}

func (m *SessionReq) Reset()                    { *m = SessionReq{} }
func (m *SessionReq) String() string            { return proto.CompactTextString(m) }
func (*SessionReq) ProtoMessage()               {}
func (*SessionReq) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{0} }

func (m *SessionReq) GetStorageEpoch() *StorageEpoch {
	if m != nil {
		return m.StorageEpoch
	}
	return nil
}

func (m *SessionReq) GetProofOfAccess() *RawTxn {
	if m != nil {
		return m.ProofOfAccess
	}
	return nil
}

type StorageInfo struct {
	// This is a sig of SessionReq.ProofOfAccess, signed with the latest StorageProvider key.
	// This authenticates this StorageProvider (since a 3rd party attempting to impersonate a StorageProvider
	//    node would be unable to produce this signature).
	SigResponse []byte `protobuf:"bytes,1,opt,name=sig_response,json=sigResponse,proto3" json:"sig_response,omitempty"`
}

func (m *StorageInfo) Reset()                    { *m = StorageInfo{} }
func (m *StorageInfo) String() string            { return proto.CompactTextString(m) }
func (*StorageInfo) ProtoMessage()               {}
func (*StorageInfo) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{1} }

func (m *StorageInfo) GetSigResponse() []byte {
	if m != nil {
		return m.SigResponse
	}
	return nil
}

// TxnInfo contains information derivable from EACH native/raw txn.
// It's used during txn processing or _about_ a Txn being processed.
// Although a TxnEncoder internally encodes a payload segment into a Txn to be signed,
//     that can only happen after the agent has segmented the payload
//     buffer into sizes appropriate for storage medium.
// For example, the Ethereum agent must break the payload into 31k pieces so that the byte size of
//     Txn.TxnData is strictly less than 32k (Ethereum's txn size limit).
type TxnInfo struct {
	// Transfer(s) (optional)
	Transfers []*Transfer `protobuf:"bytes,2,rep,name=transfers" json:"transfers,omitempty"`
	// Describes how to to decode the payload data (this value is identical for each segment that comprises a reassembled payload)
	// This should be identical for each segment
	PayloadEncoding plan.Encoding `protobuf:"varint,5,opt,name=payload_encoding,json=payloadEncoding,proto3,enum=plan.Encoding" json:"payload_encoding,omitempty"`
	// Segment byte size
	SegSz uint32 `protobuf:"varint,8,opt,name=seg_sz,json=segSz,proto3" json:"seg_sz,omitempty"`
	// When a client payload is large, it must be split into multiple native txns.
	// This info specifies which segment this is and how many total segments there are.
	// Note: SegmentIndex uses zero-based indexing
	SegIndex uint32 `protobuf:"varint,9,opt,name=seg_index,json=segIndex,proto3" json:"seg_index,omitempty"`
	SegTotal uint32 `protobuf:"varint,10,opt,name=seg_total,json=segTotal,proto3" json:"seg_total,omitempty"`
	// Txn URID of the segment preceding this one (or nil if this is the first segment)
	// This allows an entire segment chain to be implicitly specified via the URID of the last segment.
	PrevURID []byte `protobuf:"bytes,11,opt,name=prevURID,proto3" json:"prevURID,omitempty"`
	// Unix timestamp of when this txn was encoded and signed for storage.
	TimeSealed int64 `protobuf:"varint,12,opt,name=time_sealed,json=timeSealed,proto3" json:"time_sealed,omitempty"`
	// Address/pubkey that signed this txn
	From []byte `protobuf:"bytes,20,opt,name=from,proto3" json:"from,omitempty"`
	// Binary URID of this txn, derived from time_sealed and txn_hashname.
	URID []byte `protobuf:"bytes,21,opt,name=URID,proto3" json:"URID,omitempty"`
}

func (m *TxnInfo) Reset()                    { *m = TxnInfo{} }
func (m *TxnInfo) String() string            { return proto.CompactTextString(m) }
func (*TxnInfo) ProtoMessage()               {}
func (*TxnInfo) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{2} }

func (m *TxnInfo) GetTransfers() []*Transfer {
	if m != nil {
		return m.Transfers
	}
	return nil
}

func (m *TxnInfo) GetPayloadEncoding() plan.Encoding {
	if m != nil {
		return m.PayloadEncoding
	}
	return plan.Encoding_Unspecified
}

func (m *TxnInfo) GetSegSz() uint32 {
	if m != nil {
		return m.SegSz
	}
	return 0
}

func (m *TxnInfo) GetSegIndex() uint32 {
	if m != nil {
		return m.SegIndex
	}
	return 0
}

func (m *TxnInfo) GetSegTotal() uint32 {
	if m != nil {
		return m.SegTotal
	}
	return 0
}

func (m *TxnInfo) GetPrevURID() []byte {
	if m != nil {
		return m.PrevURID
	}
	return nil
}

func (m *TxnInfo) GetTimeSealed() int64 {
	if m != nil {
		return m.TimeSealed
	}
	return 0
}

func (m *TxnInfo) GetFrom() []byte {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *TxnInfo) GetURID() []byte {
	if m != nil {
		return m.URID
	}
	return nil
}

type Transfer struct {
	// Pubkey/address of the recipient
	To []byte `protobuf:"bytes,1,opt,name=to,proto3" json:"to,omitempty"`
	// Kb is the storage unit of account on a StorageProvider.
	// Each txn "costs" Kb for each kb size of the txn.
	Kb int64 `protobuf:"varint,2,opt,name=kb,proto3" json:"kb,omitempty"`
	// Ops refers to the energy and processing cost for operations requested of a StorageProvider (typically a txn commit)
	// Each txn committed "costs" 1 op for example.
	Ops int64 `protobuf:"varint,3,opt,name=ops,proto3" json:"ops,omitempty"`
}

func (m *Transfer) Reset()                    { *m = Transfer{} }
func (m *Transfer) String() string            { return proto.CompactTextString(m) }
func (*Transfer) ProtoMessage()               {}
func (*Transfer) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{3} }

func (m *Transfer) GetTo() []byte {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *Transfer) GetKb() int64 {
	if m != nil {
		return m.Kb
	}
	return 0
}

func (m *Transfer) GetOps() int64 {
	if m != nil {
		return m.Ops
	}
	return 0
}

// RawTxn reflects a txn native to/from a community's StorageProvider network.
type RawTxn struct {
	// Always generate (or confirm) locally for security (set to nil for transport)
	URID []byte `protobuf:"bytes,1,opt,name=URID,proto3" json:"URID,omitempty"`
	// Info about the status this txn.
	// Set to nil if n/a or if txn is not yet committed.
	TxnMetaInfo *TxnMetaInfo `protobuf:"bytes,2,opt,name=txn_meta_info,json=txnMetaInfo" json:"txn_meta_info,omitempty"`
	// Raw native txn data and conforms to all native txn requirements (e.g. native max size).
	Bytes []byte `protobuf:"bytes,3,opt,name=bytes,proto3" json:"bytes,omitempty"`
}

func (m *RawTxn) Reset()                    { *m = RawTxn{} }
func (m *RawTxn) String() string            { return proto.CompactTextString(m) }
func (*RawTxn) ProtoMessage()               {}
func (*RawTxn) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{4} }

func (m *RawTxn) GetURID() []byte {
	if m != nil {
		return m.URID
	}
	return nil
}

func (m *RawTxn) GetTxnMetaInfo() *TxnMetaInfo {
	if m != nil {
		return m.TxnMetaInfo
	}
	return nil
}

func (m *RawTxn) GetBytes() []byte {
	if m != nil {
		return m.Bytes
	}
	return nil
}

// TxnMetaInfo is information *about* the status of a transaction
type TxnMetaInfo struct {
	// Txn ID
	URID []byte `protobuf:"bytes,1,opt,name=URID,proto3" json:"URID,omitempty"`
	// Status information about the associated txn
	TxnStatus TxnStatus `protobuf:"varint,2,opt,name=txn_status,json=txnStatus,proto3,enum=pdi.TxnStatus" json:"txn_status,omitempty"`
	// Contains additional alert or status information
	Alert *plan.Status `protobuf:"bytes,3,opt,name=alert" json:"alert,omitempty"`
	// Consensus-based unix timestamp for this txn (or 0 if not available).
	// If txn_status == FINALIZED, then this timestamp:
	//      - won't ever change,
	//      - is universal across StorageProvider peers
	//      - is as trustworthy as the StorageProvider network.
	ConsensusTime int64 `protobuf:"varint,4,opt,name=consensus_time,json=consensusTime,proto3" json:"consensus_time,omitempty"`
	// Proof that this txn was indeed received and validated by a valid StorageProvider.
	TxnValidation []byte `protobuf:"bytes,5,opt,name=txn_validation,json=txnValidation,proto3" json:"txn_validation,omitempty"`
}

func (m *TxnMetaInfo) Reset()                    { *m = TxnMetaInfo{} }
func (m *TxnMetaInfo) String() string            { return proto.CompactTextString(m) }
func (*TxnMetaInfo) ProtoMessage()               {}
func (*TxnMetaInfo) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{5} }

func (m *TxnMetaInfo) GetURID() []byte {
	if m != nil {
		return m.URID
	}
	return nil
}

func (m *TxnMetaInfo) GetTxnStatus() TxnStatus {
	if m != nil {
		return m.TxnStatus
	}
	return TxnStatus_AWAITING_COMMIT
}

func (m *TxnMetaInfo) GetAlert() *plan.Status {
	if m != nil {
		return m.Alert
	}
	return nil
}

func (m *TxnMetaInfo) GetConsensusTime() int64 {
	if m != nil {
		return m.ConsensusTime
	}
	return 0
}

func (m *TxnMetaInfo) GetTxnValidation() []byte {
	if m != nil {
		return m.TxnValidation
	}
	return nil
}

type TxnScan struct {
	// Specifies the bounding timestamps (TxnInfo.TimeSealed) of txns to consider (inclusive).
	TimestampStart int64 `protobuf:"varint,1,opt,name=timestamp_start,json=timestampStart,proto3" json:"timestamp_start,omitempty"`
	TimestampStop  int64 `protobuf:"varint,2,opt,name=timestamp_stop,json=timestampStop,proto3" json:"timestamp_stop,omitempty"`
	// If set, this query will remain active/open even after there are no more entries to return.
	// All txn status changes or updates will be reported, regardless of timestamp.
	// This is a how client is notified about newly committed txns and status changes in previously committed txns.
	SendTxnUpdates bool `protobuf:"varint,5,opt,name=send_txn_updates,json=sendTxnUpdates,proto3" json:"send_txn_updates,omitempty"`
	// If > 0, this limits the the number of txn URIDs returned until the request is considered complete.
	MaxTxns int32 `protobuf:"varint,7,opt,name=max_txns,json=maxTxns,proto3" json:"max_txns,omitempty"`
}

func (m *TxnScan) Reset()                    { *m = TxnScan{} }
func (m *TxnScan) String() string            { return proto.CompactTextString(m) }
func (*TxnScan) ProtoMessage()               {}
func (*TxnScan) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{6} }

func (m *TxnScan) GetTimestampStart() int64 {
	if m != nil {
		return m.TimestampStart
	}
	return 0
}

func (m *TxnScan) GetTimestampStop() int64 {
	if m != nil {
		return m.TimestampStop
	}
	return 0
}

func (m *TxnScan) GetSendTxnUpdates() bool {
	if m != nil {
		return m.SendTxnUpdates
	}
	return false
}

func (m *TxnScan) GetMaxTxns() int32 {
	if m != nil {
		return m.MaxTxns
	}
	return 0
}

type TxnList struct {
	// Batch of txn URIDs (binary form)
	// Entries that are zero-length should be considered valid "no-ops".
	URIDs [][]byte `protobuf:"bytes,2,rep,name=URIDs" json:"URIDs,omitempty"`
	// len(statuses) == len(URIDs): the ith byte of is the TxnStatus of URIDs[i].
	// Note: this field is ignored for SendTxns()
	Statuses []byte `protobuf:"bytes,3,opt,name=statuses,proto3" json:"statuses,omitempty"`
}

func (m *TxnList) Reset()                    { *m = TxnList{} }
func (m *TxnList) String() string            { return proto.CompactTextString(m) }
func (*TxnList) ProtoMessage()               {}
func (*TxnList) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{7} }

func (m *TxnList) GetURIDs() [][]byte {
	if m != nil {
		return m.URIDs
	}
	return nil
}

func (m *TxnList) GetStatuses() []byte {
	if m != nil {
		return m.Statuses
	}
	return nil
}

type StorageAccount struct {
	// Kilobytes able to be used for txns
	KbBalance int64 `protobuf:"varint,1,opt,name=kb_balance,json=kbBalance,proto3" json:"kb_balance,omitempty"`
	// Number of "operations" able to be posted to a StorageProvider network.
	OpBalance int64 `protobuf:"varint,2,opt,name=op_balance,json=opBalance,proto3" json:"op_balance,omitempty"`
	// Set if this account is permitted to transfer to other accounts.
	CanTransfer bool `protobuf:"varint,3,opt,name=can_transfer,json=canTransfer,proto3" json:"can_transfer,omitempty"`
}

func (m *StorageAccount) Reset()                    { *m = StorageAccount{} }
func (m *StorageAccount) String() string            { return proto.CompactTextString(m) }
func (*StorageAccount) ProtoMessage()               {}
func (*StorageAccount) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{8} }

func (m *StorageAccount) GetKbBalance() int64 {
	if m != nil {
		return m.KbBalance
	}
	return 0
}

func (m *StorageAccount) GetOpBalance() int64 {
	if m != nil {
		return m.OpBalance
	}
	return 0
}

func (m *StorageAccount) GetCanTransfer() bool {
	if m != nil {
		return m.CanTransfer
	}
	return false
}

type AccessControls struct {
}

func (m *AccessControls) Reset()                    { *m = AccessControls{} }
func (m *AccessControls) String() string            { return proto.CompactTextString(m) }
func (*AccessControls) ProtoMessage()               {}
func (*AccessControls) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{9} }

type AccessGrant struct {
	// Specifies an access level granted to the given list of grantees. If a pnode sees an access grant given by a member who does
	// not have permission to do so, the entry will be rejected.
	AccessLevel AccessLevel `protobuf:"varint,1,opt,name=access_level,json=accessLevel,proto3,enum=pdi.AccessLevel" json:"access_level,omitempty"`
	// List of community member IDs being given the specified access grant.
	// Note: if grantees[0] == "*" AND access_grant <= MODERATOR_ACCESS, then the grant implicitly applies to ALL community members.
	Grantees []uint32 `protobuf:"varint,2,rep,packed,name=grantees" json:"grantees,omitempty"`
}

func (m *AccessGrant) Reset()                    { *m = AccessGrant{} }
func (m *AccessGrant) String() string            { return proto.CompactTextString(m) }
func (*AccessGrant) ProtoMessage()               {}
func (*AccessGrant) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{10} }

func (m *AccessGrant) GetAccessLevel() AccessLevel {
	if m != nil {
		return m.AccessLevel
	}
	return AccessLevel_NO_ACCESS
}

func (m *AccessGrant) GetGrantees() []uint32 {
	if m != nil {
		return m.Grantees
	}
	return nil
}

//
// ChannelEpoch contains critical and security-related properties about a channel and is king while in effect.
// Other than access grants given or taken away, a ChannelEpoch is immutable and only a NEW_CHANNEL_EPOCH op can change things.
type ChannelEpoch struct {
	// Identifies this ChannelEpoch and originates from the entryID that published this ChannelEpoch.
	// This is packed as nil and the repo fills this in during processing (since it is only knowable after signing)
	EpochTID []byte `protobuf:"bytes,1,opt,name=epochTID,proto3" json:"epochTID,omitempty"`
	// Names the ChannelEpoch being superseded.
	// Set to nil if there was no previous epoch and this ChannelEpoch reflects channel genesis.
	PrevEpochTID []byte `protobuf:"bytes,2,opt,name=prev_epochTID,json=prevEpochTID,proto3" json:"prev_epochTID,omitempty"`
	// Number of seconds the previous epoch can alternatively be used in place of this epoch.
	EpochTransitionPeriod int64 `protobuf:"varint,3,opt,name=epoch_transition_period,json=epochTransitionPeriod,proto3" json:"epoch_transition_period,omitempty"`
	// Identifies the community epoch that was in effect (fore the author) when this channel epoch was published.
	// If this epoch was generated against the community's genesis epoch, this is set to nil.
	//
	CommunityEpochID []byte `protobuf:"bytes,4,opt,name=community_epochID,json=communityEpochID,proto3" json:"community_epochID,omitempty"`
	//  Top-level string describing how entries on this channel are expected to conform.
	// This allows a PLAN client to invoke the appropriate UI and data handlers.
	// e.g.
	// /plan/channel-protocol/talk/2
	// /plan/channel-protocol/inventory/1
	// /plan/channel-protocol/cryptokitty/browser
	ChProtocol string `protobuf:"bytes,5,opt,name=ch_protocol,json=chProtocol,proto3" json:"ch_protocol,omitempty"`
	// Specifies the Access Control Channel that authorizes entry to be live.
	ACC []byte `protobuf:"bytes,6,opt,name=ACC,proto3" json:"ACC,omitempty"`
	// If set, channel entries can be retroactively marked to be removed/superceded via EntryOp.SUPERSEDE_ENTRY
	EntriesSupersedable bool `protobuf:"varint,8,opt,name=entries_supersedable,json=entriesSupersedable,proto3" json:"entries_supersedable,omitempty"`
	// If set, entries_supersedable (above) can be changed by subsequent channel epochs.
	// IMMUTABLE
	SupersedableIsMutable bool `protobuf:"varint,9,opt,name=supersedable_is_mutable,json=supersedableIsMutable,proto3" json:"supersedable_is_mutable,omitempty"`
	// If set, nodes with web services running are allowed share this channel to outside the community
	IsExternallyShared bool `protobuf:"varint,10,opt,name=is_externally_shared,json=isExternallyShared,proto3" json:"is_externally_shared,omitempty"`
	// If set, entries in this channel are "private", meaning that each entry body is encrypted using the key
	//    identified by this pub key (stored in the keyring with a name formed by the community ID and channel ID).
	// Key distribution occurs when the new channel epoch was posted (and when new members are given private channel access).
	PubKey []byte `protobuf:"bytes,11,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	// For unrestricted channel protocol use
	Extensions *plan.Block `protobuf:"bytes,12,opt,name=extensions" json:"extensions,omitempty"`
	// This is the channel access level for members NOT specified in access_grants.
	DefaultAccessLevel AccessLevel `protobuf:"varint,20,opt,name=default_access_level,json=defaultAccessLevel,proto3,enum=pdi.AccessLevel" json:"default_access_level,omitempty"`
	// Maps a given member ID number to an AccessLevel
	// Contains all the access grants published via EDIT_ACCESS_GRANTS sent to this channel (during this epoch).
	AccessLevels map[uint32]AccessLevel `protobuf:"bytes,21,rep,name=access_levels,json=accessLevels" json:"access_levels,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=pdi.AccessLevel"`
}

func (m *ChannelEpoch) Reset()                    { *m = ChannelEpoch{} }
func (m *ChannelEpoch) String() string            { return proto.CompactTextString(m) }
func (*ChannelEpoch) ProtoMessage()               {}
func (*ChannelEpoch) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{11} }

func (m *ChannelEpoch) GetEpochTID() []byte {
	if m != nil {
		return m.EpochTID
	}
	return nil
}

func (m *ChannelEpoch) GetPrevEpochTID() []byte {
	if m != nil {
		return m.PrevEpochTID
	}
	return nil
}

func (m *ChannelEpoch) GetEpochTransitionPeriod() int64 {
	if m != nil {
		return m.EpochTransitionPeriod
	}
	return 0
}

func (m *ChannelEpoch) GetCommunityEpochID() []byte {
	if m != nil {
		return m.CommunityEpochID
	}
	return nil
}

func (m *ChannelEpoch) GetChProtocol() string {
	if m != nil {
		return m.ChProtocol
	}
	return ""
}

func (m *ChannelEpoch) GetACC() []byte {
	if m != nil {
		return m.ACC
	}
	return nil
}

func (m *ChannelEpoch) GetEntriesSupersedable() bool {
	if m != nil {
		return m.EntriesSupersedable
	}
	return false
}

func (m *ChannelEpoch) GetSupersedableIsMutable() bool {
	if m != nil {
		return m.SupersedableIsMutable
	}
	return false
}

func (m *ChannelEpoch) GetIsExternallyShared() bool {
	if m != nil {
		return m.IsExternallyShared
	}
	return false
}

func (m *ChannelEpoch) GetPubKey() []byte {
	if m != nil {
		return m.PubKey
	}
	return nil
}

func (m *ChannelEpoch) GetExtensions() *plan.Block {
	if m != nil {
		return m.Extensions
	}
	return nil
}

func (m *ChannelEpoch) GetDefaultAccessLevel() AccessLevel {
	if m != nil {
		return m.DefaultAccessLevel
	}
	return AccessLevel_NO_ACCESS
}

func (m *ChannelEpoch) GetAccessLevels() map[uint32]AccessLevel {
	if m != nil {
		return m.AccessLevels
	}
	return nil
}

type ChannelInfo struct {
	// This permanently identifies a channel (immutable)
	ChannelTID []byte `protobuf:"bytes,1,opt,name=channelTID,proto3" json:"channelTID,omitempty"`
	// Container for all content-level properties (e.g. channel title, description, etc)
	InfoRev uint32      `protobuf:"varint,7,opt,name=info_rev,json=infoRev,proto3" json:"info_rev,omitempty"`
	Info    *plan.Block `protobuf:"bytes,8,opt,name=info" json:"info,omitempty"`
}

func (m *ChannelInfo) Reset()                    { *m = ChannelInfo{} }
func (m *ChannelInfo) String() string            { return proto.CompactTextString(m) }
func (*ChannelInfo) ProtoMessage()               {}
func (*ChannelInfo) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{12} }

func (m *ChannelInfo) GetChannelTID() []byte {
	if m != nil {
		return m.ChannelTID
	}
	return nil
}

func (m *ChannelInfo) GetInfoRev() uint32 {
	if m != nil {
		return m.InfoRev
	}
	return 0
}

func (m *ChannelInfo) GetInfo() *plan.Block {
	if m != nil {
		return m.Info
	}
	return nil
}

//
// EntryCrypt is the "wire" format for PLAN's Persistent Data Interface (PDI) entries.  It contains no revealing information and
// is what's sent to/from community data store replicators, such as NEM, DFINITY, and Ethereum.
type EntryCrypt struct {
	CommunityEpochID []byte `protobuf:"bytes,1,opt,name=community_epochID,json=communityEpochID,proto3" json:"community_epochID,omitempty"`
	PackedEntry      []byte `protobuf:"bytes,2,opt,name=packed_entry,json=packedEntry,proto3" json:"packed_entry,omitempty"`
}

func (m *EntryCrypt) Reset()                    { *m = EntryCrypt{} }
func (m *EntryCrypt) String() string            { return proto.CompactTextString(m) }
func (*EntryCrypt) ProtoMessage()               {}
func (*EntryCrypt) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{13} }

func (m *EntryCrypt) GetCommunityEpochID() []byte {
	if m != nil {
		return m.CommunityEpochID
	}
	return nil
}

func (m *EntryCrypt) GetPackedEntry() []byte {
	if m != nil {
		return m.PackedEntry
	}
	return nil
}

//
// An encrypted PDI entry has two segments, its header and "body" (content) block.  The header, EntryInfo, is "community-private",
// meaning that it is encrypted using one of the community's shared symmetric keys.  The entry's body is either also community-private
// (encrypted with the same community key as EntryInfo), or it is encrypted using the key referenced by body_key_id.
type EntryInfo struct {
	EntryOp    EntryOp `protobuf:"varint,1,opt,name=entry_op,json=entryOp,proto3,enum=pdi.EntryOp" json:"entry_op,omitempty"`
	EntrySubOp int32   `protobuf:"zigzag32,2,opt,name=entry_sub_op,json=entrySubOp,proto3" json:"entry_sub_op,omitempty"`
	ChannelID  []byte  `protobuf:"bytes,4,opt,name=channelID,proto3" json:"channelID,omitempty"`
	// TIDs corresponding to TID (above)
	// len(TIDs) == NumEntryTIDs * TIDSz
	TIDs              []byte      `protobuf:"bytes,5,opt,name=TIDs,proto3" json:"TIDs,omitempty"`
	SupersedesEntryID []byte      `protobuf:"bytes,6,opt,name=supersedes_entryID,json=supersedesEntryID,proto3" json:"supersedes_entryID,omitempty"`
	Extensions        *plan.Block `protobuf:"bytes,11,opt,name=extensions" json:"extensions,omitempty"`
	// Repo internal use only; set to nil for all published entries -- see ValidateAuthor()
	AuthorSig []byte `protobuf:"bytes,20,opt,name=author_sig,json=authorSig,proto3" json:"author_sig,omitempty"`
}

func (m *EntryInfo) Reset()                    { *m = EntryInfo{} }
func (m *EntryInfo) String() string            { return proto.CompactTextString(m) }
func (*EntryInfo) ProtoMessage()               {}
func (*EntryInfo) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{14} }

func (m *EntryInfo) GetEntryOp() EntryOp {
	if m != nil {
		return m.EntryOp
	}
	return EntryOp_POST_CONTENT
}

func (m *EntryInfo) GetEntrySubOp() int32 {
	if m != nil {
		return m.EntrySubOp
	}
	return 0
}

func (m *EntryInfo) GetChannelID() []byte {
	if m != nil {
		return m.ChannelID
	}
	return nil
}

func (m *EntryInfo) GetTIDs() []byte {
	if m != nil {
		return m.TIDs
	}
	return nil
}

func (m *EntryInfo) GetSupersedesEntryID() []byte {
	if m != nil {
		return m.SupersedesEntryID
	}
	return nil
}

func (m *EntryInfo) GetExtensions() *plan.Block {
	if m != nil {
		return m.Extensions
	}
	return nil
}

func (m *EntryInfo) GetAuthorSig() []byte {
	if m != nil {
		return m.AuthorSig
	}
	return nil
}

// StorageEpoch contains core params req'd for a community (and StorageProviders for that community)
// During community genesis, the newly created StorageEpoch is marshalled and signed by OriginKey
type StorageEpoch struct {
	// OriginKey is a signing key that:
	//    a) models for others how to generate their own signing key for use with this StorageProvider network.
	//    b) uniquely identifies this StorageEpoch (useful as a keyring name specific to this storage epoch).
	OriginKey *ski.KeyInfo `protobuf:"bytes,1,opt,name=origin_key,json=originKey" json:"origin_key,omitempty"`
	// Identifies a txn encoding schema and storage behavior.
	// Multicodec-style construction, e.g. "plan/storage/pdi-eth/1"
	StorageProtocol string `protobuf:"bytes,2,opt,name=storage_protocol,json=storageProtocol,proto3" json:"storage_protocol,omitempty"`
	// Which community this storage provider hosts.
	CommunityID []byte `protobuf:"bytes,3,opt,name=communityID,proto3" json:"communityID,omitempty"`
	// Human-readable name of this storage epoch (not necessarily the community's name)
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// Hash kit used to hash PDI txns
	TxnHashKit ski.HashKitID `protobuf:"varint,6,opt,name=txn_hash_kit,json=txnHashKit,proto3,enum=ski.HashKitID" json:"txn_hash_kit,omitempty"`
	// Max byte size of txns allowed to be posted to StorageProviders with this epoch.
	TxnMaxSize uint32 `protobuf:"varint,7,opt,name=txn_max_size,json=txnMaxSize,proto3" json:"txn_max_size,omitempty"`
	// List of CommunityChID, identifying essential channel IDs for this community's reserved channel set.
	CommunityChIDs []byte `protobuf:"bytes,8,opt,name=community_chIDs,json=communityChIDs,proto3" json:"community_chIDs,omitempty"`
	// List of entry TIDs that are considered automatically valid at all times.
	GenesisEntryIDs [][]byte `protobuf:"bytes,9,rep,name=genesis_entryIDs,json=genesisEntryIDs" json:"genesis_entryIDs,omitempty"`
}

func (m *StorageEpoch) Reset()                    { *m = StorageEpoch{} }
func (m *StorageEpoch) String() string            { return proto.CompactTextString(m) }
func (*StorageEpoch) ProtoMessage()               {}
func (*StorageEpoch) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{15} }

func (m *StorageEpoch) GetOriginKey() *ski.KeyInfo {
	if m != nil {
		return m.OriginKey
	}
	return nil
}

func (m *StorageEpoch) GetStorageProtocol() string {
	if m != nil {
		return m.StorageProtocol
	}
	return ""
}

func (m *StorageEpoch) GetCommunityID() []byte {
	if m != nil {
		return m.CommunityID
	}
	return nil
}

func (m *StorageEpoch) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StorageEpoch) GetTxnHashKit() ski.HashKitID {
	if m != nil {
		return m.TxnHashKit
	}
	return ski.HashKitID_DEFAULT_HASH_KIT
}

func (m *StorageEpoch) GetTxnMaxSize() uint32 {
	if m != nil {
		return m.TxnMaxSize
	}
	return 0
}

func (m *StorageEpoch) GetCommunityChIDs() []byte {
	if m != nil {
		return m.CommunityChIDs
	}
	return nil
}

func (m *StorageEpoch) GetGenesisEntryIDs() [][]byte {
	if m != nil {
		return m.GenesisEntryIDs
	}
	return nil
}

type CommunityEpoch struct {
	// Immutable -- the community ID and community keyring name.
	CommunityID []byte `protobuf:"bytes,1,opt,name=communityID,proto3" json:"communityID,omitempty"`
	// Official community name
	CommunityName string `protobuf:"bytes,2,opt,name=community_name,json=communityName,proto3" json:"community_name,omitempty"`
	// Identifies the CryptoKit that members should/must use to sign newly authored entries.
	SigningCryptoKit ski.CryptoKitID `protobuf:"varint,3,opt,name=signing_crypto_kit,json=signingCryptoKit,proto3,enum=ski.CryptoKitID" json:"signing_crypto_kit,omitempty"`
	// The community key associated with this epoch, identifying this epoch.
	// KeyInfo.KeyType_SymmetricKey
	// Note that KeyInfo.CryptoKit specified here is also used when generating member asymmetric keys
	KeyInfo *ski.KeyInfo `protobuf:"bytes,4,opt,name=key_info,json=keyInfo" json:"key_info,omitempty"`
	// Identifies this CommunityEpoch.
	// This value is the entryTID of the entry that bourne this CommunityEpoch (if applicable)
	EpochTID []byte `protobuf:"bytes,5,opt,name=epochTID,proto3" json:"epochTID,omitempty"`
	// Names the ChannelEpoch being superseded.
	// Set to nil if there was no previous epoch and this CommunityEpoch reflects community genesis.
	PrevEpochTID []byte `protobuf:"bytes,6,opt,name=prev_epochTID,json=prevEpochTID,proto3" json:"prev_epochTID,omitempty"`
	// Hash kit used to hash PDI entries
	EntryHashKit ski.HashKitID `protobuf:"varint,7,opt,name=entry_hash_kit,json=entryHashKit,proto3,enum=ski.HashKitID" json:"entry_hash_kit,omitempty"`
	// Max delay (in secs) allowed between pdi.EntryInfo.TimeAuthored of an incoming entry
	//    and the TimeAuthored value of the most recently witnessed entry.  The idea is, how
	//    can entries arrive days or weeks and then a back-dated entry arrives (preventing
	//    "submarine" attacks).
	// Note: this only applies to non-private ACCs.
	MaxMemberLatency int64 `protobuf:"varint,8,opt,name=max_member_latency,json=maxMemberLatency,proto3" json:"max_member_latency,omitempty"`
	// Max number of seconds that any two community peers could have different clock readings.
	// This value implies a dependency time "slop" for validation.  That is, no entry can be dependent on another
	//     entry that is more than this value in the future.  Beyond this, this is a causality inconsistency.
	MaxMemberClockDelta int64 `protobuf:"varint,9,opt,name=max_member_clock_delta,json=maxMemberClockDelta,proto3" json:"max_member_clock_delta,omitempty"`
	// Max number of seconds delay between pdi.EntryInfo.TimeAuthored and its corresponding TxnInfo.TimeSealed.
	// Otherwise, entries that are sealed too late are auto-rejected during entry processing.
	// The downside of larger number is that it limits how long members can be offline until
	//     newly authored entries will be auto-rejected due to this security constraint.
	// Tier 0: posts to reserved community channels
	// Tier 1: posts to public ACCs
	MaxEntryLatency []int64 `protobuf:"varint,10,rep,packed,name=max_entry_latency,json=maxEntryLatency" json:"max_entry_latency,omitempty"`
	// This is how "standard" channels are discovered.
	Links []*plan.Link `protobuf:"bytes,20,rep,name=links" json:"links,omitempty"`
}

func (m *CommunityEpoch) Reset()                    { *m = CommunityEpoch{} }
func (m *CommunityEpoch) String() string            { return proto.CompactTextString(m) }
func (*CommunityEpoch) ProtoMessage()               {}
func (*CommunityEpoch) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{16} }

func (m *CommunityEpoch) GetCommunityID() []byte {
	if m != nil {
		return m.CommunityID
	}
	return nil
}

func (m *CommunityEpoch) GetCommunityName() string {
	if m != nil {
		return m.CommunityName
	}
	return ""
}

func (m *CommunityEpoch) GetSigningCryptoKit() ski.CryptoKitID {
	if m != nil {
		return m.SigningCryptoKit
	}
	return ski.CryptoKitID_DEFAULT_KIT
}

func (m *CommunityEpoch) GetKeyInfo() *ski.KeyInfo {
	if m != nil {
		return m.KeyInfo
	}
	return nil
}

func (m *CommunityEpoch) GetEpochTID() []byte {
	if m != nil {
		return m.EpochTID
	}
	return nil
}

func (m *CommunityEpoch) GetPrevEpochTID() []byte {
	if m != nil {
		return m.PrevEpochTID
	}
	return nil
}

func (m *CommunityEpoch) GetEntryHashKit() ski.HashKitID {
	if m != nil {
		return m.EntryHashKit
	}
	return ski.HashKitID_DEFAULT_HASH_KIT
}

func (m *CommunityEpoch) GetMaxMemberLatency() int64 {
	if m != nil {
		return m.MaxMemberLatency
	}
	return 0
}

func (m *CommunityEpoch) GetMaxMemberClockDelta() int64 {
	if m != nil {
		return m.MaxMemberClockDelta
	}
	return 0
}

func (m *CommunityEpoch) GetMaxEntryLatency() []int64 {
	if m != nil {
		return m.MaxEntryLatency
	}
	return nil
}

func (m *CommunityEpoch) GetLinks() []*plan.Link {
	if m != nil {
		return m.Links
	}
	return nil
}

// MemberEpoch publishes a PLAN community member's public keys and other "community-public" info.
// Members of a community uses its reserved MemberRegistryChannel as the starting point
//    to get critical community-public info about other members.  This process basically
//    involves fetching the most recently published MemberEpoch by a member.
// In effect, this allows community members to:
//    (1) open cryptographically secure channels with other members
//    (2) verify member sigs on channel entries (to ensure that they are authentic)
//    (3) generate and publish new keys when personal security has been compromised.
type MemberEpoch struct {
	// Identifies this MemberEpoch for a given member ID (and is nil during creation since the TID is not yet known).
	// This value is the entryTID of the entry that bears this MemberEpoch.
	EpochTID []byte `protobuf:"bytes,1,opt,name=epochTID,proto3" json:"epochTID,omitempty"`
	// Immutable -- generated during member genesis.
	// To ensure new member ID async uniqueness, community admins lease/reserve member ID ranges they are allowed to issue within.
	MemberID uint32 `protobuf:"varint,2,opt,name=memberID,proto3" json:"memberID,omitempty"`
	// Unix timestamp when this epoch entered into effect
	TimeStarted int64 `protobuf:"varint,5,opt,name=time_started,json=timeStarted,proto3" json:"time_started,omitempty"`
	// Specifies a UTF8 textual label that this member chooses to appear as in the community.
	Alias string `protobuf:"bytes,6,opt,name=alias,proto3" json:"alias,omitempty"`
	// Public keys associated with this member epoch
	PubSigningKey []byte `protobuf:"bytes,7,opt,name=pub_signing_key,json=pubSigningKey,proto3" json:"pub_signing_key,omitempty"`
	PubEncryptKey []byte `protobuf:"bytes,8,opt,name=pub_encrypt_key,json=pubEncryptKey,proto3" json:"pub_encrypt_key,omitempty"`
	// Future-proofing
	Extensions *plan.Block `protobuf:"bytes,9,opt,name=extensions" json:"extensions,omitempty"`
	// The ChannelID of this member's "about" channel
	AboutChID []byte `protobuf:"bytes,20,opt,name=about_chID,json=aboutChID,proto3" json:"about_chID,omitempty"`
	// The ChannelID of this member's home channel -- where visitors should first go
	HomeChID []byte `protobuf:"bytes,21,opt,name=home_chID,json=homeChID,proto3" json:"home_chID,omitempty"`
	// Channel of this memeber's contact channel
	ContactChID []byte `protobuf:"bytes,22,opt,name=contact_chID,json=contactChID,proto3" json:"contact_chID,omitempty"`
	// User root ACC.
	Member_ACC []byte `protobuf:"bytes,23,opt,name=member_ACC,json=memberACC,proto3" json:"member_ACC,omitempty"`
}

func (m *MemberEpoch) Reset()                    { *m = MemberEpoch{} }
func (m *MemberEpoch) String() string            { return proto.CompactTextString(m) }
func (*MemberEpoch) ProtoMessage()               {}
func (*MemberEpoch) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{17} }

func (m *MemberEpoch) GetEpochTID() []byte {
	if m != nil {
		return m.EpochTID
	}
	return nil
}

func (m *MemberEpoch) GetMemberID() uint32 {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *MemberEpoch) GetTimeStarted() int64 {
	if m != nil {
		return m.TimeStarted
	}
	return 0
}

func (m *MemberEpoch) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *MemberEpoch) GetPubSigningKey() []byte {
	if m != nil {
		return m.PubSigningKey
	}
	return nil
}

func (m *MemberEpoch) GetPubEncryptKey() []byte {
	if m != nil {
		return m.PubEncryptKey
	}
	return nil
}

func (m *MemberEpoch) GetExtensions() *plan.Block {
	if m != nil {
		return m.Extensions
	}
	return nil
}

func (m *MemberEpoch) GetAboutChID() []byte {
	if m != nil {
		return m.AboutChID
	}
	return nil
}

func (m *MemberEpoch) GetHomeChID() []byte {
	if m != nil {
		return m.HomeChID
	}
	return nil
}

func (m *MemberEpoch) GetContactChID() []byte {
	if m != nil {
		return m.ContactChID
	}
	return nil
}

func (m *MemberEpoch) GetMember_ACC() []byte {
	if m != nil {
		return m.Member_ACC
	}
	return nil
}

func init() {
	proto.RegisterType((*SessionReq)(nil), "pdi.SessionReq")
	proto.RegisterType((*StorageInfo)(nil), "pdi.StorageInfo")
	proto.RegisterType((*TxnInfo)(nil), "pdi.TxnInfo")
	proto.RegisterType((*Transfer)(nil), "pdi.Transfer")
	proto.RegisterType((*RawTxn)(nil), "pdi.RawTxn")
	proto.RegisterType((*TxnMetaInfo)(nil), "pdi.TxnMetaInfo")
	proto.RegisterType((*TxnScan)(nil), "pdi.TxnScan")
	proto.RegisterType((*TxnList)(nil), "pdi.TxnList")
	proto.RegisterType((*StorageAccount)(nil), "pdi.StorageAccount")
	proto.RegisterType((*AccessControls)(nil), "pdi.AccessControls")
	proto.RegisterType((*AccessGrant)(nil), "pdi.AccessGrant")
	proto.RegisterType((*ChannelEpoch)(nil), "pdi.ChannelEpoch")
	proto.RegisterType((*ChannelInfo)(nil), "pdi.ChannelInfo")
	proto.RegisterType((*EntryCrypt)(nil), "pdi.EntryCrypt")
	proto.RegisterType((*EntryInfo)(nil), "pdi.EntryInfo")
	proto.RegisterType((*StorageEpoch)(nil), "pdi.StorageEpoch")
	proto.RegisterType((*CommunityEpoch)(nil), "pdi.CommunityEpoch")
	proto.RegisterType((*MemberEpoch)(nil), "pdi.MemberEpoch")
	proto.RegisterEnum("pdi.TxnStatus", TxnStatus_name, TxnStatus_value)
	proto.RegisterEnum("pdi.AccessLevel", AccessLevel_name, AccessLevel_value)
	proto.RegisterEnum("pdi.EntryOp", EntryOp_name, EntryOp_value)
	proto.RegisterEnum("pdi.EntryVersion", EntryVersion_name, EntryVersion_value)
	proto.RegisterEnum("pdi.EntryTID", EntryTID_name, EntryTID_value)
	proto.RegisterEnum("pdi.CommunityChID", CommunityChID_name, CommunityChID_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for StorageProvider service

type StorageProviderClient interface {
	// Starts a new client session.
	StartSession(ctx context.Context, in *SessionReq, opts ...grpc.CallOption) (*StorageInfo, error)
	// Requests a sequence of txn IDs within a specified time window and other query criteria.
	Scan(ctx context.Context, in *TxnScan, opts ...grpc.CallOption) (StorageProvider_ScanClient, error)
	// Requests a set of txns to be sent to the client.
	FetchTxns(ctx context.Context, in *TxnList, opts ...grpc.CallOption) (StorageProvider_FetchTxnsClient, error)
	// Submits a txn ready to be written to the StorageProvider's permanent txn store.
	// RawTxn is generated by this StorageProvider's corresponding TxnEncoder.
	// For each StorageProvider implementation, one uses the accompanying txn marshalling encoder
	//    and decoder (TxnEncoder and TxnDecoder).
	CommitTxn(ctx context.Context, in *RawTxn, opts ...grpc.CallOption) (*plan.Status, error)
}

type storageProviderClient struct {
	cc *grpc.ClientConn
}

func NewStorageProviderClient(cc *grpc.ClientConn) StorageProviderClient {
	return &storageProviderClient{cc}
}

func (c *storageProviderClient) StartSession(ctx context.Context, in *SessionReq, opts ...grpc.CallOption) (*StorageInfo, error) {
	out := new(StorageInfo)
	err := grpc.Invoke(ctx, "/pdi.StorageProvider/StartSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageProviderClient) Scan(ctx context.Context, in *TxnScan, opts ...grpc.CallOption) (StorageProvider_ScanClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_StorageProvider_serviceDesc.Streams[0], c.cc, "/pdi.StorageProvider/Scan", opts...)
	if err != nil {
		return nil, err
	}
	x := &storageProviderScanClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StorageProvider_ScanClient interface {
	Recv() (*TxnList, error)
	grpc.ClientStream
}

type storageProviderScanClient struct {
	grpc.ClientStream
}

func (x *storageProviderScanClient) Recv() (*TxnList, error) {
	m := new(TxnList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *storageProviderClient) FetchTxns(ctx context.Context, in *TxnList, opts ...grpc.CallOption) (StorageProvider_FetchTxnsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_StorageProvider_serviceDesc.Streams[1], c.cc, "/pdi.StorageProvider/FetchTxns", opts...)
	if err != nil {
		return nil, err
	}
	x := &storageProviderFetchTxnsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StorageProvider_FetchTxnsClient interface {
	Recv() (*RawTxn, error)
	grpc.ClientStream
}

type storageProviderFetchTxnsClient struct {
	grpc.ClientStream
}

func (x *storageProviderFetchTxnsClient) Recv() (*RawTxn, error) {
	m := new(RawTxn)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *storageProviderClient) CommitTxn(ctx context.Context, in *RawTxn, opts ...grpc.CallOption) (*plan.Status, error) {
	out := new(plan.Status)
	err := grpc.Invoke(ctx, "/pdi.StorageProvider/CommitTxn", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for StorageProvider service

type StorageProviderServer interface {
	// Starts a new client session.
	StartSession(context.Context, *SessionReq) (*StorageInfo, error)
	// Requests a sequence of txn IDs within a specified time window and other query criteria.
	Scan(*TxnScan, StorageProvider_ScanServer) error
	// Requests a set of txns to be sent to the client.
	FetchTxns(*TxnList, StorageProvider_FetchTxnsServer) error
	// Submits a txn ready to be written to the StorageProvider's permanent txn store.
	// RawTxn is generated by this StorageProvider's corresponding TxnEncoder.
	// For each StorageProvider implementation, one uses the accompanying txn marshalling encoder
	//    and decoder (TxnEncoder and TxnDecoder).
	CommitTxn(context.Context, *RawTxn) (*plan.Status, error)
}

func RegisterStorageProviderServer(s *grpc.Server, srv StorageProviderServer) {
	s.RegisterService(&_StorageProvider_serviceDesc, srv)
}

func _StorageProvider_StartSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageProviderServer).StartSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdi.StorageProvider/StartSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageProviderServer).StartSession(ctx, req.(*SessionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageProvider_Scan_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TxnScan)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StorageProviderServer).Scan(m, &storageProviderScanServer{stream})
}

type StorageProvider_ScanServer interface {
	Send(*TxnList) error
	grpc.ServerStream
}

type storageProviderScanServer struct {
	grpc.ServerStream
}

func (x *storageProviderScanServer) Send(m *TxnList) error {
	return x.ServerStream.SendMsg(m)
}

func _StorageProvider_FetchTxns_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TxnList)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StorageProviderServer).FetchTxns(m, &storageProviderFetchTxnsServer{stream})
}

type StorageProvider_FetchTxnsServer interface {
	Send(*RawTxn) error
	grpc.ServerStream
}

type storageProviderFetchTxnsServer struct {
	grpc.ServerStream
}

func (x *storageProviderFetchTxnsServer) Send(m *RawTxn) error {
	return x.ServerStream.SendMsg(m)
}

func _StorageProvider_CommitTxn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RawTxn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageProviderServer).CommitTxn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pdi.StorageProvider/CommitTxn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageProviderServer).CommitTxn(ctx, req.(*RawTxn))
	}
	return interceptor(ctx, in, info, handler)
}

var _StorageProvider_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pdi.StorageProvider",
	HandlerType: (*StorageProviderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartSession",
			Handler:    _StorageProvider_StartSession_Handler,
		},
		{
			MethodName: "CommitTxn",
			Handler:    _StorageProvider_CommitTxn_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Scan",
			Handler:       _StorageProvider_Scan_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FetchTxns",
			Handler:       _StorageProvider_FetchTxns_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pdi.proto",
}

func (m *SessionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StorageEpoch != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.StorageEpoch.Size()))
		n1, err := m.StorageEpoch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.ProofOfAccess != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.ProofOfAccess.Size()))
		n2, err := m.ProofOfAccess.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *StorageInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SigResponse) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.SigResponse)))
		i += copy(dAtA[i:], m.SigResponse)
	}
	return i, nil
}

func (m *TxnInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Transfers) > 0 {
		for _, msg := range m.Transfers {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPdi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PayloadEncoding != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.PayloadEncoding))
	}
	if m.SegSz != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.SegSz))
	}
	if m.SegIndex != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.SegIndex))
	}
	if m.SegTotal != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.SegTotal))
	}
	if len(m.PrevURID) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.PrevURID)))
		i += copy(dAtA[i:], m.PrevURID)
	}
	if m.TimeSealed != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.TimeSealed))
	}
	if len(m.From) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.From)))
		i += copy(dAtA[i:], m.From)
	}
	if len(m.URID) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.URID)))
		i += copy(dAtA[i:], m.URID)
	}
	return i, nil
}

func (m *Transfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transfer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.To) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.To)))
		i += copy(dAtA[i:], m.To)
	}
	if m.Kb != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.Kb))
	}
	if m.Ops != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.Ops))
	}
	return i, nil
}

func (m *RawTxn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawTxn) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.URID)))
		i += copy(dAtA[i:], m.URID)
	}
	if m.TxnMetaInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.TxnMetaInfo.Size()))
		n3, err := m.TxnMetaInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Bytes) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.Bytes)))
		i += copy(dAtA[i:], m.Bytes)
	}
	return i, nil
}

func (m *TxnMetaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnMetaInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.URID)))
		i += copy(dAtA[i:], m.URID)
	}
	if m.TxnStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.TxnStatus))
	}
	if m.Alert != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.Alert.Size()))
		n4, err := m.Alert.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.ConsensusTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.ConsensusTime))
	}
	if len(m.TxnValidation) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.TxnValidation)))
		i += copy(dAtA[i:], m.TxnValidation)
	}
	return i, nil
}

func (m *TxnScan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnScan) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimestampStart != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.TimestampStart))
	}
	if m.TimestampStop != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.TimestampStop))
	}
	if m.SendTxnUpdates {
		dAtA[i] = 0x28
		i++
		if m.SendTxnUpdates {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxTxns != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.MaxTxns))
	}
	return i, nil
}

func (m *TxnList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URIDs) > 0 {
		for _, b := range m.URIDs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPdi(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Statuses) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.Statuses)))
		i += copy(dAtA[i:], m.Statuses)
	}
	return i, nil
}

func (m *StorageAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageAccount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KbBalance != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.KbBalance))
	}
	if m.OpBalance != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.OpBalance))
	}
	if m.CanTransfer {
		dAtA[i] = 0x18
		i++
		if m.CanTransfer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AccessControls) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessControls) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AccessGrant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessGrant) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AccessLevel != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.AccessLevel))
	}
	if len(m.Grantees) > 0 {
		dAtA6 := make([]byte, len(m.Grantees)*10)
		var j5 int
		for _, num := range m.Grantees {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintPdi(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	return i, nil
}

func (m *ChannelEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelEpoch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EpochTID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.EpochTID)))
		i += copy(dAtA[i:], m.EpochTID)
	}
	if len(m.PrevEpochTID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.PrevEpochTID)))
		i += copy(dAtA[i:], m.PrevEpochTID)
	}
	if m.EpochTransitionPeriod != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.EpochTransitionPeriod))
	}
	if len(m.CommunityEpochID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.CommunityEpochID)))
		i += copy(dAtA[i:], m.CommunityEpochID)
	}
	if len(m.ChProtocol) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.ChProtocol)))
		i += copy(dAtA[i:], m.ChProtocol)
	}
	if len(m.ACC) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.ACC)))
		i += copy(dAtA[i:], m.ACC)
	}
	if m.EntriesSupersedable {
		dAtA[i] = 0x40
		i++
		if m.EntriesSupersedable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SupersedableIsMutable {
		dAtA[i] = 0x48
		i++
		if m.SupersedableIsMutable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsExternallyShared {
		dAtA[i] = 0x50
		i++
		if m.IsExternallyShared {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PubKey) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.PubKey)))
		i += copy(dAtA[i:], m.PubKey)
	}
	if m.Extensions != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.Extensions.Size()))
		n7, err := m.Extensions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.DefaultAccessLevel != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.DefaultAccessLevel))
	}
	if len(m.AccessLevels) > 0 {
		for k, _ := range m.AccessLevels {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			v := m.AccessLevels[k]
			mapSize := 1 + sovPdi(uint64(k)) + 1 + sovPdi(uint64(v))
			i = encodeVarintPdi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintPdi(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintPdi(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *ChannelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChannelTID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.ChannelTID)))
		i += copy(dAtA[i:], m.ChannelTID)
	}
	if m.InfoRev != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.InfoRev))
	}
	if m.Info != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.Info.Size()))
		n8, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *EntryCrypt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntryCrypt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CommunityEpochID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.CommunityEpochID)))
		i += copy(dAtA[i:], m.CommunityEpochID)
	}
	if len(m.PackedEntry) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.PackedEntry)))
		i += copy(dAtA[i:], m.PackedEntry)
	}
	return i, nil
}

func (m *EntryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntryInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EntryOp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.EntryOp))
	}
	if m.EntrySubOp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPdi(dAtA, i, uint64((uint32(m.EntrySubOp)<<1)^uint32((m.EntrySubOp>>31))))
	}
	if len(m.ChannelID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.ChannelID)))
		i += copy(dAtA[i:], m.ChannelID)
	}
	if len(m.TIDs) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.TIDs)))
		i += copy(dAtA[i:], m.TIDs)
	}
	if len(m.SupersedesEntryID) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.SupersedesEntryID)))
		i += copy(dAtA[i:], m.SupersedesEntryID)
	}
	if m.Extensions != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.Extensions.Size()))
		n9, err := m.Extensions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.AuthorSig) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.AuthorSig)))
		i += copy(dAtA[i:], m.AuthorSig)
	}
	return i, nil
}

func (m *StorageEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageEpoch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OriginKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.OriginKey.Size()))
		n10, err := m.OriginKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.StorageProtocol) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.StorageProtocol)))
		i += copy(dAtA[i:], m.StorageProtocol)
	}
	if len(m.CommunityID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.CommunityID)))
		i += copy(dAtA[i:], m.CommunityID)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.TxnHashKit != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.TxnHashKit))
	}
	if m.TxnMaxSize != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.TxnMaxSize))
	}
	if len(m.CommunityChIDs) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.CommunityChIDs)))
		i += copy(dAtA[i:], m.CommunityChIDs)
	}
	if len(m.GenesisEntryIDs) > 0 {
		for _, b := range m.GenesisEntryIDs {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintPdi(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *CommunityEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommunityEpoch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CommunityID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.CommunityID)))
		i += copy(dAtA[i:], m.CommunityID)
	}
	if len(m.CommunityName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.CommunityName)))
		i += copy(dAtA[i:], m.CommunityName)
	}
	if m.SigningCryptoKit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.SigningCryptoKit))
	}
	if m.KeyInfo != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.KeyInfo.Size()))
		n11, err := m.KeyInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.EpochTID) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.EpochTID)))
		i += copy(dAtA[i:], m.EpochTID)
	}
	if len(m.PrevEpochTID) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.PrevEpochTID)))
		i += copy(dAtA[i:], m.PrevEpochTID)
	}
	if m.EntryHashKit != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.EntryHashKit))
	}
	if m.MaxMemberLatency != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.MaxMemberLatency))
	}
	if m.MaxMemberClockDelta != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.MaxMemberClockDelta))
	}
	if len(m.MaxEntryLatency) > 0 {
		dAtA13 := make([]byte, len(m.MaxEntryLatency)*10)
		var j12 int
		for _, num1 := range m.MaxEntryLatency {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		dAtA[i] = 0x52
		i++
		i = encodeVarintPdi(dAtA, i, uint64(j12))
		i += copy(dAtA[i:], dAtA13[:j12])
	}
	if len(m.Links) > 0 {
		for _, msg := range m.Links {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintPdi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MemberEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemberEpoch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EpochTID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.EpochTID)))
		i += copy(dAtA[i:], m.EpochTID)
	}
	if m.MemberID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.MemberID))
	}
	if m.TimeStarted != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.TimeStarted))
	}
	if len(m.Alias) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.Alias)))
		i += copy(dAtA[i:], m.Alias)
	}
	if len(m.PubSigningKey) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.PubSigningKey)))
		i += copy(dAtA[i:], m.PubSigningKey)
	}
	if len(m.PubEncryptKey) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.PubEncryptKey)))
		i += copy(dAtA[i:], m.PubEncryptKey)
	}
	if m.Extensions != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.Extensions.Size()))
		n14, err := m.Extensions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.AboutChID) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.AboutChID)))
		i += copy(dAtA[i:], m.AboutChID)
	}
	if len(m.HomeChID) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.HomeChID)))
		i += copy(dAtA[i:], m.HomeChID)
	}
	if len(m.ContactChID) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.ContactChID)))
		i += copy(dAtA[i:], m.ContactChID)
	}
	if len(m.Member_ACC) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.Member_ACC)))
		i += copy(dAtA[i:], m.Member_ACC)
	}
	return i, nil
}

func encodeVarintPdi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SessionReq) Size() (n int) {
	var l int
	_ = l
	if m.StorageEpoch != nil {
		l = m.StorageEpoch.Size()
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.ProofOfAccess != nil {
		l = m.ProofOfAccess.Size()
		n += 1 + l + sovPdi(uint64(l))
	}
	return n
}

func (m *StorageInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.SigResponse)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	return n
}

func (m *TxnInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Transfers) > 0 {
		for _, e := range m.Transfers {
			l = e.Size()
			n += 1 + l + sovPdi(uint64(l))
		}
	}
	if m.PayloadEncoding != 0 {
		n += 1 + sovPdi(uint64(m.PayloadEncoding))
	}
	if m.SegSz != 0 {
		n += 1 + sovPdi(uint64(m.SegSz))
	}
	if m.SegIndex != 0 {
		n += 1 + sovPdi(uint64(m.SegIndex))
	}
	if m.SegTotal != 0 {
		n += 1 + sovPdi(uint64(m.SegTotal))
	}
	l = len(m.PrevURID)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.TimeSealed != 0 {
		n += 1 + sovPdi(uint64(m.TimeSealed))
	}
	l = len(m.From)
	if l > 0 {
		n += 2 + l + sovPdi(uint64(l))
	}
	l = len(m.URID)
	if l > 0 {
		n += 2 + l + sovPdi(uint64(l))
	}
	return n
}

func (m *Transfer) Size() (n int) {
	var l int
	_ = l
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.Kb != 0 {
		n += 1 + sovPdi(uint64(m.Kb))
	}
	if m.Ops != 0 {
		n += 1 + sovPdi(uint64(m.Ops))
	}
	return n
}

func (m *RawTxn) Size() (n int) {
	var l int
	_ = l
	l = len(m.URID)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.TxnMetaInfo != nil {
		l = m.TxnMetaInfo.Size()
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.Bytes)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	return n
}

func (m *TxnMetaInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.URID)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.TxnStatus != 0 {
		n += 1 + sovPdi(uint64(m.TxnStatus))
	}
	if m.Alert != nil {
		l = m.Alert.Size()
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.ConsensusTime != 0 {
		n += 1 + sovPdi(uint64(m.ConsensusTime))
	}
	l = len(m.TxnValidation)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	return n
}

func (m *TxnScan) Size() (n int) {
	var l int
	_ = l
	if m.TimestampStart != 0 {
		n += 1 + sovPdi(uint64(m.TimestampStart))
	}
	if m.TimestampStop != 0 {
		n += 1 + sovPdi(uint64(m.TimestampStop))
	}
	if m.SendTxnUpdates {
		n += 2
	}
	if m.MaxTxns != 0 {
		n += 1 + sovPdi(uint64(m.MaxTxns))
	}
	return n
}

func (m *TxnList) Size() (n int) {
	var l int
	_ = l
	if len(m.URIDs) > 0 {
		for _, b := range m.URIDs {
			l = len(b)
			n += 1 + l + sovPdi(uint64(l))
		}
	}
	l = len(m.Statuses)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	return n
}

func (m *StorageAccount) Size() (n int) {
	var l int
	_ = l
	if m.KbBalance != 0 {
		n += 1 + sovPdi(uint64(m.KbBalance))
	}
	if m.OpBalance != 0 {
		n += 1 + sovPdi(uint64(m.OpBalance))
	}
	if m.CanTransfer {
		n += 2
	}
	return n
}

func (m *AccessControls) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AccessGrant) Size() (n int) {
	var l int
	_ = l
	if m.AccessLevel != 0 {
		n += 1 + sovPdi(uint64(m.AccessLevel))
	}
	if len(m.Grantees) > 0 {
		l = 0
		for _, e := range m.Grantees {
			l += sovPdi(uint64(e))
		}
		n += 1 + sovPdi(uint64(l)) + l
	}
	return n
}

func (m *ChannelEpoch) Size() (n int) {
	var l int
	_ = l
	l = len(m.EpochTID)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.PrevEpochTID)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.EpochTransitionPeriod != 0 {
		n += 1 + sovPdi(uint64(m.EpochTransitionPeriod))
	}
	l = len(m.CommunityEpochID)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.ChProtocol)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.ACC)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.EntriesSupersedable {
		n += 2
	}
	if m.SupersedableIsMutable {
		n += 2
	}
	if m.IsExternallyShared {
		n += 2
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.Extensions != nil {
		l = m.Extensions.Size()
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.DefaultAccessLevel != 0 {
		n += 2 + sovPdi(uint64(m.DefaultAccessLevel))
	}
	if len(m.AccessLevels) > 0 {
		for k, v := range m.AccessLevels {
			_ = k
			_ = v
			mapEntrySize := 1 + sovPdi(uint64(k)) + 1 + sovPdi(uint64(v))
			n += mapEntrySize + 2 + sovPdi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ChannelInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChannelTID)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.InfoRev != 0 {
		n += 1 + sovPdi(uint64(m.InfoRev))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovPdi(uint64(l))
	}
	return n
}

func (m *EntryCrypt) Size() (n int) {
	var l int
	_ = l
	l = len(m.CommunityEpochID)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.PackedEntry)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	return n
}

func (m *EntryInfo) Size() (n int) {
	var l int
	_ = l
	if m.EntryOp != 0 {
		n += 1 + sovPdi(uint64(m.EntryOp))
	}
	if m.EntrySubOp != 0 {
		n += 1 + sozPdi(uint64(m.EntrySubOp))
	}
	l = len(m.ChannelID)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.TIDs)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.SupersedesEntryID)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.Extensions != nil {
		l = m.Extensions.Size()
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.AuthorSig)
	if l > 0 {
		n += 2 + l + sovPdi(uint64(l))
	}
	return n
}

func (m *StorageEpoch) Size() (n int) {
	var l int
	_ = l
	if m.OriginKey != nil {
		l = m.OriginKey.Size()
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.StorageProtocol)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.CommunityID)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.TxnHashKit != 0 {
		n += 1 + sovPdi(uint64(m.TxnHashKit))
	}
	if m.TxnMaxSize != 0 {
		n += 1 + sovPdi(uint64(m.TxnMaxSize))
	}
	l = len(m.CommunityChIDs)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if len(m.GenesisEntryIDs) > 0 {
		for _, b := range m.GenesisEntryIDs {
			l = len(b)
			n += 1 + l + sovPdi(uint64(l))
		}
	}
	return n
}

func (m *CommunityEpoch) Size() (n int) {
	var l int
	_ = l
	l = len(m.CommunityID)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.CommunityName)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.SigningCryptoKit != 0 {
		n += 1 + sovPdi(uint64(m.SigningCryptoKit))
	}
	if m.KeyInfo != nil {
		l = m.KeyInfo.Size()
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.EpochTID)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.PrevEpochTID)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.EntryHashKit != 0 {
		n += 1 + sovPdi(uint64(m.EntryHashKit))
	}
	if m.MaxMemberLatency != 0 {
		n += 1 + sovPdi(uint64(m.MaxMemberLatency))
	}
	if m.MaxMemberClockDelta != 0 {
		n += 1 + sovPdi(uint64(m.MaxMemberClockDelta))
	}
	if len(m.MaxEntryLatency) > 0 {
		l = 0
		for _, e := range m.MaxEntryLatency {
			l += sovPdi(uint64(e))
		}
		n += 1 + sovPdi(uint64(l)) + l
	}
	if len(m.Links) > 0 {
		for _, e := range m.Links {
			l = e.Size()
			n += 2 + l + sovPdi(uint64(l))
		}
	}
	return n
}

func (m *MemberEpoch) Size() (n int) {
	var l int
	_ = l
	l = len(m.EpochTID)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.MemberID != 0 {
		n += 1 + sovPdi(uint64(m.MemberID))
	}
	if m.TimeStarted != 0 {
		n += 1 + sovPdi(uint64(m.TimeStarted))
	}
	l = len(m.Alias)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.PubSigningKey)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.PubEncryptKey)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.Extensions != nil {
		l = m.Extensions.Size()
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.AboutChID)
	if l > 0 {
		n += 2 + l + sovPdi(uint64(l))
	}
	l = len(m.HomeChID)
	if l > 0 {
		n += 2 + l + sovPdi(uint64(l))
	}
	l = len(m.ContactChID)
	if l > 0 {
		n += 2 + l + sovPdi(uint64(l))
	}
	l = len(m.Member_ACC)
	if l > 0 {
		n += 2 + l + sovPdi(uint64(l))
	}
	return n
}

func sovPdi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPdi(x uint64) (n int) {
	return sovPdi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SessionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageEpoch == nil {
				m.StorageEpoch = &StorageEpoch{}
			}
			if err := m.StorageEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofOfAccess", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofOfAccess == nil {
				m.ProofOfAccess = &RawTxn{}
			}
			if err := m.ProofOfAccess.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigResponse", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SigResponse = append(m.SigResponse[:0], dAtA[iNdEx:postIndex]...)
			if m.SigResponse == nil {
				m.SigResponse = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transfers = append(m.Transfers, &Transfer{})
			if err := m.Transfers[len(m.Transfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadEncoding", wireType)
			}
			m.PayloadEncoding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadEncoding |= (plan.Encoding(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegSz", wireType)
			}
			m.SegSz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegSz |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegIndex", wireType)
			}
			m.SegIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegTotal", wireType)
			}
			m.SegTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegTotal |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevURID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevURID = append(m.PrevURID[:0], dAtA[iNdEx:postIndex]...)
			if m.PrevURID == nil {
				m.PrevURID = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeSealed", wireType)
			}
			m.TimeSealed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeSealed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = append(m.From[:0], dAtA[iNdEx:postIndex]...)
			if m.From == nil {
				m.From = []byte{}
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URID = append(m.URID[:0], dAtA[iNdEx:postIndex]...)
			if m.URID == nil {
				m.URID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To[:0], dAtA[iNdEx:postIndex]...)
			if m.To == nil {
				m.To = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kb", wireType)
			}
			m.Kb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kb |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ops", wireType)
			}
			m.Ops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ops |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawTxn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawTxn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawTxn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URID = append(m.URID[:0], dAtA[iNdEx:postIndex]...)
			if m.URID == nil {
				m.URID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnMetaInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxnMetaInfo == nil {
				m.TxnMetaInfo = &TxnMetaInfo{}
			}
			if err := m.TxnMetaInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bytes = append(m.Bytes[:0], dAtA[iNdEx:postIndex]...)
			if m.Bytes == nil {
				m.Bytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnMetaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnMetaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnMetaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URID = append(m.URID[:0], dAtA[iNdEx:postIndex]...)
			if m.URID == nil {
				m.URID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnStatus", wireType)
			}
			m.TxnStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnStatus |= (TxnStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Alert == nil {
				m.Alert = &plan.Status{}
			}
			if err := m.Alert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusTime", wireType)
			}
			m.ConsensusTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsensusTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnValidation", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxnValidation = append(m.TxnValidation[:0], dAtA[iNdEx:postIndex]...)
			if m.TxnValidation == nil {
				m.TxnValidation = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnScan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnScan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnScan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampStart", wireType)
			}
			m.TimestampStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampStart |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampStop", wireType)
			}
			m.TimestampStop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampStop |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendTxnUpdates", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendTxnUpdates = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTxns", wireType)
			}
			m.MaxTxns = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTxns |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIDs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URIDs = append(m.URIDs, make([]byte, postIndex-iNdEx))
			copy(m.URIDs[len(m.URIDs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statuses", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statuses = append(m.Statuses[:0], dAtA[iNdEx:postIndex]...)
			if m.Statuses == nil {
				m.Statuses = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KbBalance", wireType)
			}
			m.KbBalance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KbBalance |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpBalance", wireType)
			}
			m.OpBalance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpBalance |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanTransfer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanTransfer = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessControls) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessControls: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessControls: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessGrant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessGrant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessGrant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessLevel", wireType)
			}
			m.AccessLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessLevel |= (AccessLevel(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Grantees = append(m.Grantees, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPdi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPdi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Grantees = append(m.Grantees, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Grantees", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochTID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EpochTID = append(m.EpochTID[:0], dAtA[iNdEx:postIndex]...)
			if m.EpochTID == nil {
				m.EpochTID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevEpochTID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevEpochTID = append(m.PrevEpochTID[:0], dAtA[iNdEx:postIndex]...)
			if m.PrevEpochTID == nil {
				m.PrevEpochTID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochTransitionPeriod", wireType)
			}
			m.EpochTransitionPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochTransitionPeriod |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityEpochID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunityEpochID = append(m.CommunityEpochID[:0], dAtA[iNdEx:postIndex]...)
			if m.CommunityEpochID == nil {
				m.CommunityEpochID = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChProtocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChProtocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ACC", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ACC = append(m.ACC[:0], dAtA[iNdEx:postIndex]...)
			if m.ACC == nil {
				m.ACC = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntriesSupersedable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EntriesSupersedable = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupersedableIsMutable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupersedableIsMutable = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsExternallyShared", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsExternallyShared = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extensions == nil {
				m.Extensions = &plan.Block{}
			}
			if err := m.Extensions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultAccessLevel", wireType)
			}
			m.DefaultAccessLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultAccessLevel |= (AccessLevel(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessLevels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessLevels == nil {
				m.AccessLevels = make(map[uint32]AccessLevel)
			}
			var mapkey uint32
			var mapvalue AccessLevel
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPdi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPdi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (AccessLevel(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPdi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPdi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AccessLevels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelTID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelTID = append(m.ChannelTID[:0], dAtA[iNdEx:postIndex]...)
			if m.ChannelTID == nil {
				m.ChannelTID = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoRev", wireType)
			}
			m.InfoRev = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InfoRev |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &plan.Block{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntryCrypt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntryCrypt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntryCrypt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityEpochID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunityEpochID = append(m.CommunityEpochID[:0], dAtA[iNdEx:postIndex]...)
			if m.CommunityEpochID == nil {
				m.CommunityEpochID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedEntry", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackedEntry = append(m.PackedEntry[:0], dAtA[iNdEx:postIndex]...)
			if m.PackedEntry == nil {
				m.PackedEntry = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryOp", wireType)
			}
			m.EntryOp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryOp |= (EntryOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntrySubOp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EntrySubOp = v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelID = append(m.ChannelID[:0], dAtA[iNdEx:postIndex]...)
			if m.ChannelID == nil {
				m.ChannelID = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TIDs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TIDs = append(m.TIDs[:0], dAtA[iNdEx:postIndex]...)
			if m.TIDs == nil {
				m.TIDs = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupersedesEntryID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupersedesEntryID = append(m.SupersedesEntryID[:0], dAtA[iNdEx:postIndex]...)
			if m.SupersedesEntryID == nil {
				m.SupersedesEntryID = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extensions == nil {
				m.Extensions = &plan.Block{}
			}
			if err := m.Extensions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorSig = append(m.AuthorSig[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthorSig == nil {
				m.AuthorSig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginKey == nil {
				m.OriginKey = &ski.KeyInfo{}
			}
			if err := m.OriginKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageProtocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageProtocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunityID = append(m.CommunityID[:0], dAtA[iNdEx:postIndex]...)
			if m.CommunityID == nil {
				m.CommunityID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnHashKit", wireType)
			}
			m.TxnHashKit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnHashKit |= (ski.HashKitID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnMaxSize", wireType)
			}
			m.TxnMaxSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnMaxSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityChIDs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunityChIDs = append(m.CommunityChIDs[:0], dAtA[iNdEx:postIndex]...)
			if m.CommunityChIDs == nil {
				m.CommunityChIDs = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisEntryIDs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GenesisEntryIDs = append(m.GenesisEntryIDs, make([]byte, postIndex-iNdEx))
			copy(m.GenesisEntryIDs[len(m.GenesisEntryIDs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommunityEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommunityEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommunityEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunityID = append(m.CommunityID[:0], dAtA[iNdEx:postIndex]...)
			if m.CommunityID == nil {
				m.CommunityID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunityName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningCryptoKit", wireType)
			}
			m.SigningCryptoKit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SigningCryptoKit |= (ski.CryptoKitID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyInfo == nil {
				m.KeyInfo = &ski.KeyInfo{}
			}
			if err := m.KeyInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochTID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EpochTID = append(m.EpochTID[:0], dAtA[iNdEx:postIndex]...)
			if m.EpochTID == nil {
				m.EpochTID = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevEpochTID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevEpochTID = append(m.PrevEpochTID[:0], dAtA[iNdEx:postIndex]...)
			if m.PrevEpochTID == nil {
				m.PrevEpochTID = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryHashKit", wireType)
			}
			m.EntryHashKit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryHashKit |= (ski.HashKitID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMemberLatency", wireType)
			}
			m.MaxMemberLatency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMemberLatency |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMemberClockDelta", wireType)
			}
			m.MaxMemberClockDelta = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMemberClockDelta |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MaxEntryLatency = append(m.MaxEntryLatency, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPdi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPdi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPdi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MaxEntryLatency = append(m.MaxEntryLatency, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxEntryLatency", wireType)
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Links = append(m.Links, &plan.Link{})
			if err := m.Links[len(m.Links)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemberEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemberEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemberEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochTID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EpochTID = append(m.EpochTID[:0], dAtA[iNdEx:postIndex]...)
			if m.EpochTID == nil {
				m.EpochTID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStarted", wireType)
			}
			m.TimeStarted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeStarted |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubSigningKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubSigningKey = append(m.PubSigningKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubSigningKey == nil {
				m.PubSigningKey = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubEncryptKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubEncryptKey = append(m.PubEncryptKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubEncryptKey == nil {
				m.PubEncryptKey = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extensions == nil {
				m.Extensions = &plan.Block{}
			}
			if err := m.Extensions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AboutChID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AboutChID = append(m.AboutChID[:0], dAtA[iNdEx:postIndex]...)
			if m.AboutChID == nil {
				m.AboutChID = []byte{}
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeChID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomeChID = append(m.HomeChID[:0], dAtA[iNdEx:postIndex]...)
			if m.HomeChID == nil {
				m.HomeChID = []byte{}
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContactChID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContactChID = append(m.ContactChID[:0], dAtA[iNdEx:postIndex]...)
			if m.ContactChID == nil {
				m.ContactChID = []byte{}
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member_ACC", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Member_ACC = append(m.Member_ACC[:0], dAtA[iNdEx:postIndex]...)
			if m.Member_ACC == nil {
				m.Member_ACC = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPdi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPdi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPdi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPdi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPdi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPdi   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("pdi.proto", fileDescriptorPdi) }

var fileDescriptorPdi = []byte{
	// 2222 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x58, 0xcd, 0x6e, 0x1b, 0xc9,
	0x11, 0xf6, 0x90, 0x92, 0x48, 0x16, 0xff, 0x46, 0x6d, 0xc9, 0x66, 0x94, 0xd8, 0x2b, 0x73, 0x13,
	0xaf, 0x22, 0xc7, 0xb6, 0xd6, 0x5e, 0x2c, 0xf2, 0x87, 0x00, 0x34, 0x39, 0xb6, 0x09, 0x4b, 0xa4,
	0xd3, 0xa4, 0x6d, 0x24, 0x08, 0x32, 0x68, 0x0e, 0x5b, 0xe4, 0x80, 0xe4, 0xcc, 0xec, 0x74, 0x53,
	0x21, 0x7d, 0xcd, 0x21, 0x40, 0x9e, 0x20, 0xa7, 0x5c, 0x73, 0xc8, 0x2b, 0xe4, 0x14, 0xe4, 0x90,
	0x63, 0x1e, 0x21, 0x70, 0x6e, 0x79, 0x83, 0xdc, 0x82, 0xaa, 0x9e, 0x19, 0xd1, 0x2b, 0xef, 0xfa,
	0x20, 0xa1, 0xeb, 0xab, 0xea, 0xee, 0xfa, 0xaf, 0x1e, 0x42, 0x29, 0x1a, 0xfb, 0x0f, 0xa2, 0x38,
	0xd4, 0x21, 0xcb, 0x47, 0x63, 0xff, 0xe0, 0xe1, 0xc4, 0xd7, 0xd3, 0xe5, 0xe8, 0x81, 0x17, 0x2e,
	0x1e, 0x46, 0x73, 0x11, 0xdc, 0x57, 0x6b, 0xa5, 0xe5, 0x42, 0x3d, 0x9c, 0x84, 0xf7, 0x91, 0x7e,
	0x98, 0xfd, 0x33, 0xbb, 0x0e, 0xee, 0x7f, 0x6c, 0x83, 0x9a, 0xf9, 0xf8, 0x67, 0xc4, 0x9b, 0x6b,
	0x80, 0x81, 0x54, 0xca, 0x0f, 0x03, 0x2e, 0xbf, 0x62, 0x5f, 0x42, 0x55, 0xe9, 0x30, 0x16, 0x13,
	0xe9, 0xca, 0x28, 0xf4, 0xa6, 0x0d, 0xeb, 0xd0, 0x3a, 0x2a, 0x3f, 0xda, 0x7d, 0x80, 0x5a, 0x0d,
	0x0c, 0xc7, 0x41, 0x06, 0xaf, 0xa8, 0x0d, 0x8a, 0x3d, 0x86, 0x7a, 0x14, 0x87, 0xe1, 0xb9, 0x1b,
	0x9e, 0xbb, 0xc2, 0xf3, 0xa4, 0x52, 0x8d, 0x1c, 0xed, 0x2c, 0xd3, 0x4e, 0x2e, 0x7e, 0x37, 0x5c,
	0x05, 0xbc, 0x4a, 0x32, 0xfd, 0xf3, 0x16, 0x49, 0x34, 0x4f, 0xa0, 0x9c, 0x1c, 0xd9, 0x0d, 0xce,
	0x43, 0x76, 0x07, 0x2a, 0xca, 0x9f, 0xb8, 0xb1, 0x54, 0x51, 0x18, 0x28, 0x49, 0x57, 0x57, 0x78,
	0x59, 0xf9, 0x13, 0x9e, 0x40, 0xcd, 0xbf, 0xe4, 0xa0, 0x30, 0x5c, 0x05, 0x24, 0x7e, 0x0f, 0x4a,
	0x3a, 0x16, 0x81, 0x3a, 0x97, 0x31, 0x5e, 0x96, 0x3f, 0x2a, 0x3f, 0xaa, 0xd2, 0x65, 0xc3, 0x04,
	0xe5, 0x97, 0x7c, 0xf6, 0x13, 0xb0, 0x23, 0xb1, 0x9e, 0x87, 0x62, 0xec, 0xca, 0xc0, 0x0b, 0xc7,
	0x7e, 0x30, 0x69, 0x6c, 0x1f, 0x5a, 0x47, 0xb5, 0x47, 0xb5, 0x07, 0xe4, 0x3b, 0x27, 0x41, 0x79,
	0x3d, 0x91, 0x4b, 0x01, 0xb6, 0x0f, 0x3b, 0x4a, 0x4e, 0x5c, 0xf5, 0xb6, 0x51, 0x3c, 0xb4, 0x8e,
	0xaa, 0x7c, 0x5b, 0xc9, 0xc9, 0xe0, 0x2d, 0xfb, 0x2e, 0x94, 0x10, 0xf6, 0x83, 0xb1, 0x5c, 0x35,
	0x4a, 0xc4, 0x29, 0x2a, 0x39, 0xe9, 0x22, 0x9d, 0x32, 0x75, 0xa8, 0xc5, 0xbc, 0x01, 0x19, 0x73,
	0x88, 0x34, 0x3b, 0x80, 0x62, 0x14, 0xcb, 0x8b, 0x57, 0xbc, 0xdb, 0x69, 0x94, 0xc9, 0xc6, 0x8c,
	0x66, 0x9f, 0x40, 0x59, 0xfb, 0x0b, 0xe9, 0x2a, 0x29, 0xe6, 0x72, 0xdc, 0xa8, 0x1c, 0x5a, 0x47,
	0x79, 0x0e, 0x08, 0x0d, 0x08, 0x61, 0x0c, 0xb6, 0xce, 0xe3, 0x70, 0xd1, 0xd8, 0xa3, 0x8d, 0xb4,
	0x46, 0x8c, 0x0e, 0xdb, 0x37, 0x18, 0xae, 0x9b, 0x3f, 0x87, 0x62, 0xea, 0x07, 0x56, 0x83, 0x9c,
	0x0e, 0x13, 0x77, 0xe6, 0x74, 0x88, 0xf4, 0x6c, 0x44, 0xf1, 0xc9, 0xf3, 0xdc, 0x6c, 0xc4, 0x6c,
	0xc8, 0x87, 0x91, 0x6a, 0xe4, 0x09, 0xc0, 0x65, 0x73, 0x0a, 0x3b, 0x26, 0x64, 0xd9, 0xd9, 0xd6,
	0xe5, 0xd9, 0xec, 0x0b, 0xa8, 0xea, 0x55, 0xe0, 0x2e, 0xa4, 0x16, 0xae, 0x1f, 0x9c, 0x87, 0x49,
	0xa8, 0x6d, 0xe3, 0xfd, 0x55, 0x70, 0x26, 0xb5, 0xc0, 0x10, 0xf1, 0xb2, 0xbe, 0x24, 0xd8, 0x1e,
	0x6c, 0x8f, 0xd6, 0x5a, 0x9a, 0x7b, 0x2a, 0xdc, 0x10, 0xcd, 0xbf, 0x5b, 0x50, 0xde, 0xd8, 0xf2,
	0xc1, 0xfb, 0xee, 0x03, 0xe0, 0x7d, 0x4a, 0x0b, 0xbd, 0x34, 0x79, 0x45, 0x61, 0x33, 0x97, 0x0d,
	0x08, 0xe5, 0x25, 0x9d, 0x2e, 0x59, 0x13, 0xb6, 0xc5, 0x5c, 0xc6, 0x9a, 0x2e, 0x2a, 0x3f, 0xaa,
	0x98, 0x00, 0x27, 0x72, 0x86, 0xc5, 0x7e, 0x00, 0x35, 0x0f, 0x33, 0x2a, 0x50, 0x4b, 0xe5, 0xa2,
	0x7b, 0x1b, 0x5b, 0x64, 0x7d, 0x35, 0x43, 0x87, 0xfe, 0x42, 0xa2, 0x18, 0xde, 0x7c, 0x21, 0xe6,
	0xfe, 0x58, 0x68, 0x3f, 0x0c, 0x28, 0x69, 0x2a, 0x1c, 0xed, 0x7f, 0x9d, 0x81, 0xcd, 0x3f, 0x5b,
	0x94, 0x96, 0x03, 0x4f, 0x04, 0xec, 0x33, 0xa8, 0xe3, 0x79, 0x4a, 0x8b, 0x45, 0x84, 0x2a, 0xc7,
	0x9a, 0x6c, 0xc9, 0xf3, 0x5a, 0x06, 0x0f, 0x10, 0xa5, 0xb3, 0x37, 0x04, 0xc3, 0x28, 0x89, 0x48,
	0x75, 0x43, 0x2e, 0x8c, 0xd8, 0x11, 0xd8, 0x4a, 0x06, 0x63, 0x17, 0xf5, 0x58, 0x46, 0x63, 0x81,
	0x1e, 0x44, 0x25, 0x8a, 0xbc, 0x86, 0xf8, 0x70, 0x15, 0xbc, 0x32, 0x28, 0xfb, 0x0e, 0x14, 0x17,
	0x62, 0x85, 0x82, 0xaa, 0x51, 0x38, 0xb4, 0x8e, 0xb6, 0x79, 0x61, 0x21, 0x56, 0xc3, 0x55, 0xa0,
	0x9a, 0x3f, 0x23, 0xfd, 0x4e, 0x7d, 0xa5, 0x31, 0x0c, 0xe8, 0x54, 0x53, 0x32, 0x15, 0x6e, 0x08,
	0xcc, 0x49, 0xe3, 0xde, 0x2c, 0x3e, 0x19, 0xdd, 0xfc, 0x0a, 0x6a, 0x49, 0x99, 0xb6, 0x3c, 0x2f,
	0x5c, 0x06, 0x9a, 0xdd, 0x02, 0x98, 0x8d, 0xdc, 0x91, 0x98, 0x8b, 0xc0, 0x93, 0x89, 0x79, 0xa5,
	0xd9, 0xe8, 0x89, 0x01, 0x90, 0x1d, 0x46, 0x19, 0xdb, 0x58, 0x55, 0x0a, 0xa3, 0x94, 0x7d, 0x07,
	0x2a, 0x9e, 0x08, 0xdc, 0xb4, 0x38, 0xe9, 0xbe, 0x22, 0x2f, 0x7b, 0x22, 0x48, 0x33, 0xb6, 0x69,
	0x43, 0xcd, 0xf4, 0x88, 0x76, 0x18, 0xe8, 0x38, 0x9c, 0xab, 0xe6, 0x6f, 0xa1, 0x6c, 0x90, 0x67,
	0xb1, 0x08, 0x34, 0x7b, 0x0c, 0x15, 0xd3, 0x66, 0xdc, 0xb9, 0xbc, 0x90, 0x73, 0xd2, 0xa1, 0x96,
	0x64, 0xa0, 0x91, 0x3b, 0x45, 0x9c, 0x97, 0xc5, 0x25, 0x81, 0x46, 0x4e, 0x70, 0xb7, 0x94, 0xc6,
	0xfa, 0x2a, 0xcf, 0xe8, 0xe6, 0x5f, 0xb7, 0xa1, 0xd2, 0x9e, 0x8a, 0x20, 0x90, 0x73, 0xd3, 0xd1,
	0x0e, 0xa0, 0x48, 0x1d, 0x70, 0x98, 0x25, 0x63, 0x46, 0xb3, 0x4f, 0xa1, 0x8a, 0x15, 0xeb, 0x66,
	0x02, 0x39, 0x12, 0xa8, 0x20, 0xe8, 0xa4, 0x42, 0x5f, 0xc2, 0x4d, 0xe2, 0x1b, 0x43, 0x7d, 0x4c,
	0x14, 0x37, 0x92, 0xb1, 0x1f, 0x8e, 0x93, 0x4a, 0xdb, 0x37, 0xdb, 0x33, 0xee, 0x4b, 0x62, 0xb2,
	0x7b, 0xb0, 0xeb, 0x85, 0x8b, 0xc5, 0x32, 0xf0, 0xf5, 0xda, 0xdc, 0xd0, 0xed, 0x50, 0x76, 0x56,
	0xb8, 0x9d, 0x31, 0x1c, 0x83, 0x63, 0xbf, 0xf0, 0xa6, 0x2e, 0x75, 0x72, 0x2f, 0x9c, 0x53, 0x62,
	0x94, 0x38, 0x78, 0xd3, 0x97, 0x09, 0x82, 0xb5, 0xdd, 0x6a, 0xb7, 0x1b, 0x3b, 0xb4, 0x1f, 0x97,
	0xec, 0x73, 0xd8, 0x93, 0x81, 0x8e, 0x7d, 0xa9, 0x5c, 0xb5, 0x8c, 0x64, 0xac, 0xe4, 0x58, 0x8c,
	0xe6, 0x92, 0xba, 0x5b, 0x91, 0x5f, 0x4f, 0x78, 0x83, 0x0d, 0x16, 0x9a, 0xb2, 0x29, 0xea, 0xfa,
	0xca, 0x5d, 0x2c, 0x35, 0xed, 0x2a, 0xd1, 0xae, 0xfd, 0x4d, 0x76, 0x57, 0x9d, 0x19, 0x26, 0x3b,
	0x81, 0x3d, 0x5f, 0xb9, 0x72, 0xa5, 0x65, 0x1c, 0x88, 0xf9, 0x7c, 0xed, 0xaa, 0xa9, 0x88, 0xe5,
	0x98, 0x3a, 0x62, 0x91, 0x33, 0x5f, 0x39, 0x19, 0x6b, 0x40, 0x1c, 0x76, 0x13, 0x0a, 0xd1, 0x72,
	0xe4, 0xce, 0xe4, 0x3a, 0x69, 0x8d, 0x3b, 0xd1, 0x72, 0xf4, 0x42, 0xae, 0xd9, 0x3d, 0x00, 0x3c,
	0x27, 0xc0, 0x41, 0xa5, 0xa8, 0x2f, 0xd2, 0x6c, 0xc1, 0xca, 0x7e, 0x32, 0x0f, 0xbd, 0x19, 0xdf,
	0x60, 0xb3, 0x27, 0xb0, 0x37, 0x96, 0xe7, 0x62, 0x39, 0xd7, 0xee, 0x7b, 0x59, 0xb2, 0xf7, 0x0d,
	0x59, 0xc2, 0x12, 0xe9, 0x0d, 0x8c, 0x3d, 0x87, 0xea, 0xe6, 0x5e, 0xd5, 0xd8, 0xa7, 0x11, 0xf3,
	0x29, 0x6d, 0xde, 0xcc, 0x94, 0xcd, 0x93, 0x94, 0x13, 0xe8, 0x78, 0xcd, 0x2b, 0x1b, 0x59, 0xa7,
	0x0e, 0x7e, 0x09, 0xbb, 0x57, 0x44, 0x30, 0x2e, 0x68, 0xa4, 0x45, 0xb3, 0x01, 0x97, 0xec, 0x2e,
	0x6c, 0x5f, 0x88, 0xf9, 0x52, 0x26, 0x0d, 0xee, 0xaa, 0x96, 0x86, 0xfd, 0xd3, 0xdc, 0x8f, 0xad,
	0xa6, 0x0f, 0xe5, 0x44, 0x05, 0x6a, 0x9a, 0xb7, 0x01, 0x3c, 0x43, 0x5e, 0x66, 0xeb, 0x06, 0x82,
	0x9d, 0x01, 0xfb, 0xb4, 0x1b, 0xcb, 0x0b, 0xea, 0x0c, 0x55, 0x5e, 0x40, 0x9a, 0xcb, 0x0b, 0xf6,
	0x09, 0x6c, 0x51, 0x0b, 0x2f, 0x5e, 0xf5, 0x28, 0x31, 0x9a, 0xbf, 0x01, 0x20, 0x8d, 0xdb, 0xf1,
	0x3a, 0xd2, 0x1f, 0x4e, 0x4e, 0xeb, 0x1b, 0x92, 0xf3, 0x0e, 0x54, 0x22, 0xe1, 0xcd, 0x24, 0xce,
	0x5c, 0x1d, 0xaf, 0x93, 0x2a, 0x29, 0x1b, 0x8c, 0x0e, 0x6d, 0xfe, 0x3e, 0x07, 0x25, 0x5a, 0x91,
	0x1d, 0x9f, 0x41, 0x91, 0x24, 0xdd, 0x30, 0x4a, 0x2a, 0xba, 0x42, 0x5e, 0x20, 0x89, 0x7e, 0xc4,
	0x0b, 0xd2, 0x2c, 0xd8, 0x21, 0x54, 0x8c, 0xa0, 0x5a, 0x8e, 0xdc, 0xa4, 0x73, 0xee, 0x72, 0x20,
	0x6c, 0xb0, 0x1c, 0xf5, 0x23, 0xf6, 0x3d, 0x28, 0x25, 0x0e, 0xc8, 0xaa, 0xe7, 0x12, 0xc0, 0x29,
	0x33, 0xc4, 0x1e, 0x68, 0xba, 0x39, 0xad, 0xd9, 0x7d, 0x60, 0x69, 0x16, 0x4b, 0x65, 0x34, 0xee,
	0x76, 0x92, 0xc2, 0xd9, 0xbd, 0xe4, 0x18, 0x6d, 0x3b, 0x5f, 0x4b, 0xc8, 0xf2, 0xb7, 0x27, 0xe4,
	0x2d, 0x00, 0xb1, 0xd4, 0xd3, 0x30, 0x76, 0x95, 0x3f, 0x49, 0x66, 0x77, 0xc9, 0x20, 0x03, 0x7f,
	0xd2, 0xfc, 0x47, 0x0e, 0x2a, 0x9b, 0x8f, 0x2b, 0x3c, 0x3c, 0x8c, 0xfd, 0x89, 0x1f, 0xb8, 0x69,
	0x92, 0xe0, 0x1c, 0xc3, 0x47, 0xdb, 0x0b, 0x49, 0xae, 0xe2, 0x25, 0xc3, 0xc7, 0xd2, 0xf8, 0x21,
	0xd8, 0xe9, 0x9b, 0x2d, 0x6b, 0x04, 0x39, 0x6a, 0x04, 0xf5, 0x04, 0xcf, 0xba, 0xc1, 0x21, 0x94,
	0xb3, 0x28, 0x75, 0x3b, 0x49, 0xa7, 0xdf, 0x84, 0xd0, 0x33, 0x81, 0x48, 0xc6, 0x61, 0x89, 0xd3,
	0x9a, 0x9d, 0x40, 0x05, 0xa7, 0xcf, 0x54, 0xa8, 0xa9, 0x3b, 0xf3, 0x35, 0xf9, 0x04, 0x27, 0x30,
	0xea, 0xf3, 0x5c, 0xa8, 0xe9, 0x0b, 0x5f, 0x77, 0x3b, 0x1c, 0x67, 0x74, 0x42, 0x61, 0x7c, 0xe8,
	0x85, 0x20, 0x56, 0xae, 0xf2, 0xdf, 0xca, 0x24, 0xe9, 0x50, 0xe2, 0x4c, 0xac, 0x06, 0xfe, 0x5b,
	0x89, 0x63, 0xf2, 0x32, 0x91, 0x30, 0x5b, 0x14, 0xa5, 0x60, 0x85, 0xd7, 0x32, 0xb8, 0x8d, 0x28,
	0x5a, 0x37, 0x91, 0x81, 0x54, 0x7e, 0x16, 0x13, 0xd5, 0x28, 0xd1, 0xe8, 0xaa, 0x27, 0x78, 0x12,
	0x11, 0xd5, 0xfc, 0x6f, 0x1e, 0x6a, 0xed, 0xf7, 0x92, 0xf0, 0xeb, 0x06, 0x5b, 0x57, 0x0d, 0xa6,
	0x97, 0x40, 0xaa, 0x08, 0x99, 0x6e, 0x7c, 0x57, 0xcd, 0xd0, 0x1e, 0xfa, 0xe0, 0x17, 0xc0, 0x94,
	0x3f, 0x09, 0xfc, 0x60, 0xe2, 0x7a, 0x58, 0x09, 0x21, 0x79, 0x22, 0x9f, 0x94, 0x2a, 0x7a, 0x82,
	0x0a, 0x24, 0x34, 0xbe, 0xb0, 0x13, 0xd9, 0x0c, 0xc3, 0xd4, 0x9e, 0xc9, 0xb5, 0x79, 0x2e, 0x6d,
	0x7d, 0x20, 0x9e, 0x85, 0x99, 0x59, 0xbc, 0x37, 0x77, 0xb6, 0x3f, 0x36, 0x77, 0x76, 0x3e, 0x30,
	0x77, 0xbe, 0x80, 0x9a, 0xa9, 0x8d, 0x2c, 0x5e, 0x85, 0x0f, 0xc6, 0xcb, 0x54, 0x50, 0x1a, 0xb1,
	0x1f, 0x01, 0xc3, 0x68, 0x2d, 0xe4, 0x62, 0x24, 0x63, 0x77, 0x2e, 0xb4, 0x0c, 0xbc, 0x35, 0x85,
	0x24, 0xcf, 0xed, 0x85, 0x58, 0x9d, 0x11, 0xe3, 0xd4, 0xe0, 0xec, 0x31, 0xdc, 0xd8, 0x90, 0xf6,
	0x30, 0xdf, 0xdd, 0xb1, 0x9c, 0x6b, 0x41, 0xf3, 0x20, 0xcf, 0xaf, 0x67, 0x3b, 0xda, 0xc8, 0xeb,
	0x20, 0x8b, 0x1d, 0xc3, 0x2e, 0x6e, 0x32, 0xca, 0xa5, 0x37, 0xc0, 0x61, 0xfe, 0x28, 0xcf, 0xeb,
	0x0b, 0xb1, 0xa2, 0x30, 0xa6, 0x17, 0x1c, 0xc2, 0xf6, 0xdc, 0x0f, 0x66, 0xaa, 0xb1, 0x47, 0x5d,
	0x17, 0x4c, 0x61, 0x9d, 0xfa, 0xc1, 0x8c, 0x1b, 0x46, 0xf3, 0x7f, 0x39, 0x28, 0x9b, 0x2b, 0x3e,
	0x3e, 0xaf, 0x0f, 0xa0, 0x68, 0x54, 0x4d, 0x46, 0x75, 0x95, 0x67, 0x34, 0x36, 0x29, 0xf3, 0xe2,
	0xc6, 0x47, 0x99, 0x1c, 0x93, 0xcf, 0xf3, 0x9c, 0x5e, 0xe1, 0x03, 0x03, 0xe1, 0x93, 0x49, 0xcc,
	0x7d, 0xa1, 0xc8, 0xdd, 0x25, 0x6e, 0x08, 0x76, 0x17, 0xea, 0x38, 0xaa, 0xd2, 0xac, 0xc0, 0x42,
	0x2d, 0x98, 0xc7, 0x61, 0xb4, 0x1c, 0x0d, 0x0c, 0xfa, 0x82, 0xfa, 0x3a, 0xc9, 0xc9, 0x80, 0xf2,
	0x86, 0xe4, 0x8a, 0x99, 0x9c, 0x63, 0xd0, 0xab, 0x13, 0xae, 0xf4, 0xf1, 0x86, 0x32, 0x0a, 0x97,
	0x9a, 0x4a, 0x27, 0x6b, 0x28, 0x88, 0x60, 0xd5, 0xe0, 0xf7, 0xc7, 0x34, 0x5c, 0x48, 0xc3, 0x35,
	0x9f, 0x05, 0x45, 0x04, 0xda, 0x49, 0x5b, 0xf6, 0xc2, 0x40, 0x0b, 0x2f, 0xd9, 0x7d, 0x23, 0x2d,
	0x0a, 0xc2, 0x48, 0xe4, 0x16, 0x40, 0x12, 0x5b, 0x7c, 0x3c, 0xdc, 0x34, 0xc7, 0x1b, 0xa4, 0xd5,
	0x6e, 0x1f, 0xaf, 0xa0, 0x94, 0xbd, 0xbc, 0xd9, 0x75, 0xa8, 0xb7, 0xde, 0xb4, 0xba, 0xc3, 0x6e,
	0xef, 0x99, 0xdb, 0xee, 0x9f, 0x9d, 0x75, 0x87, 0xf6, 0x35, 0x56, 0x03, 0x30, 0x6b, 0x84, 0xed,
	0x1c, 0x2b, 0xc2, 0xd6, 0x69, 0x7f, 0x30, 0xb4, 0xb7, 0xd9, 0x2e, 0x54, 0x0d, 0xc7, 0x7d, 0xda,
	0xea, 0x9e, 0x3a, 0x1d, 0xbb, 0xc0, 0xaa, 0x50, 0x4a, 0x84, 0x9d, 0x8e, 0x5d, 0x64, 0x65, 0x28,
	0x70, 0xe7, 0x75, 0xff, 0x85, 0xd3, 0xb1, 0x4b, 0xc8, 0x7b, 0xda, 0xed, 0xb5, 0x4e, 0xbb, 0xbf,
	0x76, 0x3a, 0xb6, 0x7d, 0xfc, 0x07, 0x2b, 0x7d, 0x07, 0x9a, 0x29, 0x5d, 0x85, 0x52, 0xaf, 0x8f,
	0x4a, 0x3a, 0x83, 0x81, 0x7d, 0x8d, 0xd5, 0xa1, 0xcc, 0x9d, 0x56, 0x27, 0x05, 0x2c, 0xb6, 0x07,
	0x36, 0x02, 0x6f, 0x78, 0x77, 0xe8, 0xa4, 0x68, 0x0e, 0xd1, 0xb3, 0x7e, 0xc7, 0xe1, 0xad, 0x61,
	0x9f, 0xa7, 0x68, 0x9e, 0x1d, 0xc0, 0x8d, 0xc1, 0xab, 0x97, 0x0e, 0x77, 0xaf, 0xf0, 0xb6, 0x98,
	0x0d, 0x95, 0x56, 0xe7, 0xac, 0xdb, 0x4b, 0x91, 0xed, 0xe3, 0x3f, 0x5a, 0x50, 0x48, 0xe6, 0x12,
	0x72, 0x5f, 0xf6, 0x07, 0x43, 0xb7, 0xdd, 0xef, 0x0d, 0x9d, 0x1e, 0xda, 0xcf, 0xa0, 0xc6, 0x9d,
	0xb3, 0xfe, 0x6b, 0xc7, 0x75, 0x7a, 0x43, 0xde, 0x75, 0x50, 0x97, 0xeb, 0x50, 0xa7, 0xf3, 0x07,
	0x4e, 0xc7, 0xc0, 0xbf, 0xb2, 0x73, 0x6c, 0x1f, 0x76, 0x9d, 0x4e, 0x77, 0xe8, 0xb6, 0x9f, 0xb7,
	0x7a, 0x3d, 0xe7, 0xd4, 0xed, 0xf6, 0x9e, 0xf6, 0xed, 0x3c, 0xc2, 0x3d, 0xe7, 0x4d, 0x86, 0x3a,
	0x2f, 0xfb, 0xed, 0xe7, 0xf6, 0x16, 0xbb, 0x01, 0x8c, 0xa4, 0x8d, 0x16, 0xee, 0x33, 0xde, 0xea,
	0x0d, 0x07, 0xf6, 0xce, 0xf1, 0x0d, 0xa8, 0x90, 0x2e, 0xaf, 0x65, 0x8c, 0xf9, 0xc1, 0x76, 0x20,
	0xf7, 0xfa, 0xc4, 0xbe, 0x76, 0x7c, 0x0e, 0x45, 0xc2, 0xb1, 0x08, 0xca, 0x89, 0xbe, 0xdd, 0x8e,
	0x7d, 0x0d, 0xa3, 0xd0, 0xa2, 0xf1, 0x93, 0x42, 0x16, 0xbb, 0x09, 0xd7, 0x37, 0x9f, 0x35, 0x29,
	0x23, 0x87, 0xb1, 0xc4, 0xfb, 0x12, 0x3a, 0x8f, 0x7b, 0x7b, 0x61, 0xbc, 0x10, 0xf3, 0xde, 0x72,
	0x81, 0x93, 0xd3, 0xde, 0x3a, 0x1e, 0x40, 0xb5, 0xbd, 0xd9, 0xb6, 0x29, 0x86, 0x61, 0xa8, 0x5b,
	0xed, 0xb6, 0x71, 0x86, 0xa9, 0x54, 0x2e, 0x27, 0xbe, 0xd2, 0xf1, 0xda, 0xb6, 0xd0, 0x65, 0x74,
	0xcd, 0x73, 0x1f, 0x67, 0xd4, 0xda, 0xce, 0x61, 0xec, 0x7a, 0xcb, 0x45, 0xa2, 0x82, 0xb2, 0xf3,
	0x8f, 0xfe, 0x66, 0x41, 0x7d, 0x90, 0x0d, 0xb0, 0x0b, 0x7f, 0x2c, 0x63, 0xf6, 0x39, 0x0e, 0x4a,
	0x11, 0xeb, 0xe4, 0x27, 0x0b, 0x56, 0x37, 0x3f, 0x4c, 0x64, 0x3f, 0x60, 0x1c, 0xd8, 0x9b, 0xbf,
	0x54, 0x50, 0x43, 0xfd, 0x3e, 0x6c, 0xd1, 0x87, 0x59, 0x25, 0xfb, 0x62, 0xf4, 0x44, 0x70, 0x90,
	0x51, 0xf8, 0x51, 0x74, 0x62, 0xb1, 0x23, 0x28, 0x3d, 0x95, 0xda, 0x9b, 0xe2, 0xe7, 0x12, 0x7b,
	0x8f, 0x79, 0xb0, 0xf9, 0x13, 0xc6, 0x89, 0xc5, 0xee, 0x42, 0x09, 0x6d, 0xf5, 0x35, 0x7e, 0x1e,
	0x6f, 0xf2, 0x0e, 0xde, 0xfb, 0xd2, 0x7c, 0x62, 0xff, 0xf3, 0xdd, 0x6d, 0xeb, 0x5f, 0xef, 0x6e,
	0x5b, 0xff, 0x7e, 0x77, 0xdb, 0xfa, 0xd3, 0x7f, 0x6e, 0x5f, 0x1b, 0xed, 0xd0, 0x78, 0x7e, 0xfc,
	0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe1, 0x48, 0x9b, 0x26, 0xe3, 0x11, 0x00, 0x00,
}
