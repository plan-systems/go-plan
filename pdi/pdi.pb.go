// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pdi.proto

/*
	Package pdi is a generated protocol buffer package.

	It is generated from these files:
		pdi.proto

	It has these top-level messages:
		MemberEpoch
		AccessGrant
		ChannelEpoch
		ChannelInfo
		ChannelList
		Entry
		EntryCrypt
		EntryHeader
		StorageTxn
*/
package pdi

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import plan "github.com/plan-tools/go-plan/plan"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ChannelAccess int32

const (
	// Not used
	ChannelAccess_NO_ACCESS ChannelAccess = 0
	// Has crypto to decrypt entries from the given channel
	ChannelAccess_READ_ACCESS ChannelAccess = 1
	// Permitted to author: POST_NEW_CONTENT, REMOVE_ENTRIES (for self), SUPERCEDE_ENTRY (for self)
	ChannelAccess_READWRITE_ACCESS ChannelAccess = 2
	// Permitted to author: POST_NEW_CONTENT, REMOVE_ENTRIES (for all), SUPERCEDE_ENTRY (for all), EDIT_CHANNEL_INFO, EDIT_ACCESS_GRANTS
	ChannelAccess_MODERATOR_ACCESS ChannelAccess = 3
	// Same as MODERATOR_ACCESS plus can grant others MODERATOR_ACCESS and can issue EDIT_ACCESS_GRANTS
	ChannelAccess_SUPER_MODERATOR_ACCESS ChannelAccess = 4
	// Same as SUPER_MODERATOR_ACCESS plus can grant others SUPER_MODERATOR_ACCESS and can author entry type NEW_CHANNEL_EPOCH
	ChannelAccess_ADMIN_ACCESS ChannelAccess = 5
)

var ChannelAccess_name = map[int32]string{
	0: "NO_ACCESS",
	1: "READ_ACCESS",
	2: "READWRITE_ACCESS",
	3: "MODERATOR_ACCESS",
	4: "SUPER_MODERATOR_ACCESS",
	5: "ADMIN_ACCESS",
}
var ChannelAccess_value = map[string]int32{
	"NO_ACCESS":              0,
	"READ_ACCESS":            1,
	"READWRITE_ACCESS":       2,
	"MODERATOR_ACCESS":       3,
	"SUPER_MODERATOR_ACCESS": 4,
	"ADMIN_ACCESS":           5,
}

func (x ChannelAccess) String() string {
	return proto.EnumName(ChannelAccess_name, int32(x))
}
func (ChannelAccess) EnumDescriptor() ([]byte, []int) { return fileDescriptorPdi, []int{0} }

type EntryOp int32

const (
	// Appends this content entry to the specified channel.
	EntryOp_POST_NEW_CONTENT EntryOp = 0
	// This entry's body lists one or more channel entries to effectively mark as removed/invisible.
	EntryOp_REMOVE_ENTRIES EntryOp = 1
	// This entry's body should effectively replace a specified previous entry
	EntryOp_SUPERCEDE_ENTRY EntryOp = 2
	//  - This entry modifies one or more of a given channel's meta fields (e.g. channel description, icon, etc).
	// - A ChannelInfo snapshot/composite can be reconstructed by sequentially applying every EDIT_CHANNEL_INFO
	// change to the previous ChannelInfo composite up to the present time.
	// - Only channel admins or moderators are permitted to originate this op.
	EntryOp_EDIT_CHANNEL_INFO EntryOp = 3
	// This entry initiates a new channel epoch, inserting one or more changes to the channel's current ChannelEpoch.
	// This op is mostly issued to access channels since a new epoch is only needed in order to rekey a private access channel.
	// Only channel admins are permitted to originate this op.
	EntryOp_NEW_CHANNEL_EPOCH EntryOp = 4
	// Adds or removes access to given member IDs or wildcards.  Notes:
	//   - This entry type is only valid for use channels that are access control channels.
	//   - Members with MODERATOR_ACCESS can only grant/revoke READ_ACCESS and READWRITE_ACCESS.
	//   - Members with ADMIN_ACCESS can grant/revoke up to and including SUPER_MODERATOR_ACCESS.
	//   - ADMIN_ACCESS can ONLY be granted by members with ADMIN_ACCESS in the parent access control channel.
	//   - In some cases, this entry type MAY result a new channel epoch to be initiated (this is because
	//     a private channel must issue and distribute a new channel encryption key in order to effectively
	//     remove access to members that are longer have channel access).
	EntryOp_EDIT_ACCESS_GRANTS EntryOp = 5
)

var EntryOp_name = map[int32]string{
	0: "POST_NEW_CONTENT",
	1: "REMOVE_ENTRIES",
	2: "SUPERCEDE_ENTRY",
	3: "EDIT_CHANNEL_INFO",
	4: "NEW_CHANNEL_EPOCH",
	5: "EDIT_ACCESS_GRANTS",
}
var EntryOp_value = map[string]int32{
	"POST_NEW_CONTENT":   0,
	"REMOVE_ENTRIES":     1,
	"SUPERCEDE_ENTRY":    2,
	"EDIT_CHANNEL_INFO":  3,
	"NEW_CHANNEL_EPOCH":  4,
	"EDIT_ACCESS_GRANTS": 5,
}

func (x EntryOp) String() string {
	return proto.EnumName(EntryOp_name, int32(x))
}
func (EntryOp) EnumDescriptor() ([]byte, []int) { return fileDescriptorPdi, []int{1} }

type EntryVersion int32

const (
	EntryVersion_V0 EntryVersion = 0
)

var EntryVersion_name = map[int32]string{
	0: "V0",
}
var EntryVersion_value = map[string]int32{
	"V0": 0,
}

func (x EntryVersion) String() string {
	return proto.EnumName(EntryVersion_name, int32(x))
}
func (EntryVersion) EnumDescriptor() ([]byte, []int) { return fileDescriptorPdi, []int{2} }

// TxnStatus describes how far along a StorageTxn is on being stored on a PDI StorageProvider.
// Note: odd values reflect an error state
type TxnStatus int32

const (
	// The txn is yet to be committed to storage
	TxnStatus_AWAITING_COMMIT TxnStatus = 0
	// The txn has been committed and is in the process of being stored
	TxnStatus_COMMITTING TxnStatus = 2
	// The txn is yet to be committed to storage
	TxnStatus_INVALID_TXN TxnStatus = 3
	// This txn was lost or is otherwise not available
	TxnStatus_LOST TxnStatus = 5
	// This txn has failed to commit because of an error (or the storage provider rejected it for some reason)
	TxnStatus_FAILED_TO_COMMIT TxnStatus = 7
	// The txn has been committed and has been confirmed as stored (but could still potentially be reverted)
	TxnStatus_COMMITTED TxnStatus = 8
	// The txn was confirmed COMMITTED earlier in time, but has since been revoked (and is in an equiivalent state to AWAITING_COMMIT)
	TxnStatus_REVOKED TxnStatus = 9
	// The txn has been committed, confirmed as stored, and faces no possibility of being reverted.
	TxnStatus_FINALIZED TxnStatus = 16
)

var TxnStatus_name = map[int32]string{
	0:  "AWAITING_COMMIT",
	2:  "COMMITTING",
	3:  "INVALID_TXN",
	5:  "LOST",
	7:  "FAILED_TO_COMMIT",
	8:  "COMMITTED",
	9:  "REVOKED",
	16: "FINALIZED",
}
var TxnStatus_value = map[string]int32{
	"AWAITING_COMMIT":  0,
	"COMMITTING":       2,
	"INVALID_TXN":      3,
	"LOST":             5,
	"FAILED_TO_COMMIT": 7,
	"COMMITTED":        8,
	"REVOKED":          9,
	"FINALIZED":        16,
}

func (x TxnStatus) String() string {
	return proto.EnumName(TxnStatus_name, int32(x))
}
func (TxnStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorPdi, []int{3} }

// /plan/community/member/epoch
type MemberEpoch struct {
	// Random "name" for this member epoch -- must be unique for a member's epoch history (and not 0).
	EpochId uint64 `protobuf:"fixed64,1,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	// Names the previous epoch.  Set to 0 if there was no previous epoch.
	PrevEpochId uint64 `protobuf:"fixed64,2,opt,name=prev_epoch_id,json=prevEpochId,proto3" json:"prev_epoch_id,omitempty"`
	// Unix timestamp when this epoch entered into effect
	TimeStarted int64 `protobuf:"varint,3,opt,name=time_started,json=timeStarted,proto3" json:"time_started,omitempty"`
	// Specifies a UTF8 textual label that this member chooses to appear as in the community.
	Alias string `protobuf:"bytes,4,opt,name=alias,proto3" json:"alias,omitempty"`
	// Public keys associated with the given revision
	PubSigningKey []byte `protobuf:"bytes,5,opt,name=pub_signing_key,json=pubSigningKey,proto3" json:"pub_signing_key,omitempty"`
	PubCryptoKey  []byte `protobuf:"bytes,6,opt,name=pub_crypto_key,json=pubCryptoKey,proto3" json:"pub_crypto_key,omitempty"`
	// The ChannelID of this member's "about" channel
	AboutChannelId []byte `protobuf:"bytes,7,opt,name=about_channel_id,json=aboutChannelId,proto3" json:"about_channel_id,omitempty"`
	// The ChannelID of this member's home channel -- where visitors should first go
	HomeChannelId []byte `protobuf:"bytes,8,opt,name=home_channel_id,json=homeChannelId,proto3" json:"home_channel_id,omitempty"`
	// Future-proofing
	Extensions *plan.Block `protobuf:"bytes,9,opt,name=extensions" json:"extensions,omitempty"`
}

func (m *MemberEpoch) Reset()                    { *m = MemberEpoch{} }
func (m *MemberEpoch) String() string            { return proto.CompactTextString(m) }
func (*MemberEpoch) ProtoMessage()               {}
func (*MemberEpoch) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{0} }

func (m *MemberEpoch) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

func (m *MemberEpoch) GetPrevEpochId() uint64 {
	if m != nil {
		return m.PrevEpochId
	}
	return 0
}

func (m *MemberEpoch) GetTimeStarted() int64 {
	if m != nil {
		return m.TimeStarted
	}
	return 0
}

func (m *MemberEpoch) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *MemberEpoch) GetPubSigningKey() []byte {
	if m != nil {
		return m.PubSigningKey
	}
	return nil
}

func (m *MemberEpoch) GetPubCryptoKey() []byte {
	if m != nil {
		return m.PubCryptoKey
	}
	return nil
}

func (m *MemberEpoch) GetAboutChannelId() []byte {
	if m != nil {
		return m.AboutChannelId
	}
	return nil
}

func (m *MemberEpoch) GetHomeChannelId() []byte {
	if m != nil {
		return m.HomeChannelId
	}
	return nil
}

func (m *MemberEpoch) GetExtensions() *plan.Block {
	if m != nil {
		return m.Extensions
	}
	return nil
}

type AccessGrant struct {
	// Specifies an access level granted to the liven list of grantees. If a pnode sees an access grant given by a member who does
	// not have permission to do so, the entry will be rejected.
	AccessGrant ChannelAccess `protobuf:"varint,1,opt,name=access_grant,json=accessGrant,proto3,enum=pdi.ChannelAccess" json:"access_grant,omitempty"`
	// This is a list of community member IDs being given the specified access grant.
	// Note: if grantees[0] == "*" AND access_grant <= MODERATOR_ACCESS, then the grant implicitly applies to ALL community members.
	Grantees [][]byte `protobuf:"bytes,2,rep,name=grantees" json:"grantees,omitempty"`
}

func (m *AccessGrant) Reset()                    { *m = AccessGrant{} }
func (m *AccessGrant) String() string            { return proto.CompactTextString(m) }
func (*AccessGrant) ProtoMessage()               {}
func (*AccessGrant) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{1} }

func (m *AccessGrant) GetAccessGrant() ChannelAccess {
	if m != nil {
		return m.AccessGrant
	}
	return ChannelAccess_NO_ACCESS
}

func (m *AccessGrant) GetGrantees() [][]byte {
	if m != nil {
		return m.Grantees
	}
	return nil
}

//
// ChannelEpoch contains critical and security-related properties about a channel and is king while in effect.
// Other than access grants given or taken away, a ChannelEpoch is immutable and only a NEW_CHANNEL_EPOCH op can change things.
type ChannelEpoch struct {
	// Random "name" for this channel epoch -- must be unique for a channel's epoch history (and not 0).
	EpochId uint64 `protobuf:"fixed64,1,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	// Unix timestamp when this epoch entered into effect
	TimeStarted int64 `protobuf:"varint,2,opt,name=time_started,json=timeStarted,proto3" json:"time_started,omitempty"`
	// Names the previous epoch.  0 if there was no previous epoch.
	PrevEpochId uint64 `protobuf:"fixed64,3,opt,name=prev_epoch_id,json=prevEpochId,proto3" json:"prev_epoch_id,omitempty"`
	// Number of seconds the previous epoch can alternatively be used in place of this epoch.
	EpochTransitionPeriod int32 `protobuf:"varint,4,opt,name=epoch_transition_period,json=epochTransitionPeriod,proto3" json:"epoch_transition_period,omitempty"`
	//  Top-level string describing how entries on this channel are expected to conform.
	// This allows a PLAN client to invoke the appropriate UI and data handlers.
	// e.g.
	// /plan/channel-protocol/talk/2
	// /plan/channel-protocol/inventory/1
	// /plan/channel-protocol/cryptokitty/browser
	Protocol string `protobuf:"bytes,5,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Specifies the channel that is serving as this channel's access control channel (and has entries that conform to that spec)
	AccessChannelId []byte `protobuf:"bytes,6,opt,name=access_channel_id,json=accessChannelId,proto3" json:"access_channel_id,omitempty"`
	// If set, channel entries are not allowed to be removed/superceded.
	EntriesAreLocked bool `protobuf:"varint,7,opt,name=entries_are_locked,json=entriesAreLocked,proto3" json:"entries_are_locked,omitempty"`
	// If set, entries_are_locked must/will always be true.
	EntriesAreLockedForever bool `protobuf:"varint,8,opt,name=entries_are_locked_forever,json=entriesAreLockedForever,proto3" json:"entries_are_locked_forever,omitempty"`
	// If set, pnodes with web services running will attempt to share this channel to outside the community
	IsExternallyShared bool `protobuf:"varint,9,opt,name=is_externally_shared,json=isExternallyShared,proto3" json:"is_externally_shared,omitempty"`
	//  If set, this channel can be used to validate EntryOps applied to other channels (including other access channels).
	// Entries in an access channel conform to a specific protocol and serve to:
	// (a) allow one or more other channels to cite this channel as their access control (access_channel_id)
	// (a) transport private channel keys and grants to community members that have been given access to this channel (by encrypting a channel's key using a member's public key)
	// (b) publish and transfer write-access and ownership permissions to others (only permitted by owners)
	IsAccessChannel bool `protobuf:"varint,10,opt,name=is_access_channel,json=isAccessChannel,proto3" json:"is_access_channel,omitempty"`
	// Contains all the access grants published via EDIT_ACCESS_GRANTS sent to this channel (during this epoch).
	// If this channel is NOT an access channel (is_access_channel == false), then this field == nil
	AccessGrants []*AccessGrant `protobuf:"bytes,11,rep,name=access_grants,json=accessGrants" json:"access_grants,omitempty"`
	// Future-proofing
	Extensions *plan.Block `protobuf:"bytes,12,opt,name=extensions" json:"extensions,omitempty"`
}

func (m *ChannelEpoch) Reset()                    { *m = ChannelEpoch{} }
func (m *ChannelEpoch) String() string            { return proto.CompactTextString(m) }
func (*ChannelEpoch) ProtoMessage()               {}
func (*ChannelEpoch) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{2} }

func (m *ChannelEpoch) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

func (m *ChannelEpoch) GetTimeStarted() int64 {
	if m != nil {
		return m.TimeStarted
	}
	return 0
}

func (m *ChannelEpoch) GetPrevEpochId() uint64 {
	if m != nil {
		return m.PrevEpochId
	}
	return 0
}

func (m *ChannelEpoch) GetEpochTransitionPeriod() int32 {
	if m != nil {
		return m.EpochTransitionPeriod
	}
	return 0
}

func (m *ChannelEpoch) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *ChannelEpoch) GetAccessChannelId() []byte {
	if m != nil {
		return m.AccessChannelId
	}
	return nil
}

func (m *ChannelEpoch) GetEntriesAreLocked() bool {
	if m != nil {
		return m.EntriesAreLocked
	}
	return false
}

func (m *ChannelEpoch) GetEntriesAreLockedForever() bool {
	if m != nil {
		return m.EntriesAreLockedForever
	}
	return false
}

func (m *ChannelEpoch) GetIsExternallyShared() bool {
	if m != nil {
		return m.IsExternallyShared
	}
	return false
}

func (m *ChannelEpoch) GetIsAccessChannel() bool {
	if m != nil {
		return m.IsAccessChannel
	}
	return false
}

func (m *ChannelEpoch) GetAccessGrants() []*AccessGrant {
	if m != nil {
		return m.AccessGrants
	}
	return nil
}

func (m *ChannelEpoch) GetExtensions() *plan.Block {
	if m != nil {
		return m.Extensions
	}
	return nil
}

type ChannelInfo struct {
	// This channel ID (immutable)
	ChannelId []byte `protobuf:"bytes,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	// Container for all content-level properties (e.g. channel title, description, etc)
	InfoRev uint32      `protobuf:"varint,7,opt,name=info_rev,json=infoRev,proto3" json:"info_rev,omitempty"`
	Info    *plan.Block `protobuf:"bytes,8,opt,name=info" json:"info,omitempty"`
}

func (m *ChannelInfo) Reset()                    { *m = ChannelInfo{} }
func (m *ChannelInfo) String() string            { return proto.CompactTextString(m) }
func (*ChannelInfo) ProtoMessage()               {}
func (*ChannelInfo) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{3} }

func (m *ChannelInfo) GetChannelId() []byte {
	if m != nil {
		return m.ChannelId
	}
	return nil
}

func (m *ChannelInfo) GetInfoRev() uint32 {
	if m != nil {
		return m.InfoRev
	}
	return 0
}

func (m *ChannelInfo) GetInfo() *plan.Block {
	if m != nil {
		return m.Info
	}
	return nil
}

type ChannelList struct {
	Channels []*ChannelInfo `protobuf:"bytes,1,rep,name=channels" json:"channels,omitempty"`
}

func (m *ChannelList) Reset()                    { *m = ChannelList{} }
func (m *ChannelList) String() string            { return proto.CompactTextString(m) }
func (*ChannelList) ProtoMessage()               {}
func (*ChannelList) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{4} }

func (m *ChannelList) GetChannels() []*ChannelInfo {
	if m != nil {
		return m.Channels
	}
	return nil
}

// Entry is a convenience container for the pieces/parts that a PDI entry may be at during processing or transmission.
type Entry struct {
	Crypt  *EntryCrypt  `protobuf:"bytes,1,opt,name=crypt" json:"crypt,omitempty"`
	Header *EntryHeader `protobuf:"bytes,2,opt,name=header" json:"header,omitempty"`
	Body   *plan.Block  `protobuf:"bytes,3,opt,name=body" json:"body,omitempty"`
}

func (m *Entry) Reset()                    { *m = Entry{} }
func (m *Entry) String() string            { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()               {}
func (*Entry) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{5} }

func (m *Entry) GetCrypt() *EntryCrypt {
	if m != nil {
		return m.Crypt
	}
	return nil
}

func (m *Entry) GetHeader() *EntryHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Entry) GetBody() *plan.Block {
	if m != nil {
		return m.Body
	}
	return nil
}

//
// EntryCrypt is the "wire" format for PLAN's Persistent Data Interface (PDI) entries.  It contains no revealing information and
// is what's sent to/from community data store replicators, such as NEM, DFINITY, and Ethereum.
type EntryCrypt struct {
	CryptInfo      uint64 `protobuf:"varint,1,opt,name=crypt_info,json=cryptInfo,proto3" json:"crypt_info,omitempty"`
	CommunityKeyId []byte `protobuf:"bytes,3,opt,name=community_key_id,json=communityKeyId,proto3" json:"community_key_id,omitempty"`
	HeaderCrypt    []byte `protobuf:"bytes,5,opt,name=header_crypt,json=headerCrypt,proto3" json:"header_crypt,omitempty"`
	BodyCrypt      []byte `protobuf:"bytes,6,opt,name=body_crypt,json=bodyCrypt,proto3" json:"body_crypt,omitempty"`
	Sig            []byte `protobuf:"bytes,7,opt,name=sig,proto3" json:"sig,omitempty"`
}

func (m *EntryCrypt) Reset()                    { *m = EntryCrypt{} }
func (m *EntryCrypt) String() string            { return proto.CompactTextString(m) }
func (*EntryCrypt) ProtoMessage()               {}
func (*EntryCrypt) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{6} }

func (m *EntryCrypt) GetCryptInfo() uint64 {
	if m != nil {
		return m.CryptInfo
	}
	return 0
}

func (m *EntryCrypt) GetCommunityKeyId() []byte {
	if m != nil {
		return m.CommunityKeyId
	}
	return nil
}

func (m *EntryCrypt) GetHeaderCrypt() []byte {
	if m != nil {
		return m.HeaderCrypt
	}
	return nil
}

func (m *EntryCrypt) GetBodyCrypt() []byte {
	if m != nil {
		return m.BodyCrypt
	}
	return nil
}

func (m *EntryCrypt) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

//
// An encrypted PDI entry has two segments, its header and "body" (content) block.  The header, EntryHeader, is "community-private",
// meaning that it is encrypted using one of the community's shared symmetric keys.  The entry's body is either also community-private
// (encrypted with the same community key as EntryHeader), or it is encrypted using the key referenced by body_key_id.
//
// When a entry is authored, it is intended to be posted to the channel specified by EntryHeader.channel_id.  The current rev of that
// channel is also listed so that pdi nodes know which channel access rev to use when checking permissions.
type EntryHeader struct {
	TimeAuthored      int64       `protobuf:"varint,1,opt,name=time_authored,json=timeAuthored,proto3" json:"time_authored,omitempty"`
	TimeAuthoredNs    uint32      `protobuf:"fixed32,2,opt,name=time_authored_ns,json=timeAuthoredNs,proto3" json:"time_authored_ns,omitempty"`
	TimeSealed        int64       `protobuf:"varint,3,opt,name=time_sealed,json=timeSealed,proto3" json:"time_sealed,omitempty"`
	EntryOp           EntryOp     `protobuf:"varint,4,opt,name=entry_op,json=entryOp,proto3,enum=pdi.EntryOp" json:"entry_op,omitempty"`
	ChannelId         []byte      `protobuf:"bytes,5,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	ChannelEpochId    uint64      `protobuf:"fixed64,6,opt,name=channel_epoch_id,json=channelEpochId,proto3" json:"channel_epoch_id,omitempty"`
	AuthorMemberId    []byte      `protobuf:"bytes,7,opt,name=author_member_id,json=authorMemberId,proto3" json:"author_member_id,omitempty"`
	AuthorMemberEpoch uint64      `protobuf:"fixed64,8,opt,name=author_member_epoch,json=authorMemberEpoch,proto3" json:"author_member_epoch,omitempty"`
	BodyKeyId         []byte      `protobuf:"bytes,10,opt,name=body_key_id,json=bodyKeyId,proto3" json:"body_key_id,omitempty"`
	Extensions        *plan.Block `protobuf:"bytes,11,opt,name=extensions" json:"extensions,omitempty"`
}

func (m *EntryHeader) Reset()                    { *m = EntryHeader{} }
func (m *EntryHeader) String() string            { return proto.CompactTextString(m) }
func (*EntryHeader) ProtoMessage()               {}
func (*EntryHeader) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{7} }

func (m *EntryHeader) GetTimeAuthored() int64 {
	if m != nil {
		return m.TimeAuthored
	}
	return 0
}

func (m *EntryHeader) GetTimeAuthoredNs() uint32 {
	if m != nil {
		return m.TimeAuthoredNs
	}
	return 0
}

func (m *EntryHeader) GetTimeSealed() int64 {
	if m != nil {
		return m.TimeSealed
	}
	return 0
}

func (m *EntryHeader) GetEntryOp() EntryOp {
	if m != nil {
		return m.EntryOp
	}
	return EntryOp_POST_NEW_CONTENT
}

func (m *EntryHeader) GetChannelId() []byte {
	if m != nil {
		return m.ChannelId
	}
	return nil
}

func (m *EntryHeader) GetChannelEpochId() uint64 {
	if m != nil {
		return m.ChannelEpochId
	}
	return 0
}

func (m *EntryHeader) GetAuthorMemberId() []byte {
	if m != nil {
		return m.AuthorMemberId
	}
	return nil
}

func (m *EntryHeader) GetAuthorMemberEpoch() uint64 {
	if m != nil {
		return m.AuthorMemberEpoch
	}
	return 0
}

func (m *EntryHeader) GetBodyKeyId() []byte {
	if m != nil {
		return m.BodyKeyId
	}
	return nil
}

func (m *EntryHeader) GetExtensions() *plan.Block {
	if m != nil {
		return m.Extensions
	}
	return nil
}

type StorageTxn struct {
	// Issued by the storage layer (not storage clients) some time after StorageSession.Commit()
	// Since a StorageProvier creates/assigns txn names, they can be any length (typically 8 to 32 bytes),
	//    but the length is *never* changes when a StorageProvier inits a new repo.
	TxnName []byte `protobuf:"bytes,1,opt,name=txn_name,json=txnName,proto3" json:"txn_name,omitempty"`
	// Unix timestamp of when this txn was committed for storage (0 if not committed)
	TimeCommitted int64 `protobuf:"varint,2,opt,name=time_committed,json=timeCommitted,proto3" json:"time_committed,omitempty"`
	// Consensus-based unix timestamp for this txn (or 0 if not available).
	// If txn_status == FINALIZED, then this timestamp:
	//      - won't ever change,
	//      - is universal across storage peers
	//      - is trustworthy
	TimeConsensus int64 `protobuf:"varint,3,opt,name=time_consensus,json=timeConsensus,proto3" json:"time_consensus,omitempty"`
	// Describes the state of this txn segment number
	TxnStatus TxnStatus `protobuf:"varint,4,opt,name=txn_status,json=txnStatus,proto3,enum=pdi.TxnStatus" json:"txn_status,omitempty"`
	// Txn payload (in PLAN, one or more serialized pdi.EntryCrypt)
	Body *plan.Block `protobuf:"bytes,5,opt,name=body" json:"body,omitempty"`
}

func (m *StorageTxn) Reset()                    { *m = StorageTxn{} }
func (m *StorageTxn) String() string            { return proto.CompactTextString(m) }
func (*StorageTxn) ProtoMessage()               {}
func (*StorageTxn) Descriptor() ([]byte, []int) { return fileDescriptorPdi, []int{8} }

func (m *StorageTxn) GetTxnName() []byte {
	if m != nil {
		return m.TxnName
	}
	return nil
}

func (m *StorageTxn) GetTimeCommitted() int64 {
	if m != nil {
		return m.TimeCommitted
	}
	return 0
}

func (m *StorageTxn) GetTimeConsensus() int64 {
	if m != nil {
		return m.TimeConsensus
	}
	return 0
}

func (m *StorageTxn) GetTxnStatus() TxnStatus {
	if m != nil {
		return m.TxnStatus
	}
	return TxnStatus_AWAITING_COMMIT
}

func (m *StorageTxn) GetBody() *plan.Block {
	if m != nil {
		return m.Body
	}
	return nil
}

func init() {
	proto.RegisterType((*MemberEpoch)(nil), "pdi.MemberEpoch")
	proto.RegisterType((*AccessGrant)(nil), "pdi.AccessGrant")
	proto.RegisterType((*ChannelEpoch)(nil), "pdi.ChannelEpoch")
	proto.RegisterType((*ChannelInfo)(nil), "pdi.ChannelInfo")
	proto.RegisterType((*ChannelList)(nil), "pdi.ChannelList")
	proto.RegisterType((*Entry)(nil), "pdi.Entry")
	proto.RegisterType((*EntryCrypt)(nil), "pdi.EntryCrypt")
	proto.RegisterType((*EntryHeader)(nil), "pdi.EntryHeader")
	proto.RegisterType((*StorageTxn)(nil), "pdi.StorageTxn")
	proto.RegisterEnum("pdi.ChannelAccess", ChannelAccess_name, ChannelAccess_value)
	proto.RegisterEnum("pdi.EntryOp", EntryOp_name, EntryOp_value)
	proto.RegisterEnum("pdi.EntryVersion", EntryVersion_name, EntryVersion_value)
	proto.RegisterEnum("pdi.TxnStatus", TxnStatus_name, TxnStatus_value)
}
func (m *MemberEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemberEpoch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EpochId != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.EpochId))
		i += 8
	}
	if m.PrevEpochId != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.PrevEpochId))
		i += 8
	}
	if m.TimeStarted != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.TimeStarted))
	}
	if len(m.Alias) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.Alias)))
		i += copy(dAtA[i:], m.Alias)
	}
	if len(m.PubSigningKey) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.PubSigningKey)))
		i += copy(dAtA[i:], m.PubSigningKey)
	}
	if len(m.PubCryptoKey) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.PubCryptoKey)))
		i += copy(dAtA[i:], m.PubCryptoKey)
	}
	if len(m.AboutChannelId) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.AboutChannelId)))
		i += copy(dAtA[i:], m.AboutChannelId)
	}
	if len(m.HomeChannelId) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.HomeChannelId)))
		i += copy(dAtA[i:], m.HomeChannelId)
	}
	if m.Extensions != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.Extensions.Size()))
		n1, err := m.Extensions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *AccessGrant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessGrant) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AccessGrant != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.AccessGrant))
	}
	if len(m.Grantees) > 0 {
		for _, b := range m.Grantees {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPdi(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *ChannelEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelEpoch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EpochId != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.EpochId))
		i += 8
	}
	if m.TimeStarted != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.TimeStarted))
	}
	if m.PrevEpochId != 0 {
		dAtA[i] = 0x19
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.PrevEpochId))
		i += 8
	}
	if m.EpochTransitionPeriod != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.EpochTransitionPeriod))
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if len(m.AccessChannelId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.AccessChannelId)))
		i += copy(dAtA[i:], m.AccessChannelId)
	}
	if m.EntriesAreLocked {
		dAtA[i] = 0x38
		i++
		if m.EntriesAreLocked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EntriesAreLockedForever {
		dAtA[i] = 0x40
		i++
		if m.EntriesAreLockedForever {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsExternallyShared {
		dAtA[i] = 0x48
		i++
		if m.IsExternallyShared {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsAccessChannel {
		dAtA[i] = 0x50
		i++
		if m.IsAccessChannel {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.AccessGrants) > 0 {
		for _, msg := range m.AccessGrants {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintPdi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Extensions != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.Extensions.Size()))
		n2, err := m.Extensions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *ChannelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChannelId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.ChannelId)))
		i += copy(dAtA[i:], m.ChannelId)
	}
	if m.InfoRev != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.InfoRev))
	}
	if m.Info != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.Info.Size()))
		n3, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *ChannelList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Channels) > 0 {
		for _, msg := range m.Channels {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPdi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Crypt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.Crypt.Size()))
		n4, err := m.Crypt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Header != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.Header.Size()))
		n5, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Body != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.Body.Size()))
		n6, err := m.Body.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *EntryCrypt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntryCrypt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CryptInfo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.CryptInfo))
	}
	if len(m.CommunityKeyId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.CommunityKeyId)))
		i += copy(dAtA[i:], m.CommunityKeyId)
	}
	if len(m.HeaderCrypt) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.HeaderCrypt)))
		i += copy(dAtA[i:], m.HeaderCrypt)
	}
	if len(m.BodyCrypt) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.BodyCrypt)))
		i += copy(dAtA[i:], m.BodyCrypt)
	}
	if len(m.Sig) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.Sig)))
		i += copy(dAtA[i:], m.Sig)
	}
	return i, nil
}

func (m *EntryHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntryHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimeAuthored != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.TimeAuthored))
	}
	if m.TimeAuthoredNs != 0 {
		dAtA[i] = 0x15
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.TimeAuthoredNs))
		i += 4
	}
	if m.TimeSealed != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.TimeSealed))
	}
	if m.EntryOp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.EntryOp))
	}
	if len(m.ChannelId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.ChannelId)))
		i += copy(dAtA[i:], m.ChannelId)
	}
	if m.ChannelEpochId != 0 {
		dAtA[i] = 0x31
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ChannelEpochId))
		i += 8
	}
	if len(m.AuthorMemberId) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.AuthorMemberId)))
		i += copy(dAtA[i:], m.AuthorMemberId)
	}
	if m.AuthorMemberEpoch != 0 {
		dAtA[i] = 0x41
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AuthorMemberEpoch))
		i += 8
	}
	if len(m.BodyKeyId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.BodyKeyId)))
		i += copy(dAtA[i:], m.BodyKeyId)
	}
	if m.Extensions != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.Extensions.Size()))
		n7, err := m.Extensions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *StorageTxn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageTxn) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TxnName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPdi(dAtA, i, uint64(len(m.TxnName)))
		i += copy(dAtA[i:], m.TxnName)
	}
	if m.TimeCommitted != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.TimeCommitted))
	}
	if m.TimeConsensus != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.TimeConsensus))
	}
	if m.TxnStatus != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.TxnStatus))
	}
	if m.Body != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPdi(dAtA, i, uint64(m.Body.Size()))
		n8, err := m.Body.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func encodeVarintPdi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MemberEpoch) Size() (n int) {
	var l int
	_ = l
	if m.EpochId != 0 {
		n += 9
	}
	if m.PrevEpochId != 0 {
		n += 9
	}
	if m.TimeStarted != 0 {
		n += 1 + sovPdi(uint64(m.TimeStarted))
	}
	l = len(m.Alias)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.PubSigningKey)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.PubCryptoKey)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.AboutChannelId)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.HomeChannelId)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.Extensions != nil {
		l = m.Extensions.Size()
		n += 1 + l + sovPdi(uint64(l))
	}
	return n
}

func (m *AccessGrant) Size() (n int) {
	var l int
	_ = l
	if m.AccessGrant != 0 {
		n += 1 + sovPdi(uint64(m.AccessGrant))
	}
	if len(m.Grantees) > 0 {
		for _, b := range m.Grantees {
			l = len(b)
			n += 1 + l + sovPdi(uint64(l))
		}
	}
	return n
}

func (m *ChannelEpoch) Size() (n int) {
	var l int
	_ = l
	if m.EpochId != 0 {
		n += 9
	}
	if m.TimeStarted != 0 {
		n += 1 + sovPdi(uint64(m.TimeStarted))
	}
	if m.PrevEpochId != 0 {
		n += 9
	}
	if m.EpochTransitionPeriod != 0 {
		n += 1 + sovPdi(uint64(m.EpochTransitionPeriod))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.AccessChannelId)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.EntriesAreLocked {
		n += 2
	}
	if m.EntriesAreLockedForever {
		n += 2
	}
	if m.IsExternallyShared {
		n += 2
	}
	if m.IsAccessChannel {
		n += 2
	}
	if len(m.AccessGrants) > 0 {
		for _, e := range m.AccessGrants {
			l = e.Size()
			n += 1 + l + sovPdi(uint64(l))
		}
	}
	if m.Extensions != nil {
		l = m.Extensions.Size()
		n += 1 + l + sovPdi(uint64(l))
	}
	return n
}

func (m *ChannelInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.InfoRev != 0 {
		n += 1 + sovPdi(uint64(m.InfoRev))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovPdi(uint64(l))
	}
	return n
}

func (m *ChannelList) Size() (n int) {
	var l int
	_ = l
	if len(m.Channels) > 0 {
		for _, e := range m.Channels {
			l = e.Size()
			n += 1 + l + sovPdi(uint64(l))
		}
	}
	return n
}

func (m *Entry) Size() (n int) {
	var l int
	_ = l
	if m.Crypt != nil {
		l = m.Crypt.Size()
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovPdi(uint64(l))
	}
	return n
}

func (m *EntryCrypt) Size() (n int) {
	var l int
	_ = l
	if m.CryptInfo != 0 {
		n += 1 + sovPdi(uint64(m.CryptInfo))
	}
	l = len(m.CommunityKeyId)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.HeaderCrypt)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.BodyCrypt)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	return n
}

func (m *EntryHeader) Size() (n int) {
	var l int
	_ = l
	if m.TimeAuthored != 0 {
		n += 1 + sovPdi(uint64(m.TimeAuthored))
	}
	if m.TimeAuthoredNs != 0 {
		n += 5
	}
	if m.TimeSealed != 0 {
		n += 1 + sovPdi(uint64(m.TimeSealed))
	}
	if m.EntryOp != 0 {
		n += 1 + sovPdi(uint64(m.EntryOp))
	}
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.ChannelEpochId != 0 {
		n += 9
	}
	l = len(m.AuthorMemberId)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.AuthorMemberEpoch != 0 {
		n += 9
	}
	l = len(m.BodyKeyId)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.Extensions != nil {
		l = m.Extensions.Size()
		n += 1 + l + sovPdi(uint64(l))
	}
	return n
}

func (m *StorageTxn) Size() (n int) {
	var l int
	_ = l
	l = len(m.TxnName)
	if l > 0 {
		n += 1 + l + sovPdi(uint64(l))
	}
	if m.TimeCommitted != 0 {
		n += 1 + sovPdi(uint64(m.TimeCommitted))
	}
	if m.TimeConsensus != 0 {
		n += 1 + sovPdi(uint64(m.TimeConsensus))
	}
	if m.TxnStatus != 0 {
		n += 1 + sovPdi(uint64(m.TxnStatus))
	}
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovPdi(uint64(l))
	}
	return n
}

func sovPdi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPdi(x uint64) (n int) {
	return sovPdi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MemberEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemberEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemberEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.EpochId = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevEpochId", wireType)
			}
			m.PrevEpochId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevEpochId = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStarted", wireType)
			}
			m.TimeStarted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeStarted |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubSigningKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubSigningKey = append(m.PubSigningKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubSigningKey == nil {
				m.PubSigningKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubCryptoKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubCryptoKey = append(m.PubCryptoKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubCryptoKey == nil {
				m.PubCryptoKey = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AboutChannelId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AboutChannelId = append(m.AboutChannelId[:0], dAtA[iNdEx:postIndex]...)
			if m.AboutChannelId == nil {
				m.AboutChannelId = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeChannelId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomeChannelId = append(m.HomeChannelId[:0], dAtA[iNdEx:postIndex]...)
			if m.HomeChannelId == nil {
				m.HomeChannelId = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extensions == nil {
				m.Extensions = &plan.Block{}
			}
			if err := m.Extensions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessGrant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessGrant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessGrant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessGrant", wireType)
			}
			m.AccessGrant = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessGrant |= (ChannelAccess(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grantees", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grantees = append(m.Grantees, make([]byte, postIndex-iNdEx))
			copy(m.Grantees[len(m.Grantees)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.EpochId = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStarted", wireType)
			}
			m.TimeStarted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeStarted |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevEpochId", wireType)
			}
			m.PrevEpochId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevEpochId = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochTransitionPeriod", wireType)
			}
			m.EpochTransitionPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochTransitionPeriod |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessChannelId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessChannelId = append(m.AccessChannelId[:0], dAtA[iNdEx:postIndex]...)
			if m.AccessChannelId == nil {
				m.AccessChannelId = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntriesAreLocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EntriesAreLocked = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntriesAreLockedForever", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EntriesAreLockedForever = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsExternallyShared", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsExternallyShared = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAccessChannel", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAccessChannel = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessGrants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessGrants = append(m.AccessGrants, &AccessGrant{})
			if err := m.AccessGrants[len(m.AccessGrants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extensions == nil {
				m.Extensions = &plan.Block{}
			}
			if err := m.Extensions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = append(m.ChannelId[:0], dAtA[iNdEx:postIndex]...)
			if m.ChannelId == nil {
				m.ChannelId = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoRev", wireType)
			}
			m.InfoRev = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InfoRev |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &plan.Block{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channels = append(m.Channels, &ChannelInfo{})
			if err := m.Channels[len(m.Channels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crypt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Crypt == nil {
				m.Crypt = &EntryCrypt{}
			}
			if err := m.Crypt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &EntryHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &plan.Block{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntryCrypt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntryCrypt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntryCrypt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CryptInfo", wireType)
			}
			m.CryptInfo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CryptInfo |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityKeyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunityKeyId = append(m.CommunityKeyId[:0], dAtA[iNdEx:postIndex]...)
			if m.CommunityKeyId == nil {
				m.CommunityKeyId = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderCrypt", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderCrypt = append(m.HeaderCrypt[:0], dAtA[iNdEx:postIndex]...)
			if m.HeaderCrypt == nil {
				m.HeaderCrypt = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyCrypt", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BodyCrypt = append(m.BodyCrypt[:0], dAtA[iNdEx:postIndex]...)
			if m.BodyCrypt == nil {
				m.BodyCrypt = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntryHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntryHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntryHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeAuthored", wireType)
			}
			m.TimeAuthored = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeAuthored |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeAuthoredNs", wireType)
			}
			m.TimeAuthoredNs = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.TimeAuthoredNs = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeSealed", wireType)
			}
			m.TimeSealed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeSealed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryOp", wireType)
			}
			m.EntryOp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryOp |= (EntryOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = append(m.ChannelId[:0], dAtA[iNdEx:postIndex]...)
			if m.ChannelId == nil {
				m.ChannelId = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelEpochId", wireType)
			}
			m.ChannelEpochId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelEpochId = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorMemberId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorMemberId = append(m.AuthorMemberId[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthorMemberId == nil {
				m.AuthorMemberId = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorMemberEpoch", wireType)
			}
			m.AuthorMemberEpoch = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorMemberEpoch = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyKeyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BodyKeyId = append(m.BodyKeyId[:0], dAtA[iNdEx:postIndex]...)
			if m.BodyKeyId == nil {
				m.BodyKeyId = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extensions == nil {
				m.Extensions = &plan.Block{}
			}
			if err := m.Extensions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageTxn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageTxn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageTxn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxnName = append(m.TxnName[:0], dAtA[iNdEx:postIndex]...)
			if m.TxnName == nil {
				m.TxnName = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeCommitted", wireType)
			}
			m.TimeCommitted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeCommitted |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeConsensus", wireType)
			}
			m.TimeConsensus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeConsensus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnStatus", wireType)
			}
			m.TxnStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnStatus |= (TxnStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPdi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &plan.Block{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPdi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPdi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPdi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPdi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPdi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPdi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPdi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPdi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPdi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPdi   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("pdi.proto", fileDescriptorPdi) }

var fileDescriptorPdi = []byte{
	// 1279 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x55, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x36, 0xf5, 0xaf, 0xa1, 0x24, 0x33, 0x9b, 0x3f, 0xc5, 0x40, 0x1d, 0x55, 0x6d, 0x5a, 0xc1,
	0x8d, 0x9d, 0xc0, 0x45, 0x7a, 0xc9, 0x89, 0x91, 0xe8, 0x84, 0x88, 0x4c, 0x19, 0x2b, 0xd6, 0x69,
	0x7b, 0xd9, 0x52, 0xd2, 0x46, 0x22, 0x22, 0x91, 0x02, 0x97, 0x32, 0xac, 0x47, 0x28, 0x50, 0xf4,
	0x58, 0xf4, 0xd2, 0x07, 0xe8, 0x83, 0x14, 0xe8, 0xb1, 0xe8, 0x13, 0x14, 0xe9, 0x8b, 0x14, 0x3b,
	0x4b, 0xd1, 0xb4, 0x8c, 0xa6, 0x17, 0x61, 0xf7, 0x9b, 0x8f, 0xbb, 0xb3, 0xdf, 0x37, 0x33, 0x82,
	0xea, 0x72, 0xe2, 0x1f, 0x2d, 0xa3, 0x30, 0x0e, 0x49, 0x7e, 0x39, 0xf1, 0xf7, 0x0e, 0xa7, 0x7e,
	0x3c, 0x5b, 0x8d, 0x8e, 0xc6, 0xe1, 0xe2, 0xc9, 0x72, 0xee, 0x05, 0x87, 0x71, 0x18, 0xce, 0xc5,
	0x93, 0x69, 0x78, 0x28, 0x77, 0x4f, 0xd2, 0x1f, 0xf5, 0x4d, 0xfb, 0xaf, 0x1c, 0xe8, 0xa7, 0x7c,
	0x31, 0xe2, 0x91, 0xb5, 0x0c, 0xc7, 0x33, 0xf2, 0x00, 0x2a, 0x5c, 0x2e, 0x98, 0x3f, 0x69, 0x6a,
	0x2d, 0xad, 0x53, 0xa2, 0x65, 0xdc, 0xdb, 0x13, 0xd2, 0x86, 0xfa, 0x32, 0xe2, 0x17, 0x2c, 0x8d,
	0xe7, 0x30, 0xae, 0x4b, 0xd0, 0x4a, 0x38, 0x1f, 0x43, 0x2d, 0xf6, 0x17, 0x9c, 0x89, 0xd8, 0x8b,
	0x62, 0x3e, 0x69, 0xe6, 0x5b, 0x5a, 0x27, 0x4f, 0x75, 0x89, 0x0d, 0x15, 0x44, 0xee, 0x40, 0xd1,
	0x9b, 0xfb, 0x9e, 0x68, 0x16, 0x5a, 0x5a, 0xa7, 0x4a, 0xd5, 0x86, 0x7c, 0x06, 0xbb, 0xcb, 0xd5,
	0x88, 0x09, 0x7f, 0x1a, 0xf8, 0xc1, 0x94, 0xbd, 0xe3, 0xeb, 0x66, 0xb1, 0xa5, 0x75, 0x6a, 0xb4,
	0xbe, 0x5c, 0x8d, 0x86, 0x0a, 0x7d, 0xcd, 0xd7, 0xe4, 0x53, 0x68, 0x48, 0xde, 0x38, 0x5a, 0x2f,
	0xe3, 0x10, 0x69, 0x25, 0xa4, 0xd5, 0x96, 0xab, 0x51, 0x17, 0x41, 0xc9, 0xea, 0x80, 0xe1, 0x8d,
	0xc2, 0x55, 0xcc, 0xc6, 0x33, 0x2f, 0x08, 0xf8, 0x5c, 0x66, 0x5b, 0x46, 0x5e, 0x03, 0xf1, 0xae,
	0x82, 0xed, 0x89, 0xbc, 0x77, 0x16, 0x2e, 0x78, 0x96, 0x58, 0x51, 0xf7, 0x4a, 0xf8, 0x8a, 0xf7,
	0x05, 0x00, 0xbf, 0x8c, 0x79, 0x20, 0xfc, 0x30, 0x10, 0xcd, 0x6a, 0x4b, 0xeb, 0xe8, 0xc7, 0xfa,
	0x11, 0x0a, 0xf9, 0x62, 0x1e, 0x8e, 0xdf, 0xd1, 0x4c, 0xb8, 0xfd, 0x3d, 0xe8, 0xe6, 0x78, 0xcc,
	0x85, 0x78, 0x19, 0x79, 0x41, 0x4c, 0x9e, 0x41, 0xcd, 0xc3, 0x2d, 0x9b, 0xca, 0x3d, 0xea, 0xda,
	0x38, 0x26, 0x47, 0xd2, 0xb9, 0xe4, 0x06, 0x45, 0xa7, 0xba, 0x97, 0xf9, 0x6c, 0x0f, 0x2a, 0xc8,
	0xe7, 0x5c, 0x34, 0x73, 0xad, 0x7c, 0xa7, 0x46, 0xd3, 0x7d, 0xfb, 0xd7, 0x02, 0xd4, 0x92, 0x4f,
	0xff, 0xd7, 0xb7, 0x6d, 0x4f, 0x72, 0x37, 0x3d, 0xb9, 0x61, 0x6d, 0xfe, 0xa6, 0xb5, 0x5f, 0xc1,
	0x7d, 0x15, 0x8e, 0x23, 0x2f, 0x10, 0x7e, 0xec, 0x87, 0x01, 0x5b, 0xf2, 0xc8, 0x0f, 0x27, 0xe8,
	0x64, 0x91, 0xde, 0xc5, 0xb0, 0x9b, 0x46, 0xcf, 0x30, 0x28, 0x9f, 0x81, 0xa5, 0x36, 0x0e, 0xe7,
	0x68, 0x69, 0x95, 0xa6, 0x7b, 0x72, 0x00, 0xb7, 0x12, 0x65, 0x32, 0xfa, 0x2b, 0x43, 0x77, 0x55,
	0xe0, 0xca, 0x81, 0xc7, 0x40, 0x78, 0x10, 0x47, 0x3e, 0x17, 0xcc, 0x8b, 0x38, 0x93, 0xa2, 0x73,
	0xe5, 0x6a, 0x85, 0x1a, 0x49, 0xc4, 0x8c, 0x78, 0x1f, 0x71, 0xf2, 0x1c, 0xf6, 0x6e, 0xb2, 0xd9,
	0xdb, 0x30, 0xe2, 0x17, 0x3c, 0x42, 0x8b, 0x2b, 0xf4, 0xfe, 0xf6, 0x57, 0x27, 0x2a, 0x4c, 0x9e,
	0xc2, 0x1d, 0x5f, 0x30, 0x69, 0x68, 0x14, 0x78, 0xf3, 0xf9, 0x9a, 0x89, 0x99, 0x17, 0xf1, 0x09,
	0xda, 0x5e, 0xa1, 0xc4, 0x17, 0x56, 0x1a, 0x1a, 0x62, 0x44, 0x3e, 0xc4, 0x17, 0xec, 0xfa, 0x5b,
	0x9a, 0x80, 0xf4, 0x5d, 0x5f, 0x98, 0xd9, 0xa7, 0x90, 0x67, 0x50, 0xcf, 0x96, 0x83, 0x68, 0xea,
	0xad, 0x7c, 0x47, 0x3f, 0x36, 0xb0, 0x1e, 0x32, 0x75, 0x43, 0x6b, 0x99, 0x6a, 0x10, 0x5b, 0x15,
	0x58, 0xfb, 0x70, 0x05, 0xce, 0x40, 0xdf, 0x28, 0x17, 0xbc, 0x0d, 0xc9, 0x47, 0x00, 0x19, 0x81,
	0x35, 0x14, 0xb8, 0x3a, 0x4e, 0xa5, 0x7d, 0x00, 0x15, 0x3f, 0x78, 0x1b, 0xb2, 0x88, 0x5f, 0xa0,
	0xa0, 0x75, 0x5a, 0x96, 0x7b, 0xca, 0x2f, 0xc8, 0x43, 0x28, 0xc8, 0x25, 0x2a, 0xb6, 0x75, 0x1f,
	0x06, 0xda, 0xcf, 0xd3, 0x9b, 0xfa, 0xbe, 0x88, 0xc9, 0x63, 0xa8, 0x24, 0xe7, 0x8a, 0xa6, 0x96,
	0x79, 0x57, 0x26, 0x1b, 0x9a, 0x32, 0xda, 0x6b, 0x28, 0x5a, 0x41, 0x1c, 0xad, 0xc9, 0x23, 0x28,
	0x62, 0x4b, 0x63, 0x6e, 0xfa, 0xf1, 0x2e, 0x7e, 0x83, 0x21, 0x6c, 0x6a, 0xaa, 0xa2, 0xa4, 0x03,
	0xa5, 0x19, 0xf7, 0x26, 0x3c, 0xc2, 0x22, 0xde, 0x9c, 0x8d, 0xbc, 0x57, 0x88, 0xd3, 0x24, 0x2e,
	0xf3, 0x1e, 0x85, 0x93, 0x35, 0x16, 0xf2, 0x76, 0xde, 0x32, 0xd0, 0xfe, 0x4d, 0x03, 0xb8, 0xba,
	0x00, 0x15, 0x92, 0x0b, 0x86, 0xaf, 0x95, 0x59, 0x14, 0x68, 0x15, 0x11, 0x14, 0xb0, 0x03, 0xc6,
	0x38, 0x5c, 0x2c, 0x56, 0x81, 0x1f, 0xaf, 0xe5, 0xd4, 0xd9, 0xf4, 0x48, 0x8d, 0x36, 0x52, 0xfc,
	0x35, 0x5f, 0xab, 0x6e, 0x53, 0x29, 0xa8, 0x19, 0x95, 0x4c, 0x31, 0x5d, 0x61, 0xe9, 0x5d, 0x32,
	0x85, 0x84, 0xa0, 0xca, 0xbd, 0x2a, 0x11, 0x15, 0x36, 0x20, 0x2f, 0xfc, 0x69, 0x32, 0xaf, 0xe4,
	0xb2, 0xfd, 0x73, 0x1e, 0xf4, 0xcc, 0x23, 0xc9, 0x27, 0x50, 0xc7, 0x8e, 0xf6, 0x56, 0xf1, 0x2c,
	0x94, 0x85, 0xa9, 0x61, 0x4b, 0x63, 0x9b, 0x9b, 0x09, 0x26, 0x53, 0xbe, 0x46, 0x62, 0x81, 0x40,
	0xd5, 0xca, 0xb4, 0x91, 0xe5, 0x39, 0x82, 0x3c, 0x04, 0x5d, 0x0d, 0x08, 0xee, 0xcd, 0xd3, 0x99,
	0x0d, 0x38, 0x1f, 0x10, 0x21, 0x9f, 0x43, 0x45, 0xb6, 0xca, 0x9a, 0x85, 0x4b, 0xec, 0xf5, 0xc6,
	0x71, 0xed, 0x4a, 0xf8, 0xc1, 0x92, 0x96, 0xb9, 0x5a, 0x6c, 0xd5, 0x59, 0x71, 0xbb, 0xce, 0xa4,
	0x8a, 0x49, 0x38, 0x9d, 0x34, 0x25, 0x9c, 0x34, 0x8d, 0x71, 0x66, 0x98, 0x29, 0xa6, 0xca, 0x9b,
	0x2d, 0xf0, 0xcf, 0x29, 0x3b, 0xc0, 0x11, 0x57, 0xff, 0x59, 0xf6, 0x84, 0x1c, 0xc1, 0xed, 0xeb,
	0x4c, 0x3c, 0x19, 0xeb, 0xb5, 0x44, 0x6f, 0x65, 0xc9, 0x6a, 0x50, 0xee, 0x83, 0x8e, 0xe2, 0x27,
	0x26, 0xc2, 0x95, 0xfa, 0xca, 0xbf, 0xeb, 0x6d, 0xa6, 0x7f, 0xb8, 0xcd, 0x7e, 0xd7, 0x00, 0x86,
	0x71, 0x18, 0x79, 0x53, 0xee, 0x5e, 0x06, 0xb2, 0x8f, 0xe2, 0xcb, 0x80, 0x05, 0xde, 0x82, 0x27,
	0x4d, 0x56, 0x8e, 0x2f, 0x03, 0xc7, 0x5b, 0x70, 0xf2, 0x08, 0x50, 0x75, 0x26, 0xab, 0xc5, 0x8f,
	0xaf, 0xc6, 0x30, 0x1a, 0xd9, 0xdd, 0x80, 0x19, 0x5a, 0x20, 0x78, 0x20, 0x56, 0x22, 0x71, 0x23,
	0xa1, 0x25, 0x20, 0x39, 0x04, 0x90, 0x17, 0x89, 0xd8, 0x8b, 0x57, 0x22, 0xb1, 0xa4, 0x81, 0x96,
	0xb8, 0x97, 0xc1, 0x10, 0x51, 0x5a, 0x8d, 0x37, 0xcb, 0xb4, 0x19, 0x8a, 0xff, 0xd1, 0x0c, 0x07,
	0x3f, 0x68, 0x50, 0xbf, 0xf6, 0x4f, 0x44, 0xea, 0x50, 0x75, 0x06, 0xcc, 0xec, 0x76, 0xad, 0xe1,
	0xd0, 0xd8, 0x21, 0xbb, 0xa0, 0x53, 0xcb, 0xec, 0x6d, 0x00, 0x8d, 0xdc, 0x01, 0x43, 0x02, 0x6f,
	0xa8, 0xed, 0x5a, 0x1b, 0x34, 0x27, 0xd1, 0xd3, 0x41, 0xcf, 0xa2, 0xa6, 0x3b, 0xa0, 0x1b, 0x34,
	0x4f, 0xf6, 0xe0, 0xde, 0xf0, 0xeb, 0x33, 0x8b, 0xb2, 0x1b, 0xb1, 0x02, 0x31, 0xa0, 0x66, 0xf6,
	0x4e, 0x6d, 0x67, 0x83, 0x14, 0x0f, 0x7e, 0xd2, 0xa0, 0x9c, 0x14, 0x96, 0x3c, 0xef, 0x6c, 0x30,
	0x74, 0x99, 0x63, 0xbd, 0x61, 0xdd, 0x81, 0xe3, 0x5a, 0x8e, 0x6b, 0xec, 0x10, 0x02, 0x0d, 0x6a,
	0x9d, 0x0e, 0xce, 0x2d, 0x66, 0x39, 0x2e, 0xb5, 0x2d, 0x99, 0xcf, 0x6d, 0xd8, 0xc5, 0x3b, 0xba,
	0x56, 0x4f, 0xc1, 0xdf, 0x1a, 0x39, 0x72, 0x17, 0x6e, 0x59, 0x3d, 0xdb, 0x65, 0xdd, 0x57, 0xa6,
	0xe3, 0x58, 0x7d, 0x66, 0x3b, 0x27, 0x03, 0x23, 0x2f, 0x61, 0x3c, 0x30, 0x41, 0xad, 0xb3, 0x41,
	0xf7, 0x95, 0x51, 0x20, 0xf7, 0x80, 0x20, 0x5b, 0x65, 0xc2, 0x5e, 0x52, 0xd3, 0x71, 0x65, 0x42,
	0xf7, 0xa0, 0x86, 0xf9, 0x9c, 0xf3, 0x48, 0xba, 0x4e, 0x4a, 0x90, 0x3b, 0x7f, 0x6a, 0xec, 0x1c,
	0xfc, 0xa8, 0x41, 0x35, 0x95, 0x5b, 0x26, 0x60, 0xbe, 0x31, 0x6d, 0xd7, 0x76, 0x5e, 0xb2, 0xee,
	0xe0, 0xf4, 0xd4, 0x96, 0x99, 0x36, 0x00, 0xd4, 0x5a, 0xc2, 0x46, 0x4e, 0xca, 0x68, 0x3b, 0xe7,
	0x66, 0xdf, 0xee, 0x31, 0xf7, 0x1b, 0xc7, 0xc8, 0x93, 0x0a, 0x14, 0xfa, 0x83, 0xa1, 0x6b, 0x14,
	0xe5, 0x53, 0x4f, 0x4c, 0xbb, 0x6f, 0xf5, 0x98, 0x3b, 0xd8, 0x1c, 0x50, 0x96, 0x36, 0x24, 0x07,
	0x58, 0x3d, 0xa3, 0x42, 0x74, 0x28, 0x53, 0xeb, 0x7c, 0xf0, 0xda, 0xea, 0x19, 0x55, 0x19, 0x3b,
	0xb1, 0x1d, 0xb3, 0x6f, 0x7f, 0x67, 0xf5, 0x0c, 0xe3, 0x85, 0xf1, 0xc7, 0xfb, 0x7d, 0xed, 0xcf,
	0xf7, 0xfb, 0xda, 0xdf, 0xef, 0xf7, 0xb5, 0x5f, 0xfe, 0xd9, 0xdf, 0x19, 0x95, 0xf0, 0x7f, 0xf6,
	0xcb, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x24, 0x55, 0xd8, 0x36, 0x23, 0x0a, 0x00, 0x00,
}
