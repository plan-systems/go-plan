// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: vault/vault.proto

package vault

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Const int32

const (
	Const_ConstDefs Const = 0
	// EntryIDSz is the expected byte size of an EntryID
	Const_EntryIDSz Const = 30
	// DefaultGrpcServicePort is the TCP port number that the service VaultGrpc should run on by default.
	Const_DefaultGrpcServicePort Const = 5190
)

var Const_name = map[int32]string{
	0:    "ConstDefs",
	30:   "EntryIDSz",
	5190: "DefaultGrpcServicePort",
}

var Const_value = map[string]int32{
	"ConstDefs":              0,
	"EntryIDSz":              30,
	"DefaultGrpcServicePort": 5190,
}

func (x Const) String() string {
	return proto.EnumName(Const_name, int32(x))
}

func (Const) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_588669eac0ffd7f7, []int{0}
}

// ReqOp is a code describing the purpose and format of the vault Req that it resides in.
type ReqOp int32

const (
	ReqOp_InvalidEntry ReqOp = 0
	// AppendEntry requests that FeedReq.NewEntry is appended to the given stream URI.
	// When this entry has been committed, a ReqComplete will be returned.
	ReqOp_AppendEntry ReqOp = 1
	// ChannelGenesis creates a new channel specified in FeedReq.FeedURI
	// FeedReq.NewEntry is written into the new channel (and is the channel genesis entry).
	ReqOp_ChannelGenesis ReqOp = 2
	// CancelReq tells the server to cancel/stop/close the request identified by the given ReqID.
	// Unlike all other client-to-server requests, the ReqID of this msg is not newly issued -- it refers to an existing request.
	ReqOp_CancelReq ReqOp = 10
	// OpenFeed requests to open a given channel feed based on the params in FeedReq.OpenFeed
	// On success, the server does not send a response and either begins streaming (if it was requested) and/or awaits requests for channel feed.
	ReqOp_OpenFeed ReqOp = 30
)

var ReqOp_name = map[int32]string{
	0:  "InvalidEntry",
	1:  "AppendEntry",
	2:  "ChannelGenesis",
	10: "CancelReq",
	30: "OpenFeed",
}

var ReqOp_value = map[string]int32{
	"InvalidEntry":   0,
	"AppendEntry":    1,
	"ChannelGenesis": 2,
	"CancelReq":      10,
	"OpenFeed":       30,
}

func (x ReqOp) String() string {
	return proto.EnumName(ReqOp_name, int32(x))
}

func (ReqOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_588669eac0ffd7f7, []int{1}
}

// MsgOp tells a holder of a Msg how to interpret its fields.
// On general this is how a Vault communicates to a client.
type MsgOp int32

const (
	// FeedEntry delivers the next entry in a feed stream identified by FeedMsg.ReqID.
	MsgOp_FeedEntry MsgOp = 0
	// ReqComplete means the referenced request (via FeedMsg.ReqID) has successfully completed.
	// Other values in the FeedMsg are contextual the op that was completed.
	MsgOp_ReqComplete MsgOp = 1
	// ReqDiscarded means the referenced request failed and/or has been cancelled.
	// If Msg.Body != nil, then it is a serialized ReqErr describing why it was discarded.
	// As with ReqComplete, the referenced request is now closed/complete, so the given ReqID is now available for (re)use.
	MsgOp_ReqDiscarded MsgOp = 3
	// FeedReqStatus is the server reporting progress for the given ReqID.
	// FeedMsg.Body is a serialized ReqStatus.
	MsgOp_FeedReqStatus MsgOp = 4
)

var MsgOp_name = map[int32]string{
	0: "FeedEntry",
	1: "ReqComplete",
	3: "ReqDiscarded",
	4: "FeedReqStatus",
}

var MsgOp_value = map[string]int32{
	"FeedEntry":     0,
	"ReqComplete":   1,
	"ReqDiscarded":  3,
	"FeedReqStatus": 4,
}

func (x MsgOp) String() string {
	return proto.EnumName(MsgOp_name, int32(x))
}

func (MsgOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_588669eac0ffd7f7, []int{2}
}

type StreamMode int32

const (
	// DontStream means the server should not stream any entries.
	// This mode is typically used by clients that only want to append
	// entries to a feed.  SeekEntryID is ignored.
	StreamMode_DontStream StreamMode = 0
	// FromGenesis tells the server to start streaming from the very
	// beginning of the feed.  SeekEntryID is ignored.
	StreamMode_FromGenesis StreamMode = 1
	// AtEntry tells the server to stream starting with SeekEntryID.
	StreamMode_AtEntry StreamMode = 4
	// AfterEntry tells the server to stream starting with the entry
	// immediately *after* SeekEntryID.
	StreamMode_AfterEntry StreamMode = 5
	// AfterHead tells the server to resume after the latest entry in this feed.
	// SeekEntryID is ignored.
	StreamMode_AfterHead StreamMode = 7
	// FromIndex tells the server to treat stream entries in order of
	// arrival at this vault peer, rather than ordered by
	// EntryID. This allows clients to catch up to entries received
	// while they were offline. The SeekEntryID is treated as the
	// index.
	StreamMode_FromIndex StreamMode = 9
)

var StreamMode_name = map[int32]string{
	0: "DontStream",
	1: "FromGenesis",
	4: "AtEntry",
	5: "AfterEntry",
	7: "AfterHead",
	9: "FromIndex",
}

var StreamMode_value = map[string]int32{
	"DontStream":  0,
	"FromGenesis": 1,
	"AtEntry":     4,
	"AfterEntry":  5,
	"AfterHead":   7,
	"FromIndex":   9,
}

func (x StreamMode) String() string {
	return proto.EnumName(StreamMode_name, int32(x))
}

func (StreamMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_588669eac0ffd7f7, []int{3}
}

// StatusCode expresses milestones for a given feed request.
type StatusCode int32

const (
	// InfoMsg means there is no status change, other than the amplifying message in ReqStatus.Msg
	StatusCode_InfoMsg StatusCode = 0
	// WarningMsg means there is no status change, other than the warning message in ReqStatus.Msg.
	StatusCode_WarningMsg StatusCode = 1
	// Working is a flag that means that the request is actively being worked and to expect progress on the order of several seconds.
	StatusCode_Working           StatusCode = 64
	StatusCode_FindingPeers      StatusCode = 65
	StatusCode_ConnectingToPeers StatusCode = 66
	StatusCode_SearchingForFeed  StatusCode = 67
	StatusCode_TransferringFeed  StatusCode = 68
	// Stalled is a flag that means the request is in a long-term wait state of some kind with an unbounded completion time.
	// This flag can be ORed to any of the above "Working" status code values.
	StatusCode_Stalled StatusCode = 128
)

var StatusCode_name = map[int32]string{
	0:   "InfoMsg",
	1:   "WarningMsg",
	64:  "Working",
	65:  "FindingPeers",
	66:  "ConnectingToPeers",
	67:  "SearchingForFeed",
	68:  "TransferringFeed",
	128: "Stalled",
}

var StatusCode_value = map[string]int32{
	"InfoMsg":           0,
	"WarningMsg":        1,
	"Working":           64,
	"FindingPeers":      65,
	"ConnectingToPeers": 66,
	"SearchingForFeed":  67,
	"TransferringFeed":  68,
	"Stalled":           128,
}

func (x StatusCode) String() string {
	return proto.EnumName(StatusCode_name, int32(x))
}

func (StatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_588669eac0ffd7f7, []int{4}
}

// ErrCode is used to unambiguously express common errors.
type ErrCode int32

const (
	ErrCode_NoErr                   ErrCode = 0
	ErrCode_UnnamedErr              ErrCode = 5000
	ErrCode_ReqCanceled             ErrCode = 5001
	ErrCode_InsufficientPermissions ErrCode = 5101
	ErrCode_ReqNotFound             ErrCode = 5010
	ErrCode_ReqInUse                ErrCode = 5011
	ErrCode_InvalidFeedURI          ErrCode = 5020
	ErrCode_FeedNotFound            ErrCode = 5021
	ErrCode_FeedAlreadyExists       ErrCode = 5022
	ErrCode_UnrecognizedVaultCtx    ErrCode = 5030
	ErrCode_InvalidRequest          ErrCode = 5040
	ErrCode_DatabaseError           ErrCode = 6000
)

var ErrCode_name = map[int32]string{
	0:    "NoErr",
	5000: "UnnamedErr",
	5001: "ReqCanceled",
	5101: "InsufficientPermissions",
	5010: "ReqNotFound",
	5011: "ReqInUse",
	5020: "InvalidFeedURI",
	5021: "FeedNotFound",
	5022: "FeedAlreadyExists",
	5030: "UnrecognizedVaultCtx",
	5040: "InvalidRequest",
	6000: "DatabaseError",
}

var ErrCode_value = map[string]int32{
	"NoErr":                   0,
	"UnnamedErr":              5000,
	"ReqCanceled":             5001,
	"InsufficientPermissions": 5101,
	"ReqNotFound":             5010,
	"ReqInUse":                5011,
	"InvalidFeedURI":          5020,
	"FeedNotFound":            5021,
	"FeedAlreadyExists":       5022,
	"UnrecognizedVaultCtx":    5030,
	"InvalidRequest":          5040,
	"DatabaseError":           6000,
}

func (x ErrCode) String() string {
	return proto.EnumName(ErrCode_name, int32(x))
}

func (ErrCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_588669eac0ffd7f7, []int{5}
}

// PeerUpdateOp tells us what to do with the Peer we just got. Note
// that we only remove a peer ID when it's gone permanently, not when
// it's temporarily unavailable or has moved to a new multiaddr.
type PeerUpdateOp int32

const (
	PeerUpdateOp_Nothing           PeerUpdateOp = 0
	PeerUpdateOp_Upsert            PeerUpdateOp = 10
	PeerUpdateOp_RemovePermanently PeerUpdateOp = 20
)

var PeerUpdateOp_name = map[int32]string{
	0:  "Nothing",
	10: "Upsert",
	20: "RemovePermanently",
}

var PeerUpdateOp_value = map[string]int32{
	"Nothing":           0,
	"Upsert":            10,
	"RemovePermanently": 20,
}

func (x PeerUpdateOp) String() string {
	return proto.EnumName(PeerUpdateOp_name, int32(x))
}

func (PeerUpdateOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_588669eac0ffd7f7, []int{6}
}

type FeedReq struct {
	// ReqOp requests that the given op to be execute on ChReq.Entries
	ReqOp ReqOp `protobuf:"varint,1,opt,name=ReqOp,proto3,enum=vault.ReqOp" json:"ReqOp,omitempty"`
	// ReqID is a client-assigned ID that allows the client and server to reference this ChReq in the future.
	// Node.ReqComplete & ReqDiscarded is how the server signals when this request is considered closed/complete.
	ReqID int32 `protobuf:"varint,2,opt,name=ReqID,proto3" json:"ReqID,omitempty"`
	// OpenFeed opens a feed for access.
	OpenFeed *OpenFeedReq `protobuf:"bytes,10,opt,name=OpenFeed,proto3" json:"OpenFeed,omitempty"`
	// NewEntry is contains an entry to be appended to this feed.
	// If non-nil, FeedURI should be created and this entry should be the first entry appended to it.
	NewEntry             *Msg     `protobuf:"bytes,20,opt,name=NewEntry,proto3" json:"NewEntry,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FeedReq) Reset()         { *m = FeedReq{} }
func (m *FeedReq) String() string { return proto.CompactTextString(m) }
func (*FeedReq) ProtoMessage()    {}
func (*FeedReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_588669eac0ffd7f7, []int{0}
}
func (m *FeedReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeedReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeedReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeedReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeedReq.Merge(m, src)
}
func (m *FeedReq) XXX_Size() int {
	return m.Size()
}
func (m *FeedReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FeedReq.DiscardUnknown(m)
}

var xxx_messageInfo_FeedReq proto.InternalMessageInfo

func (m *FeedReq) GetReqOp() ReqOp {
	if m != nil {
		return m.ReqOp
	}
	return ReqOp_InvalidEntry
}

func (m *FeedReq) GetReqID() int32 {
	if m != nil {
		return m.ReqID
	}
	return 0
}

func (m *FeedReq) GetOpenFeed() *OpenFeedReq {
	if m != nil {
		return m.OpenFeed
	}
	return nil
}

func (m *FeedReq) GetNewEntry() *Msg {
	if m != nil {
		return m.NewEntry
	}
	return nil
}

type OpenFeedReq struct {
	// FeedURI is the feed name to be opened.
	// A feed URI a case-sensitive, UTF8, POSIX-style pathname.
	FeedURI string `protobuf:"bytes,10,opt,name=FeedURI,proto3" json:"FeedURI,omitempty"`
	// StreamMode specifies if and where the server should start streaming feed entries.
	StreamMode StreamMode `protobuf:"varint,11,opt,name=StreamMode,proto3,enum=vault.StreamMode" json:"StreamMode,omitempty"`
	// SeekEntryID tells the server where to start streaming.
	SeekEntryID []byte `protobuf:"bytes,12,opt,name=SeekEntryID,proto3" json:"SeekEntryID,omitempty"`
	// MaxEntriesToSend limits the number of entries the server will stream.
	// If 0, then no limit is set.
	MaxEntriesToSend int32 `protobuf:"varint,13,opt,name=MaxEntriesToSend,proto3" json:"MaxEntriesToSend,omitempty"`
	// SendEntryIDsOnly tells the server to only send EntryIDs (MsgData and MsgCodec will be nil)
	SendEntryIDsOnly     bool     `protobuf:"varint,14,opt,name=SendEntryIDsOnly,proto3" json:"SendEntryIDsOnly,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpenFeedReq) Reset()         { *m = OpenFeedReq{} }
func (m *OpenFeedReq) String() string { return proto.CompactTextString(m) }
func (*OpenFeedReq) ProtoMessage()    {}
func (*OpenFeedReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_588669eac0ffd7f7, []int{1}
}
func (m *OpenFeedReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenFeedReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenFeedReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenFeedReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenFeedReq.Merge(m, src)
}
func (m *OpenFeedReq) XXX_Size() int {
	return m.Size()
}
func (m *OpenFeedReq) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenFeedReq.DiscardUnknown(m)
}

var xxx_messageInfo_OpenFeedReq proto.InternalMessageInfo

func (m *OpenFeedReq) GetFeedURI() string {
	if m != nil {
		return m.FeedURI
	}
	return ""
}

func (m *OpenFeedReq) GetStreamMode() StreamMode {
	if m != nil {
		return m.StreamMode
	}
	return StreamMode_DontStream
}

func (m *OpenFeedReq) GetSeekEntryID() []byte {
	if m != nil {
		return m.SeekEntryID
	}
	return nil
}

func (m *OpenFeedReq) GetMaxEntriesToSend() int32 {
	if m != nil {
		return m.MaxEntriesToSend
	}
	return 0
}

func (m *OpenFeedReq) GetSendEntryIDsOnly() bool {
	if m != nil {
		return m.SendEntryIDsOnly
	}
	return false
}

type EntryHeader struct {
	// EntryID names the entry being posted and is a binary ID based on a hash of the entry body.
	// The vault can safely assume that no two entries will ever share the same EntryID.
	// The expected byte size of this ID (and all other entry IDs is Const.EntryIDSz)
	EntryID []byte `protobuf:"bytes,1,opt,name=EntryID,proto3" json:"EntryID,omitempty"`
	// MemberID tells us what key signed the entry.
	MemberID []byte `protobuf:"bytes,2,opt,name=MemberID,proto3" json:"MemberID,omitempty"`
	// ParentID names a parent of this entry and intended to be an aid for a vault to help find and recover missing entries in a feed.
	ParentID []byte `protobuf:"bytes,10,opt,name=ParentID,proto3" json:"ParentID,omitempty"`
	// EntryCodec is a POSIX-style pathname that describes the encoding of this entry's data body.
	// It is not needed/used by the vault (with the exception that vaults may insert entries into a feed stream to meta-communicate).
	// Unrecognized codec types should be ignored but passed on as applicable.
	EntryCodec string `protobuf:"bytes,11,opt,name=EntryCodec,proto3" json:"EntryCodec,omitempty"`
	// FeedURI tells the client what Channel the Entry is associated with.
	FeedURI              string   `protobuf:"bytes,15,opt,name=FeedURI,proto3" json:"FeedURI,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EntryHeader) Reset()         { *m = EntryHeader{} }
func (m *EntryHeader) String() string { return proto.CompactTextString(m) }
func (*EntryHeader) ProtoMessage()    {}
func (*EntryHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_588669eac0ffd7f7, []int{2}
}
func (m *EntryHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntryHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntryHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntryHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntryHeader.Merge(m, src)
}
func (m *EntryHeader) XXX_Size() int {
	return m.Size()
}
func (m *EntryHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_EntryHeader.DiscardUnknown(m)
}

var xxx_messageInfo_EntryHeader proto.InternalMessageInfo

func (m *EntryHeader) GetEntryID() []byte {
	if m != nil {
		return m.EntryID
	}
	return nil
}

func (m *EntryHeader) GetMemberID() []byte {
	if m != nil {
		return m.MemberID
	}
	return nil
}

func (m *EntryHeader) GetParentID() []byte {
	if m != nil {
		return m.ParentID
	}
	return nil
}

func (m *EntryHeader) GetEntryCodec() string {
	if m != nil {
		return m.EntryCodec
	}
	return ""
}

func (m *EntryHeader) GetFeedURI() string {
	if m != nil {
		return m.FeedURI
	}
	return ""
}

// Msg is the generalized response object that a vault sends to the client as it processes each requests sent by the client.
type Msg struct {
	// MsOp tells the client how to interpret the fields in this FeedMsg.
	Op MsgOp `protobuf:"varint,1,opt,name=Op,proto3,enum=vault.MsgOp" json:"Op,omitempty"`
	// ReqID is set to value the originating FeedReq.ReqID was set to.
	ReqID int32 `protobuf:"varint,2,opt,name=ReqID,proto3" json:"ReqID,omitempty"`
	// EntryHeader, if non-nil, provides info about the entry contained in Msg.Body.
	EntryHeader *EntryHeader `protobuf:"bytes,8,opt,name=EntryHeader,proto3" json:"EntryHeader,omitempty"`
	// Body is an entry's data body
	Body []byte `protobuf:"bytes,10,opt,name=Body,proto3" json:"Body,omitempty"`
	// Status provides status information about the request beyond
	// what is provided in thenMsgOp
	Status *ReqStatus `protobuf:"bytes,20,opt,name=Status,proto3" json:"Status,omitempty"`
	// Err provides details about error conditions.
	Err                  *ReqErr  `protobuf:"bytes,30,opt,name=Err,proto3" json:"Err,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Msg) Reset()         { *m = Msg{} }
func (m *Msg) String() string { return proto.CompactTextString(m) }
func (*Msg) ProtoMessage()    {}
func (*Msg) Descriptor() ([]byte, []int) {
	return fileDescriptor_588669eac0ffd7f7, []int{3}
}
func (m *Msg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Msg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Msg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Msg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Msg.Merge(m, src)
}
func (m *Msg) XXX_Size() int {
	return m.Size()
}
func (m *Msg) XXX_DiscardUnknown() {
	xxx_messageInfo_Msg.DiscardUnknown(m)
}

var xxx_messageInfo_Msg proto.InternalMessageInfo

func (m *Msg) GetOp() MsgOp {
	if m != nil {
		return m.Op
	}
	return MsgOp_FeedEntry
}

func (m *Msg) GetReqID() int32 {
	if m != nil {
		return m.ReqID
	}
	return 0
}

func (m *Msg) GetEntryHeader() *EntryHeader {
	if m != nil {
		return m.EntryHeader
	}
	return nil
}

func (m *Msg) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Msg) GetStatus() *ReqStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Msg) GetErr() *ReqErr {
	if m != nil {
		return m.Err
	}
	return nil
}

// ReqStatus is used in conjunction with FeedMsgOp.StatusUpdate and expresses milestones for a given client request.
type ReqStatus struct {
	// ReqID is feed request ID that this update is reporting about.
	ReqID int32 `protobuf:"varint,1,opt,name=ReqID,proto3" json:"ReqID,omitempty"`
	// Code describes the status of ReqID.
	Code StatusCode `protobuf:"varint,2,opt,name=Code,proto3,enum=vault.StatusCode" json:"Code,omitempty"`
	// Msg is an optional human-readable message describing the current status of a request.
	Msg string `protobuf:"bytes,3,opt,name=Msg,proto3" json:"Msg,omitempty"`
	// If applicable this is a relevant entry ID.
	EntryID []byte `protobuf:"bytes,4,opt,name=EntryID,proto3" json:"EntryID,omitempty"`
	// If greater than zero, these are estimates of the work or time remaining.
	BytesRemaining       int64    `protobuf:"varint,10,opt,name=BytesRemaining,proto3" json:"BytesRemaining,omitempty"`
	SecsRemaining        int64    `protobuf:"varint,11,opt,name=SecsRemaining,proto3" json:"SecsRemaining,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReqStatus) Reset()         { *m = ReqStatus{} }
func (m *ReqStatus) String() string { return proto.CompactTextString(m) }
func (*ReqStatus) ProtoMessage()    {}
func (*ReqStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_588669eac0ffd7f7, []int{4}
}
func (m *ReqStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReqStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReqStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReqStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqStatus.Merge(m, src)
}
func (m *ReqStatus) XXX_Size() int {
	return m.Size()
}
func (m *ReqStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ReqStatus proto.InternalMessageInfo

func (m *ReqStatus) GetReqID() int32 {
	if m != nil {
		return m.ReqID
	}
	return 0
}

func (m *ReqStatus) GetCode() StatusCode {
	if m != nil {
		return m.Code
	}
	return StatusCode_InfoMsg
}

func (m *ReqStatus) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ReqStatus) GetEntryID() []byte {
	if m != nil {
		return m.EntryID
	}
	return nil
}

func (m *ReqStatus) GetBytesRemaining() int64 {
	if m != nil {
		return m.BytesRemaining
	}
	return 0
}

func (m *ReqStatus) GetSecsRemaining() int64 {
	if m != nil {
		return m.SecsRemaining
	}
	return 0
}

// ReqErr wraps any error and is typically used in conjunction with FeedMsgOp.ReqDiscarded
type ReqErr struct {
	Code                 ErrCode  `protobuf:"varint,1,opt,name=Code,proto3,enum=vault.ErrCode" json:"Code,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=Msg,proto3" json:"Msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReqErr) Reset()         { *m = ReqErr{} }
func (m *ReqErr) String() string { return proto.CompactTextString(m) }
func (*ReqErr) ProtoMessage()    {}
func (*ReqErr) Descriptor() ([]byte, []int) {
	return fileDescriptor_588669eac0ffd7f7, []int{5}
}
func (m *ReqErr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReqErr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReqErr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReqErr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqErr.Merge(m, src)
}
func (m *ReqErr) XXX_Size() int {
	return m.Size()
}
func (m *ReqErr) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqErr.DiscardUnknown(m)
}

var xxx_messageInfo_ReqErr proto.InternalMessageInfo

func (m *ReqErr) GetCode() ErrCode {
	if m != nil {
		return m.Code
	}
	return ErrCode_NoErr
}

func (m *ReqErr) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// Peer is the body of a message sent over the discovery Channel for
// sharing peer network addresses and public keys.
type Peer struct {
	// Op tells us what to do with this
	Op PeerUpdateOp `protobuf:"varint,1,opt,name=Op,proto3,enum=vault.PeerUpdateOp" json:"Op,omitempty"`
	// ID is the Peer ID
	ID string `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	// Key is the Peer public key
	Key []byte `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	// multiaddrs is the list of network multiaddresses for this peer
	Multiaddrs           [][]byte `protobuf:"bytes,5,rep,name=Multiaddrs,proto3" json:"Multiaddrs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Peer) Reset()         { *m = Peer{} }
func (m *Peer) String() string { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()    {}
func (*Peer) Descriptor() ([]byte, []int) {
	return fileDescriptor_588669eac0ffd7f7, []int{6}
}
func (m *Peer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Peer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Peer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Peer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Peer.Merge(m, src)
}
func (m *Peer) XXX_Size() int {
	return m.Size()
}
func (m *Peer) XXX_DiscardUnknown() {
	xxx_messageInfo_Peer.DiscardUnknown(m)
}

var xxx_messageInfo_Peer proto.InternalMessageInfo

func (m *Peer) GetOp() PeerUpdateOp {
	if m != nil {
		return m.Op
	}
	return PeerUpdateOp_Nothing
}

func (m *Peer) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Peer) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Peer) GetMultiaddrs() [][]byte {
	if m != nil {
		return m.Multiaddrs
	}
	return nil
}

func init() {
	proto.RegisterEnum("vault.Const", Const_name, Const_value)
	proto.RegisterEnum("vault.ReqOp", ReqOp_name, ReqOp_value)
	proto.RegisterEnum("vault.MsgOp", MsgOp_name, MsgOp_value)
	proto.RegisterEnum("vault.StreamMode", StreamMode_name, StreamMode_value)
	proto.RegisterEnum("vault.StatusCode", StatusCode_name, StatusCode_value)
	proto.RegisterEnum("vault.ErrCode", ErrCode_name, ErrCode_value)
	proto.RegisterEnum("vault.PeerUpdateOp", PeerUpdateOp_name, PeerUpdateOp_value)
	proto.RegisterType((*FeedReq)(nil), "vault.FeedReq")
	proto.RegisterType((*OpenFeedReq)(nil), "vault.OpenFeedReq")
	proto.RegisterType((*EntryHeader)(nil), "vault.EntryHeader")
	proto.RegisterType((*Msg)(nil), "vault.Msg")
	proto.RegisterType((*ReqStatus)(nil), "vault.ReqStatus")
	proto.RegisterType((*ReqErr)(nil), "vault.ReqErr")
	proto.RegisterType((*Peer)(nil), "vault.Peer")
}

func init() { proto.RegisterFile("vault/vault.proto", fileDescriptor_588669eac0ffd7f7) }

var fileDescriptor_588669eac0ffd7f7 = []byte{
	// 1109 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x55, 0xcf, 0x73, 0x62, 0x45,
	0x10, 0xce, 0x90, 0x90, 0x40, 0xf3, 0x60, 0x87, 0xd9, 0xb8, 0x3e, 0xd7, 0x2d, 0xa4, 0x50, 0x17,
	0x8a, 0x43, 0xd4, 0xd5, 0x9b, 0x55, 0x5b, 0x26, 0x40, 0x56, 0x4a, 0x49, 0x52, 0xc3, 0xb2, 0x7b,
	0xf0, 0xf4, 0x96, 0xd7, 0xb0, 0xaf, 0x16, 0x66, 0x60, 0x66, 0x88, 0x61, 0x4f, 0x1e, 0xf5, 0xaa,
	0x17, 0xb7, 0xfc, 0x71, 0xf4, 0xec, 0xdf, 0xe0, 0xc1, 0xf2, 0x64, 0x79, 0xf0, 0x0f, 0xb0, 0xe2,
	0xd9, 0x2a, 0xcf, 0x9e, 0xac, 0x99, 0xf7, 0x20, 0x0f, 0x53, 0x5e, 0x92, 0xd7, 0x5f, 0xf7, 0xf4,
	0x74, 0x7f, 0xfd, 0xf5, 0x00, 0xe5, 0xf3, 0x60, 0x31, 0x31, 0x6f, 0xb9, 0xbf, 0x07, 0x33, 0x25,
	0x8d, 0x64, 0x59, 0x67, 0xd4, 0xbe, 0x21, 0xb0, 0x77, 0x8c, 0x18, 0x72, 0x9c, 0xb3, 0x1a, 0x64,
	0x39, 0xce, 0x4f, 0x67, 0x3e, 0xa9, 0x92, 0x46, 0xe9, 0x9e, 0x77, 0x10, 0xc7, 0x3b, 0x8c, 0xc7,
	0x2e, 0xb6, 0xef, 0x62, 0xba, 0x6d, 0x3f, 0x53, 0x25, 0x8d, 0x2c, 0x8f, 0x0d, 0x76, 0x00, 0xb9,
	0xd3, 0x19, 0x0a, 0x9b, 0xc8, 0x87, 0x2a, 0x69, 0x14, 0xee, 0xb1, 0xe4, 0xf0, 0x0a, 0xe6, 0x38,
	0xe7, 0xeb, 0x18, 0x76, 0x17, 0x72, 0x27, 0xf8, 0x69, 0x47, 0x18, 0xb5, 0xf4, 0xf7, 0x5d, 0x3c,
	0x24, 0xf1, 0x3d, 0x3d, 0xe6, 0x6b, 0x5f, 0xed, 0x77, 0x02, 0x85, 0x54, 0x06, 0xe6, 0xc7, 0xc5,
	0x0e, 0x78, 0xd7, 0x5d, 0x93, 0xe7, 0x2b, 0x93, 0xbd, 0x03, 0xd0, 0x37, 0x0a, 0x83, 0x69, 0x4f,
	0x86, 0xe8, 0x17, 0x5c, 0x03, 0xe5, 0x24, 0xe7, 0x95, 0x83, 0xa7, 0x82, 0x58, 0x15, 0x0a, 0x7d,
	0xc4, 0x67, 0xee, 0xa6, 0x6e, 0xdb, 0xf7, 0xaa, 0xa4, 0xe1, 0xf1, 0x34, 0xc4, 0x9a, 0x40, 0x7b,
	0xc1, 0x85, 0xb5, 0x22, 0xd4, 0x0f, 0x65, 0x1f, 0x45, 0xe8, 0x17, 0x5d, 0xdf, 0xd7, 0x70, 0x1b,
	0x6b, 0xff, 0x27, 0x47, 0xf5, 0xa9, 0x98, 0x2c, 0xfd, 0x52, 0x95, 0x34, 0x72, 0xfc, 0x1a, 0x5e,
	0x7b, 0x41, 0xa0, 0xe0, 0x80, 0x0f, 0x31, 0x08, 0x51, 0xd9, 0xb6, 0x56, 0x55, 0x10, 0x57, 0xc5,
	0xca, 0x64, 0xb7, 0x21, 0xd7, 0xc3, 0xe9, 0x13, 0x54, 0x09, 0xe3, 0x1e, 0x5f, 0xdb, 0xd6, 0x77,
	0x16, 0x28, 0x14, 0xa6, 0xdb, 0x76, 0x6c, 0x78, 0x7c, 0x6d, 0xb3, 0x0a, 0x80, 0x4b, 0xd1, 0x92,
	0x21, 0x0e, 0x1d, 0x1d, 0x79, 0x9e, 0x42, 0xd2, 0x44, 0xde, 0xd8, 0x20, 0xb2, 0xf6, 0x2b, 0x81,
	0xed, 0x9e, 0x1e, 0xb3, 0x3b, 0x90, 0xb9, 0xa6, 0x84, 0x9e, 0x1e, 0x9f, 0xce, 0x78, 0xe6, 0x7f,
	0x65, 0xf0, 0xde, 0x46, 0x5b, 0x7e, 0x6e, 0x43, 0x09, 0x29, 0x0f, 0xdf, 0xe8, 0x9e, 0xc1, 0xce,
	0x91, 0x0c, 0x97, 0x49, 0x0f, 0xee, 0x9b, 0x35, 0x60, 0xb7, 0x6f, 0x02, 0xb3, 0xd0, 0x89, 0x3c,
	0xe8, 0x95, 0x16, 0x63, 0x9c, 0x27, 0x7e, 0xf6, 0x1a, 0x6c, 0x77, 0x94, 0xf2, 0x2b, 0x2e, 0xac,
	0x78, 0x15, 0xd6, 0x51, 0x8a, 0x5b, 0x4f, 0xed, 0x27, 0x02, 0xf9, 0xf5, 0xb1, 0xab, 0xc2, 0x49,
	0xba, 0xf0, 0x37, 0x61, 0xc7, 0xf2, 0xe2, 0xba, 0x49, 0xeb, 0xc6, 0x1e, 0xb1, 0x0e, 0xee, 0xdc,
	0x8c, 0x3a, 0x6a, 0xfc, 0x6d, 0xc7, 0x98, 0x63, 0x29, 0x35, 0xb9, 0x9d, 0xcd, 0xc9, 0xdd, 0x85,
	0xd2, 0xd1, 0xd2, 0xa0, 0xe6, 0x38, 0x0d, 0x22, 0x11, 0x89, 0xb1, 0xeb, 0x6f, 0x9b, 0xff, 0x07,
	0x65, 0x6f, 0x40, 0xb1, 0x8f, 0xc3, 0x54, 0x58, 0xc1, 0x85, 0x6d, 0x82, 0xb5, 0xfb, 0xb0, 0x1b,
	0xf7, 0xc4, 0x6a, 0x49, 0xa9, 0xf1, 0x64, 0x4a, 0x2b, 0x72, 0x95, 0xba, 0x5e, 0x67, 0x66, 0x5d,
	0x67, 0x6d, 0x0a, 0x3b, 0x67, 0x88, 0x8a, 0xbd, 0x9e, 0x9a, 0xea, 0xcd, 0xe4, 0xac, 0x75, 0x0c,
	0x66, 0x61, 0x60, 0x30, 0x19, 0x6e, 0x09, 0x32, 0xc9, 0x64, 0xf3, 0x3c, 0xd3, 0x6d, 0xdb, 0x74,
	0x1f, 0xe1, 0xd2, 0xb5, 0xed, 0x71, 0xfb, 0x69, 0xe5, 0xd5, 0x5b, 0x4c, 0x4c, 0x14, 0x84, 0xa1,
	0xd2, 0x7e, 0xb6, 0xba, 0xdd, 0xf0, 0x78, 0x0a, 0x69, 0x1e, 0x41, 0xb6, 0x25, 0x85, 0x36, 0xac,
	0x08, 0x79, 0xf7, 0xd1, 0xc6, 0x91, 0xa6, 0x5b, 0xd6, 0x4c, 0xf8, 0xe9, 0x3f, 0xa7, 0x15, 0xf6,
	0x2a, 0xdc, 0x6a, 0xe3, 0xc8, 0x16, 0xf1, 0x40, 0xcd, 0x86, 0x7d, 0x54, 0xe7, 0xd1, 0x10, 0xcf,
	0xa4, 0x32, 0xf4, 0xe7, 0x46, 0xf3, 0x93, 0xe4, 0x35, 0x62, 0x14, 0xbc, 0xae, 0x38, 0x0f, 0x26,
	0x51, 0xbc, 0x44, 0x74, 0x8b, 0xdd, 0x80, 0xc2, 0xe1, 0x6c, 0xb6, 0xda, 0x2a, 0x4a, 0x18, 0x83,
	0x52, 0xeb, 0x69, 0x20, 0x04, 0x4e, 0x1e, 0xa0, 0x40, 0x1d, 0x69, 0x9a, 0x71, 0x57, 0x07, 0x62,
	0x88, 0x13, 0x8e, 0x73, 0x0a, 0xcc, 0xbb, 0x7a, 0xa2, 0x68, 0xa5, 0xf9, 0x31, 0x64, 0x9d, 0x98,
	0x6d, 0x94, 0x85, 0x52, 0x99, 0x39, 0xce, 0x5b, 0x72, 0x3a, 0x9b, 0xa0, 0x41, 0x4a, 0xec, 0xe5,
	0x1c, 0xe7, 0xed, 0x48, 0x0f, 0x03, 0x15, 0x62, 0x48, 0xb7, 0x59, 0x19, 0x8a, 0xc9, 0x73, 0x14,
	0xeb, 0x83, 0xee, 0x34, 0x9f, 0xa6, 0x1f, 0x1f, 0x56, 0x02, 0x68, 0x4b, 0x61, 0x62, 0x24, 0xce,
	0x79, 0xac, 0xe4, 0x74, 0x55, 0x19, 0x61, 0x05, 0xd8, 0x3b, 0x34, 0xf1, 0x8d, 0x3b, 0x36, 0xfa,
	0x70, 0x64, 0x50, 0xc5, 0x76, 0xd6, 0x16, 0xe4, 0x6c, 0xbb, 0x1c, 0x74, 0xcf, 0xd5, 0xa7, 0xe4,
	0xb4, 0x2b, 0x42, 0xbc, 0xa0, 0xf9, 0xe6, 0x0b, 0x62, 0xaf, 0x5a, 0xc9, 0xd2, 0x66, 0xea, 0x8a,
	0x91, 0xec, 0xe9, 0x31, 0xdd, 0xb2, 0x99, 0x1e, 0x07, 0xca, 0xca, 0xc5, 0xda, 0xee, 0x9a, 0xc7,
	0x52, 0x3d, 0x8b, 0xc4, 0x98, 0x7e, 0x60, 0xfb, 0x38, 0x8e, 0x44, 0x18, 0x89, 0xb1, 0x1d, 0xb7,
	0xa6, 0x87, 0xec, 0x25, 0x28, 0xb7, 0xa4, 0x10, 0x38, 0x34, 0x91, 0x18, 0x3f, 0x94, 0x31, 0x7c,
	0xc4, 0xf6, 0xed, 0x3b, 0x16, 0xa8, 0xe1, 0xd3, 0x48, 0x8c, 0x8f, 0xa5, 0x72, 0x7c, 0xb5, 0x2c,
	0xfa, 0x50, 0x05, 0x42, 0x8f, 0x50, 0x29, 0xeb, 0xb0, 0x68, 0x9b, 0x79, 0xb0, 0xd7, 0x37, 0xc1,
	0x64, 0x82, 0x21, 0xfd, 0x8c, 0x34, 0xff, 0x21, 0xb0, 0x97, 0xe8, 0x90, 0xe5, 0x21, 0x7b, 0x22,
	0x3b, 0x4a, 0xb9, 0xf6, 0x61, 0x20, 0x44, 0x30, 0xc5, 0xd0, 0xda, 0x9f, 0xd7, 0x19, 0x8d, 0x39,
	0x76, 0xb3, 0xc1, 0x90, 0x7e, 0x51, 0x67, 0x77, 0xe0, 0xe5, 0xae, 0xd0, 0x8b, 0xd1, 0x28, 0x1a,
	0x46, 0x28, 0xcc, 0x19, 0xaa, 0x69, 0xa4, 0x75, 0x24, 0x85, 0xa6, 0x7f, 0xad, 0xe2, 0x4f, 0xa4,
	0x39, 0x96, 0x0b, 0x11, 0xd2, 0x2f, 0xeb, 0xac, 0x08, 0x39, 0xbb, 0xb7, 0x62, 0xa0, 0x91, 0x7e,
	0x55, 0x67, 0x37, 0xa1, 0x94, 0x08, 0x24, 0x79, 0xc4, 0xe8, 0xb7, 0x75, 0x56, 0x06, 0xcf, 0x5a,
	0xeb, 0x63, 0xdf, 0xd5, 0xd9, 0x2d, 0x28, 0x5b, 0xe8, 0x70, 0xa2, 0x30, 0x08, 0x97, 0x9d, 0x8b,
	0x48, 0x1b, 0x4d, 0xbf, 0xaf, 0xb3, 0x57, 0x60, 0x7f, 0x20, 0x14, 0x0e, 0xe5, 0x58, 0x44, 0xcf,
	0x31, 0x7c, 0x64, 0x05, 0xd9, 0x32, 0x17, 0xf4, 0x87, 0x74, 0x6a, 0x8e, 0xf3, 0x05, 0x6a, 0x43,
	0x7f, 0xac, 0x33, 0x06, 0xc5, 0x76, 0x60, 0x82, 0x27, 0x81, 0xc6, 0x8e, 0x52, 0x52, 0xd1, 0xbf,
	0x0f, 0x9a, 0xf7, 0xc1, 0x4b, 0xef, 0x91, 0x25, 0xff, 0x44, 0x1a, 0x4b, 0x22, 0xdd, 0x62, 0x00,
	0xbb, 0x83, 0x99, 0x46, 0x65, 0x28, 0x58, 0xda, 0x39, 0x4e, 0xe5, 0x39, 0xda, 0x2e, 0x03, 0x81,
	0xc2, 0x4c, 0x96, 0x74, 0xff, 0xde, 0xfb, 0x90, 0x7f, 0xb4, 0x5a, 0x04, 0x76, 0x00, 0x9e, 0x33,
	0xfa, 0xe8, 0x58, 0x60, 0xab, 0x2d, 0x4f, 0x74, 0x77, 0x3b, 0xf5, 0x63, 0xd9, 0x20, 0x6f, 0x93,
	0x23, 0xfa, 0xcb, 0x65, 0x85, 0xfc, 0x76, 0x59, 0x21, 0x7f, 0x5c, 0x56, 0xc8, 0xd7, 0x7f, 0x56,
	0xb6, 0x9e, 0xec, 0xba, 0x1f, 0xf9, 0x77, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x32, 0xf0, 0x1a,
	0xc2, 0xf9, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// VaultGrpcClient is the client API for VaultGrpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VaultGrpcClient interface {
	// VaultSession offers a client service to a vault's feed repo.
	// The client submits requests to be executed, and the vault streams response msgs.
	// The session stream remains open as long as the client maintains its open.
	VaultSession(ctx context.Context, opts ...grpc.CallOption) (VaultGrpc_VaultSessionClient, error)
}

type vaultGrpcClient struct {
	cc *grpc.ClientConn
}

func NewVaultGrpcClient(cc *grpc.ClientConn) VaultGrpcClient {
	return &vaultGrpcClient{cc}
}

func (c *vaultGrpcClient) VaultSession(ctx context.Context, opts ...grpc.CallOption) (VaultGrpc_VaultSessionClient, error) {
	stream, err := c.cc.NewStream(ctx, &_VaultGrpc_serviceDesc.Streams[0], "/vault.VaultGrpc/VaultSession", opts...)
	if err != nil {
		return nil, err
	}
	x := &vaultGrpcVaultSessionClient{stream}
	return x, nil
}

type VaultGrpc_VaultSessionClient interface {
	Send(*FeedReq) error
	Recv() (*Msg, error)
	grpc.ClientStream
}

type vaultGrpcVaultSessionClient struct {
	grpc.ClientStream
}

func (x *vaultGrpcVaultSessionClient) Send(m *FeedReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *vaultGrpcVaultSessionClient) Recv() (*Msg, error) {
	m := new(Msg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// VaultGrpcServer is the server API for VaultGrpc service.
type VaultGrpcServer interface {
	// VaultSession offers a client service to a vault's feed repo.
	// The client submits requests to be executed, and the vault streams response msgs.
	// The session stream remains open as long as the client maintains its open.
	VaultSession(VaultGrpc_VaultSessionServer) error
}

// UnimplementedVaultGrpcServer can be embedded to have forward compatible implementations.
type UnimplementedVaultGrpcServer struct {
}

func (*UnimplementedVaultGrpcServer) VaultSession(srv VaultGrpc_VaultSessionServer) error {
	return status.Errorf(codes.Unimplemented, "method VaultSession not implemented")
}

func RegisterVaultGrpcServer(s *grpc.Server, srv VaultGrpcServer) {
	s.RegisterService(&_VaultGrpc_serviceDesc, srv)
}

func _VaultGrpc_VaultSession_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(VaultGrpcServer).VaultSession(&vaultGrpcVaultSessionServer{stream})
}

type VaultGrpc_VaultSessionServer interface {
	Send(*Msg) error
	Recv() (*FeedReq, error)
	grpc.ServerStream
}

type vaultGrpcVaultSessionServer struct {
	grpc.ServerStream
}

func (x *vaultGrpcVaultSessionServer) Send(m *Msg) error {
	return x.ServerStream.SendMsg(m)
}

func (x *vaultGrpcVaultSessionServer) Recv() (*FeedReq, error) {
	m := new(FeedReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _VaultGrpc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "vault.VaultGrpc",
	HandlerType: (*VaultGrpcServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "VaultSession",
			Handler:       _VaultGrpc_VaultSession_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "vault/vault.proto",
}

func (m *FeedReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeedReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeedReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NewEntry != nil {
		{
			size, err := m.NewEntry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVault(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.OpenFeed != nil {
		{
			size, err := m.OpenFeed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVault(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ReqID != 0 {
		i = encodeVarintVault(dAtA, i, uint64(m.ReqID))
		i--
		dAtA[i] = 0x10
	}
	if m.ReqOp != 0 {
		i = encodeVarintVault(dAtA, i, uint64(m.ReqOp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OpenFeedReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenFeedReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenFeedReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SendEntryIDsOnly {
		i--
		if m.SendEntryIDsOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.MaxEntriesToSend != 0 {
		i = encodeVarintVault(dAtA, i, uint64(m.MaxEntriesToSend))
		i--
		dAtA[i] = 0x68
	}
	if len(m.SeekEntryID) > 0 {
		i -= len(m.SeekEntryID)
		copy(dAtA[i:], m.SeekEntryID)
		i = encodeVarintVault(dAtA, i, uint64(len(m.SeekEntryID)))
		i--
		dAtA[i] = 0x62
	}
	if m.StreamMode != 0 {
		i = encodeVarintVault(dAtA, i, uint64(m.StreamMode))
		i--
		dAtA[i] = 0x58
	}
	if len(m.FeedURI) > 0 {
		i -= len(m.FeedURI)
		copy(dAtA[i:], m.FeedURI)
		i = encodeVarintVault(dAtA, i, uint64(len(m.FeedURI)))
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}

func (m *EntryHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntryHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntryHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FeedURI) > 0 {
		i -= len(m.FeedURI)
		copy(dAtA[i:], m.FeedURI)
		i = encodeVarintVault(dAtA, i, uint64(len(m.FeedURI)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.EntryCodec) > 0 {
		i -= len(m.EntryCodec)
		copy(dAtA[i:], m.EntryCodec)
		i = encodeVarintVault(dAtA, i, uint64(len(m.EntryCodec)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ParentID) > 0 {
		i -= len(m.ParentID)
		copy(dAtA[i:], m.ParentID)
		i = encodeVarintVault(dAtA, i, uint64(len(m.ParentID)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.MemberID) > 0 {
		i -= len(m.MemberID)
		copy(dAtA[i:], m.MemberID)
		i = encodeVarintVault(dAtA, i, uint64(len(m.MemberID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EntryID) > 0 {
		i -= len(m.EntryID)
		copy(dAtA[i:], m.EntryID)
		i = encodeVarintVault(dAtA, i, uint64(len(m.EntryID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Msg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Msg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVault(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVault(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintVault(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x52
	}
	if m.EntryHeader != nil {
		{
			size, err := m.EntryHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVault(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.ReqID != 0 {
		i = encodeVarintVault(dAtA, i, uint64(m.ReqID))
		i--
		dAtA[i] = 0x10
	}
	if m.Op != 0 {
		i = encodeVarintVault(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReqStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReqStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SecsRemaining != 0 {
		i = encodeVarintVault(dAtA, i, uint64(m.SecsRemaining))
		i--
		dAtA[i] = 0x58
	}
	if m.BytesRemaining != 0 {
		i = encodeVarintVault(dAtA, i, uint64(m.BytesRemaining))
		i--
		dAtA[i] = 0x50
	}
	if len(m.EntryID) > 0 {
		i -= len(m.EntryID)
		copy(dAtA[i:], m.EntryID)
		i = encodeVarintVault(dAtA, i, uint64(len(m.EntryID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintVault(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintVault(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.ReqID != 0 {
		i = encodeVarintVault(dAtA, i, uint64(m.ReqID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReqErr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqErr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReqErr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintVault(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintVault(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Peer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Peer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Peer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Multiaddrs) > 0 {
		for iNdEx := len(m.Multiaddrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Multiaddrs[iNdEx])
			copy(dAtA[i:], m.Multiaddrs[iNdEx])
			i = encodeVarintVault(dAtA, i, uint64(len(m.Multiaddrs[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintVault(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintVault(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Op != 0 {
		i = encodeVarintVault(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintVault(dAtA []byte, offset int, v uint64) int {
	offset -= sovVault(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FeedReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReqOp != 0 {
		n += 1 + sovVault(uint64(m.ReqOp))
	}
	if m.ReqID != 0 {
		n += 1 + sovVault(uint64(m.ReqID))
	}
	if m.OpenFeed != nil {
		l = m.OpenFeed.Size()
		n += 1 + l + sovVault(uint64(l))
	}
	if m.NewEntry != nil {
		l = m.NewEntry.Size()
		n += 2 + l + sovVault(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OpenFeedReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FeedURI)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	if m.StreamMode != 0 {
		n += 1 + sovVault(uint64(m.StreamMode))
	}
	l = len(m.SeekEntryID)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	if m.MaxEntriesToSend != 0 {
		n += 1 + sovVault(uint64(m.MaxEntriesToSend))
	}
	if m.SendEntryIDsOnly {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EntryHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EntryID)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	l = len(m.MemberID)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	l = len(m.ParentID)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	l = len(m.EntryCodec)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	l = len(m.FeedURI)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Msg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovVault(uint64(m.Op))
	}
	if m.ReqID != 0 {
		n += 1 + sovVault(uint64(m.ReqID))
	}
	if m.EntryHeader != nil {
		l = m.EntryHeader.Size()
		n += 1 + l + sovVault(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 2 + l + sovVault(uint64(l))
	}
	if m.Err != nil {
		l = m.Err.Size()
		n += 2 + l + sovVault(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReqStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReqID != 0 {
		n += 1 + sovVault(uint64(m.ReqID))
	}
	if m.Code != 0 {
		n += 1 + sovVault(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	l = len(m.EntryID)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	if m.BytesRemaining != 0 {
		n += 1 + sovVault(uint64(m.BytesRemaining))
	}
	if m.SecsRemaining != 0 {
		n += 1 + sovVault(uint64(m.SecsRemaining))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReqErr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovVault(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Peer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovVault(uint64(m.Op))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovVault(uint64(l))
	}
	if len(m.Multiaddrs) > 0 {
		for _, b := range m.Multiaddrs {
			l = len(b)
			n += 1 + l + sovVault(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovVault(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozVault(x uint64) (n int) {
	return sovVault(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FeedReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeedReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeedReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqOp", wireType)
			}
			m.ReqOp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqOp |= ReqOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqID", wireType)
			}
			m.ReqID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenFeed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenFeed == nil {
				m.OpenFeed = &OpenFeedReq{}
			}
			if err := m.OpenFeed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewEntry == nil {
				m.NewEntry = &Msg{}
			}
			if err := m.NewEntry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenFeedReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenFeedReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenFeedReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeedURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeedURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamMode", wireType)
			}
			m.StreamMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamMode |= StreamMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeekEntryID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeekEntryID = append(m.SeekEntryID[:0], dAtA[iNdEx:postIndex]...)
			if m.SeekEntryID == nil {
				m.SeekEntryID = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxEntriesToSend", wireType)
			}
			m.MaxEntriesToSend = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxEntriesToSend |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendEntryIDsOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendEntryIDsOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntryHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntryHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntryHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntryID = append(m.EntryID[:0], dAtA[iNdEx:postIndex]...)
			if m.EntryID == nil {
				m.EntryID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MemberID = append(m.MemberID[:0], dAtA[iNdEx:postIndex]...)
			if m.MemberID == nil {
				m.MemberID = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentID = append(m.ParentID[:0], dAtA[iNdEx:postIndex]...)
			if m.ParentID == nil {
				m.ParentID = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryCodec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntryCodec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeedURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeedURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Msg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Msg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Msg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= MsgOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqID", wireType)
			}
			m.ReqID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EntryHeader == nil {
				m.EntryHeader = &EntryHeader{}
			}
			if err := m.EntryHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &ReqStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ReqErr{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqID", wireType)
			}
			m.ReqID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntryID = append(m.EntryID[:0], dAtA[iNdEx:postIndex]...)
			if m.EntryID == nil {
				m.EntryID = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRemaining", wireType)
			}
			m.BytesRemaining = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesRemaining |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecsRemaining", wireType)
			}
			m.SecsRemaining = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecsRemaining |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqErr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqErr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqErr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= ErrCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Peer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Peer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Peer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= PeerUpdateOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiaddrs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVault
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Multiaddrs = append(m.Multiaddrs, make([]byte, postIndex-iNdEx))
			copy(m.Multiaddrs[len(m.Multiaddrs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVault(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVault
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVault
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVault
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthVault
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupVault
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthVault
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthVault        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVault          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupVault = fmt.Errorf("proto: unexpected end of group")
)
