// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ski/ski.proto

package ski

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// KeyType identifies how a key operates
type KeyType int32

const (
	KeyType_Unspecified   KeyType = 0
	KeyType_SymmetricKey  KeyType = 1
	KeyType_AsymmetricKey KeyType = 2
	KeyType_SigningKey    KeyType = 3
)

var KeyType_name = map[int32]string{
	0: "Unspecified",
	1: "SymmetricKey",
	2: "AsymmetricKey",
	3: "SigningKey",
}

var KeyType_value = map[string]int32{
	"Unspecified":   0,
	"SymmetricKey":  1,
	"AsymmetricKey": 2,
	"SigningKey":    3,
}

func (x KeyType) String() string {
	return proto.EnumName(KeyType_name, int32(x))
}

func (KeyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{0}
}

// CryptoKitID identifies an encryption suite that implements ski.CryptoKit
type CryptoKitID int32

const (
	CryptoKitID_UnspecifiedCrypto CryptoKitID = 0
	CryptoKitID_NaCl              CryptoKitID = 1
	CryptoKitID_ED25519           CryptoKitID = 2
)

var CryptoKitID_name = map[int32]string{
	0: "UnspecifiedCrypto",
	1: "NaCl",
	2: "ED25519",
}

var CryptoKitID_value = map[string]int32{
	"UnspecifiedCrypto": 0,
	"NaCl":              1,
	"ED25519":           2,
}

func (x CryptoKitID) String() string {
	return proto.EnumName(CryptoKitID_name, int32(x))
}

func (CryptoKitID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{1}
}

// CryptoKitID identifies a hash algorithm that implements ski.HaskKit
type HashKitID int32

const (
	HashKitID_UnspecifiedHashKit HashKitID = 0
	HashKitID_LegacyKeccak_256   HashKitID = 1
	HashKitID_LegacyKeccak_512   HashKitID = 2
	HashKitID_SHA3_256           HashKitID = 3
	HashKitID_SHA3_512           HashKitID = 4
	HashKitID_Blake2b_256        HashKitID = 5
	HashKitID_Blake2b_512        HashKitID = 6
)

var HashKitID_name = map[int32]string{
	0: "UnspecifiedHashKit",
	1: "LegacyKeccak_256",
	2: "LegacyKeccak_512",
	3: "SHA3_256",
	4: "SHA3_512",
	5: "Blake2b_256",
	6: "Blake2b_512",
}

var HashKitID_value = map[string]int32{
	"UnspecifiedHashKit": 0,
	"LegacyKeccak_256":   1,
	"LegacyKeccak_512":   2,
	"SHA3_256":           3,
	"SHA3_512":           4,
	"Blake2b_256":        5,
	"Blake2b_512":        6,
}

func (x HashKitID) String() string {
	return proto.EnumName(HashKitID_name, int32(x))
}

func (HashKitID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{2}
}

type CryptOp int32

const (
	// Generates a signature for BufIn using the referenced signing key, placing the signature into BufOut.
	CryptOp_Sign CryptOp = 0
	// Inverse of DecryptSym
	// Encrypts BufIn using the symmetric key referenced by OpKey.
	CryptOp_EncryptSym CryptOp = 1
	// Inverse of EncryptSym
	// Decrypts BufIn using the symmetric key referenced by OpKey.
	CryptOp_DecryptSym CryptOp = 2
	// Encrypts BufIn for a recipient holding the private key associated with the pub key contained in PeerKey,
	//    encrypting using the referenced asymmetric key and placing the encrypted result into BufOut.
	CryptOp_EncryptToPeer CryptOp = 3
	// Decrypts BufIn from a sender holding the private key associated with the pub key contained in PeerKey,
	//    decrypting using the referenced asymmetric key and placing the decrypted result into BufOut.
	CryptOp_DecryptFromPeer CryptOp = 4
	// Inverse of ExportUsingPw
	// Identical to ImportFromPeer except that BufIn is instead decrypted via CryptoKit.DecryptUsingPassword(),
	//    using CryptOp.PeerKey as a the password.  The CryptoKit invoked is determined by CryptOpArgs.DefaultCryptoKit.
	CryptOp_ImportUsingPw CryptOp = 5
	// Inverse of ImportUsingPw
	// Identical to ExportToPeer except the output serialized KeyTome is encrypted via CryptoKit.EncryptUsingPassword(),
	//    using CryptOp.PeerKey as a the password.  The CryptoKit invoked is determined by CryptOpArgs.DefaultCryptoKit.
	CryptOp_ExportUsingPw CryptOp = 6
	// Inverse of ExportToPeer
	// First, performs as DecryptFromPeer.
	// The result/output buf is then unmarshalled (assumed to be a ski.KeyTome protobuf) and is merged into the host KeyTome.
	// See ski.ImportKeys() for how the incoming KeyTome is merged into the host KeyTome.
	CryptOp_ImportFromPeer CryptOp = 7
	// Inverse of ImportFromPeer
	// For each entry in CryptOpArgs.TomeIn, PubKey is used to lookup a corresponding KeyEntry in the host KeyTome.
	// Each KeyEntry with a matching PubKey is copied into a new temp KeyTome, into the appropriate Keyring,
	//    creating a Keyring if it does not yet exist.
	// If a Keyring appears in CryptOpArgs.TomeIn but contains no entries, the entire Keyring will be exported.
	// If a Keyring or KeyEntry from TomeIn isn't found, an error is returned.
	// See KeyTome.ExportUsingGuide() for how TomeIn is handled.
	// On completion, the temp KeyTome is serialized, assigned to CryptOpArgs.BufIn, and EncryptToPeer is executed.
	CryptOp_ExportToPeer CryptOp = 8
)

var CryptOp_name = map[int32]string{
	0: "Sign",
	1: "EncryptSym",
	2: "DecryptSym",
	3: "EncryptToPeer",
	4: "DecryptFromPeer",
	5: "ImportUsingPw",
	6: "ExportUsingPw",
	7: "ImportFromPeer",
	8: "ExportToPeer",
}

var CryptOp_value = map[string]int32{
	"Sign":            0,
	"EncryptSym":      1,
	"DecryptSym":      2,
	"EncryptToPeer":   3,
	"DecryptFromPeer": 4,
	"ImportUsingPw":   5,
	"ExportUsingPw":   6,
	"ImportFromPeer":  7,
	"ExportToPeer":    8,
}

func (x CryptOp) String() string {
	return proto.EnumName(CryptOp_name, int32(x))
}

func (CryptOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{3}
}

// ErrCode expresses status and error codes.
type ErrCode int32

const (
	ErrCode_NoErr                      ErrCode = 0
	ErrCode_Unimplemented              ErrCode = 4999
	ErrCode_UnnamedErr                 ErrCode = 5000
	ErrCode_InternalErr                ErrCode = 5001
	ErrCode_AssertFailed               ErrCode = 5020
	ErrCode_CryptoKitAlreadyRegistered ErrCode = 8001
	ErrCode_UnrecognizedCryptoKit      ErrCode = 8002
	ErrCode_DecryptFailed              ErrCode = 8007
	ErrCode_VerifySignatureFailed      ErrCode = 8008
	ErrCode_BadKeyFormat               ErrCode = 8009
	ErrCode_KeyGenerationFailed        ErrCode = 8010
	ErrCode_KeyringNotFound            ErrCode = 8011
	ErrCode_KeyEntryNotFound           ErrCode = 8012
	ErrCode_HashKitNotFound            ErrCode = 8013
	ErrCode_SessionNotReady            ErrCode = 8020
	ErrCode_UnrecognizedCryptOp        ErrCode = 8021
	ErrCode_MarshalFailed              ErrCode = 8030
	ErrCode_UnmarshalFailed            ErrCode = 8031
	ErrCode_KeyHiveFailedToLoad        ErrCode = 8040
	ErrCode_KeyTomeFailedToSave        ErrCode = 8041
)

var ErrCode_name = map[int32]string{
	0:    "NoErr",
	4999: "Unimplemented",
	5000: "UnnamedErr",
	5001: "InternalErr",
	5020: "AssertFailed",
	8001: "CryptoKitAlreadyRegistered",
	8002: "UnrecognizedCryptoKit",
	8007: "DecryptFailed",
	8008: "VerifySignatureFailed",
	8009: "BadKeyFormat",
	8010: "KeyGenerationFailed",
	8011: "KeyringNotFound",
	8012: "KeyEntryNotFound",
	8013: "HashKitNotFound",
	8020: "SessionNotReady",
	8021: "UnrecognizedCryptOp",
	8030: "MarshalFailed",
	8031: "UnmarshalFailed",
	8040: "KeyHiveFailedToLoad",
	8041: "KeyTomeFailedToSave",
}

var ErrCode_value = map[string]int32{
	"NoErr":                      0,
	"Unimplemented":              4999,
	"UnnamedErr":                 5000,
	"InternalErr":                5001,
	"AssertFailed":               5020,
	"CryptoKitAlreadyRegistered": 8001,
	"UnrecognizedCryptoKit":      8002,
	"DecryptFailed":              8007,
	"VerifySignatureFailed":      8008,
	"BadKeyFormat":               8009,
	"KeyGenerationFailed":        8010,
	"KeyringNotFound":            8011,
	"KeyEntryNotFound":           8012,
	"HashKitNotFound":            8013,
	"SessionNotReady":            8020,
	"UnrecognizedCryptOp":        8021,
	"MarshalFailed":              8030,
	"UnmarshalFailed":            8031,
	"KeyHiveFailedToLoad":        8040,
	"KeyTomeFailedToSave":        8041,
}

func (x ErrCode) String() string {
	return proto.EnumName(ErrCode_name, int32(x))
}

func (ErrCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{4}
}

type CryptOpArgs struct {
	// Specifies which op to invoke for these given set of args
	CryptOp CryptOp `protobuf:"varint,1,opt,name=CryptOp,proto3,enum=ski.CryptOp" json:"CryptOp,omitempty"`
	// Specifies the default CryptoKit for ops when not specified.
	DefaultCryptoKit CryptoKitID `protobuf:"varint,2,opt,name=DefaultCryptoKit,proto3,enum=ski.CryptoKitID" json:"DefaultCryptoKit,omitempty"`
	// The source/input buffer that is signed/encrypted/decrypted.
	BufIn []byte `protobuf:"bytes,3,opt,name=BufIn,proto3" json:"BufIn,omitempty"`
	// A reference to an existing KeyEntry in the host's KeyTome used as the key for this op's encryption/decryption.
	OpKey *KeyRef `protobuf:"bytes,4,opt,name=OpKey,proto3" json:"OpKey,omitempty"`
	// For EncryptToPeer and ExportToPeer, this is what the recipient will use for OpKey.PubKey.
	// For DecryptFromPeer and ImportFromPeer, this is what the sender used for OpKey.PubKey.
	// For ImportUsingPw and ExportUsingPw, this is the password.
	PeerKey []byte `protobuf:"bytes,5,opt,name=PeerKey,proto3" json:"PeerKey,omitempty"`
	// Keyring and key info used to identify existing (or to-be-created) keys in the host's KeyTome.
	// Used for ExportToPeer and GenerateKeys().
	TomeIn               *KeyTome `protobuf:"bytes,6,opt,name=TomeIn,proto3" json:"TomeIn,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CryptOpArgs) Reset()         { *m = CryptOpArgs{} }
func (m *CryptOpArgs) String() string { return proto.CompactTextString(m) }
func (*CryptOpArgs) ProtoMessage()    {}
func (*CryptOpArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{0}
}
func (m *CryptOpArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CryptOpArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CryptOpArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CryptOpArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CryptOpArgs.Merge(m, src)
}
func (m *CryptOpArgs) XXX_Size() int {
	return m.Size()
}
func (m *CryptOpArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_CryptOpArgs.DiscardUnknown(m)
}

var xxx_messageInfo_CryptOpArgs proto.InternalMessageInfo

func (m *CryptOpArgs) GetCryptOp() CryptOp {
	if m != nil {
		return m.CryptOp
	}
	return CryptOp_Sign
}

func (m *CryptOpArgs) GetDefaultCryptoKit() CryptoKitID {
	if m != nil {
		return m.DefaultCryptoKit
	}
	return CryptoKitID_UnspecifiedCrypto
}

func (m *CryptOpArgs) GetBufIn() []byte {
	if m != nil {
		return m.BufIn
	}
	return nil
}

func (m *CryptOpArgs) GetOpKey() *KeyRef {
	if m != nil {
		return m.OpKey
	}
	return nil
}

func (m *CryptOpArgs) GetPeerKey() []byte {
	if m != nil {
		return m.PeerKey
	}
	return nil
}

func (m *CryptOpArgs) GetTomeIn() *KeyTome {
	if m != nil {
		return m.TomeIn
	}
	return nil
}

type CryptOpOut struct {
	// Output buf from the given crypto op (and depends on the given CryptOp)
	BufOut []byte `protobuf:"bytes,1,opt,name=BufOut,proto3" json:"BufOut,omitempty"`
	// Returns the pub key used in the op (needed when CryptOpArgs.OpKey.PubKey wasn't specified)
	OpPubKey             []byte   `protobuf:"bytes,2,opt,name=OpPubKey,proto3" json:"OpPubKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CryptOpOut) Reset()         { *m = CryptOpOut{} }
func (m *CryptOpOut) String() string { return proto.CompactTextString(m) }
func (*CryptOpOut) ProtoMessage()    {}
func (*CryptOpOut) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{1}
}
func (m *CryptOpOut) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CryptOpOut) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CryptOpOut.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CryptOpOut) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CryptOpOut.Merge(m, src)
}
func (m *CryptOpOut) XXX_Size() int {
	return m.Size()
}
func (m *CryptOpOut) XXX_DiscardUnknown() {
	xxx_messageInfo_CryptOpOut.DiscardUnknown(m)
}

var xxx_messageInfo_CryptOpOut proto.InternalMessageInfo

func (m *CryptOpOut) GetBufOut() []byte {
	if m != nil {
		return m.BufOut
	}
	return nil
}

func (m *CryptOpOut) GetOpPubKey() []byte {
	if m != nil {
		return m.OpPubKey
	}
	return nil
}

// KeyInfo specifies info an existing KeyEntry or and KeyEntry this is to be created.
//
// KeyInfo exists in two modes/uses:
//    1) Generated/copied from an existing KeyEntry
//    2) Key gen mode: used as a guide to generate a new key
//         a) Fields used: KeyType and CryptoKitID (other fields ignored)
type KeyInfo struct {
	// Specifies the type of key this is (optional)
	KeyType KeyType `protobuf:"varint,1,opt,name=KeyType,proto3,enum=ski.KeyType" json:"KeyType,omitempty"`
	// Specifies which crypto suite to invoke.
	CryptoKitID CryptoKitID `protobuf:"varint,2,opt,name=CryptoKitID,proto3,enum=ski.CryptoKitID" json:"CryptoKitID,omitempty"`
	// Unix timestamp << 16 (TimeFS) when this key was created (or 0 if not set)
	TimeCreated int64 `protobuf:"varint,3,opt,name=TimeCreated,proto3" json:"TimeCreated,omitempty"`
	// Public part of the key; how this key is also referenced publicly (in base-256 form)
	PubKey               []byte   `protobuf:"bytes,4,opt,name=PubKey,proto3" json:"PubKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyInfo) Reset()         { *m = KeyInfo{} }
func (m *KeyInfo) String() string { return proto.CompactTextString(m) }
func (*KeyInfo) ProtoMessage()    {}
func (*KeyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{2}
}
func (m *KeyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyInfo.Merge(m, src)
}
func (m *KeyInfo) XXX_Size() int {
	return m.Size()
}
func (m *KeyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_KeyInfo proto.InternalMessageInfo

func (m *KeyInfo) GetKeyType() KeyType {
	if m != nil {
		return m.KeyType
	}
	return KeyType_Unspecified
}

func (m *KeyInfo) GetCryptoKitID() CryptoKitID {
	if m != nil {
		return m.CryptoKitID
	}
	return CryptoKitID_UnspecifiedCrypto
}

func (m *KeyInfo) GetTimeCreated() int64 {
	if m != nil {
		return m.TimeCreated
	}
	return 0
}

func (m *KeyInfo) GetPubKey() []byte {
	if m != nil {
		return m.PubKey
	}
	return nil
}

type KeyRef struct {
	// Specifies the Keyring that the key resides on (required when referencing a KeyEntry in a KeyTome).
	KeyringName []byte `protobuf:"bytes,1,opt,name=KeyringName,proto3" json:"KeyringName,omitempty"`
	// The pub key of the key being referenced (or len()==0 to imply the newest key in the cited keyring).
	// Note that the complete pub key isn't required, just a sufficiently long matching prefix (typically 16-64 bytes).
	PubKey               []byte   `protobuf:"bytes,2,opt,name=PubKey,proto3" json:"PubKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyRef) Reset()         { *m = KeyRef{} }
func (m *KeyRef) String() string { return proto.CompactTextString(m) }
func (*KeyRef) ProtoMessage()    {}
func (*KeyRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{3}
}
func (m *KeyRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyRef.Merge(m, src)
}
func (m *KeyRef) XXX_Size() int {
	return m.Size()
}
func (m *KeyRef) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyRef.DiscardUnknown(m)
}

var xxx_messageInfo_KeyRef proto.InternalMessageInfo

func (m *KeyRef) GetKeyringName() []byte {
	if m != nil {
		return m.KeyringName
	}
	return nil
}

func (m *KeyRef) GetPubKey() []byte {
	if m != nil {
		return m.PubKey
	}
	return nil
}

// KeyEntry is used in 3 ways:
//    1) Storage/Export mode: used to store all fields of a fully generated key
//         - KeyEntry.PrivKey != nil
//    2) Ref/Spec mode: used to reference an existing key somewhere else
//         - KeyEntry.PrivKey == nil
//         - Fields used: KeyInfo.PubKey (other fields ignored)
//    3) GenerateKeys "guide" mode: KeyInfo used as a guide to generate a new key
//         - Fields used: KeyInfo.KeyType and KeyInfo.CryptoKitID (other fields ignored)
type KeyEntry struct {
	// Info about this key
	KeyInfo *KeyInfo `protobuf:"bytes,1,opt,name=KeyInfo,proto3" json:"KeyInfo,omitempty"`
	// Private part of the key -- should be used and copied carefully.
	// When a KeyEntry is used to reference/specify an existing key, this field is not set and/or is ignored.
	PrivKey              []byte   `protobuf:"bytes,6,opt,name=PrivKey,proto3" json:"PrivKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyEntry) Reset()         { *m = KeyEntry{} }
func (m *KeyEntry) String() string { return proto.CompactTextString(m) }
func (*KeyEntry) ProtoMessage()    {}
func (*KeyEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{4}
}
func (m *KeyEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyEntry.Merge(m, src)
}
func (m *KeyEntry) XXX_Size() int {
	return m.Size()
}
func (m *KeyEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyEntry.DiscardUnknown(m)
}

var xxx_messageInfo_KeyEntry proto.InternalMessageInfo

func (m *KeyEntry) GetKeyInfo() *KeyInfo {
	if m != nil {
		return m.KeyInfo
	}
	return nil
}

func (m *KeyEntry) GetPrivKey() []byte {
	if m != nil {
		return m.PrivKey
	}
	return nil
}

type Keyring struct {
	// Any binary name for this Keyring (except a zero-length name).
	Name []byte `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	// Ordered list of KeyEntry (potentially sorted by KeyInfo.PubKey)
	Keys []*KeyEntry `protobuf:"bytes,2,rep,name=Keys,proto3" json:"Keys,omitempty"`
	// If set, []Keys is sorted by KeyInfo.PubKey via ski.CompareEntries()
	SortedByPubKey bool `protobuf:"varint,3,opt,name=SortedByPubKey,proto3" json:"SortedByPubKey,omitempty"`
	// PubKey of the KeyEntry in this keyring that has the largest TimeCreated (or nil if not known/determined)
	NewestPubKey         []byte   `protobuf:"bytes,4,opt,name=NewestPubKey,proto3" json:"NewestPubKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Keyring) Reset()         { *m = Keyring{} }
func (m *Keyring) String() string { return proto.CompactTextString(m) }
func (*Keyring) ProtoMessage()    {}
func (*Keyring) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{5}
}
func (m *Keyring) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Keyring) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Keyring.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Keyring) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Keyring.Merge(m, src)
}
func (m *Keyring) XXX_Size() int {
	return m.Size()
}
func (m *Keyring) XXX_DiscardUnknown() {
	xxx_messageInfo_Keyring.DiscardUnknown(m)
}

var xxx_messageInfo_Keyring proto.InternalMessageInfo

func (m *Keyring) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *Keyring) GetKeys() []*KeyEntry {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Keyring) GetSortedByPubKey() bool {
	if m != nil {
		return m.SortedByPubKey
	}
	return false
}

func (m *Keyring) GetNewestPubKey() []byte {
	if m != nil {
		return m.NewestPubKey
	}
	return nil
}

type KeyTome struct {
	// Incremented each time this KeyTome is altered.
	Rev int64 `protobuf:"varint,1,opt,name=Rev,proto3" json:"Rev,omitempty"`
	// Ordered list of Keyrings (potentially sorted by Keyring.Name)
	Keyrings []*Keyring `protobuf:"bytes,2,rep,name=Keyrings,proto3" json:"Keyrings,omitempty"`
	// If set, []Keyrings is sorted by Keyring.Name via bytes.Compare()
	SortedByName         bool     `protobuf:"varint,3,opt,name=SortedByName,proto3" json:"SortedByName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyTome) Reset()         { *m = KeyTome{} }
func (m *KeyTome) String() string { return proto.CompactTextString(m) }
func (*KeyTome) ProtoMessage()    {}
func (*KeyTome) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{6}
}
func (m *KeyTome) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyTome) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyTome.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyTome) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyTome.Merge(m, src)
}
func (m *KeyTome) XXX_Size() int {
	return m.Size()
}
func (m *KeyTome) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyTome.DiscardUnknown(m)
}

var xxx_messageInfo_KeyTome proto.InternalMessageInfo

func (m *KeyTome) GetRev() int64 {
	if m != nil {
		return m.Rev
	}
	return 0
}

func (m *KeyTome) GetKeyrings() []*Keyring {
	if m != nil {
		return m.Keyrings
	}
	return nil
}

func (m *KeyTome) GetSortedByName() bool {
	if m != nil {
		return m.SortedByName
	}
	return false
}

type SigHeader struct {
	// References a signing key -- who and what crypto kit signed the payload header.
	SignerCryptoKit CryptoKitID `protobuf:"varint,1,opt,name=SignerCryptoKit,proto3,enum=ski.CryptoKitID" json:"SignerCryptoKit,omitempty"`
	SignerPubKey    []byte      `protobuf:"bytes,2,opt,name=SignerPubKey,proto3" json:"SignerPubKey,omitempty"`
	// Specifies which hash kit to use to perform payload hashing
	HashKitID HashKitID `protobuf:"varint,6,opt,name=HashKitID,proto3,enum=ski.HashKitID" json:"HashKitID,omitempty"`
	// Size of the "header" payload (i.e. the payload that is also hashed and signed)
	HeaderSz uint32 `protobuf:"varint,7,opt,name=HeaderSz,proto3" json:"HeaderSz,omitempty"`
	// HeaderCodec allows the client store/signal how it should be unmarshalled or handled.
	HeaderCodec uint32 `protobuf:"varint,8,opt,name=HeaderCodec,proto3" json:"HeaderCodec,omitempty"`
	// Size of the "body" payload (i.e. the payload that is NOT hashed signed)
	BodySz               uint64   `protobuf:"varint,9,opt,name=BodySz,proto3" json:"BodySz,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SigHeader) Reset()         { *m = SigHeader{} }
func (m *SigHeader) String() string { return proto.CompactTextString(m) }
func (*SigHeader) ProtoMessage()    {}
func (*SigHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{7}
}
func (m *SigHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SigHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SigHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SigHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigHeader.Merge(m, src)
}
func (m *SigHeader) XXX_Size() int {
	return m.Size()
}
func (m *SigHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_SigHeader.DiscardUnknown(m)
}

var xxx_messageInfo_SigHeader proto.InternalMessageInfo

func (m *SigHeader) GetSignerCryptoKit() CryptoKitID {
	if m != nil {
		return m.SignerCryptoKit
	}
	return CryptoKitID_UnspecifiedCrypto
}

func (m *SigHeader) GetSignerPubKey() []byte {
	if m != nil {
		return m.SignerPubKey
	}
	return nil
}

func (m *SigHeader) GetHashKitID() HashKitID {
	if m != nil {
		return m.HashKitID
	}
	return HashKitID_UnspecifiedHashKit
}

func (m *SigHeader) GetHeaderSz() uint32 {
	if m != nil {
		return m.HeaderSz
	}
	return 0
}

func (m *SigHeader) GetHeaderCodec() uint32 {
	if m != nil {
		return m.HeaderCodec
	}
	return 0
}

func (m *SigHeader) GetBodySz() uint64 {
	if m != nil {
		return m.BodySz
	}
	return 0
}

type KeyTomeCrypt struct {
	// A serialized ski.KeyTome encrypted in accordance with the accompanying key params
	Tome []byte `protobuf:"bytes,1,opt,name=Tome,proto3" json:"Tome,omitempty"`
	// Optional -- used to identify how (or with what key) the KeyTome in KeyTomeCrypt.Tpme is encrypted.
	KeyRef               *KeyRef  `protobuf:"bytes,10,opt,name=KeyRef,proto3" json:"KeyRef,omitempty"`
	KeyInfo              *KeyInfo `protobuf:"bytes,11,opt,name=KeyInfo,proto3" json:"KeyInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyTomeCrypt) Reset()         { *m = KeyTomeCrypt{} }
func (m *KeyTomeCrypt) String() string { return proto.CompactTextString(m) }
func (*KeyTomeCrypt) ProtoMessage()    {}
func (*KeyTomeCrypt) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{8}
}
func (m *KeyTomeCrypt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyTomeCrypt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyTomeCrypt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyTomeCrypt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyTomeCrypt.Merge(m, src)
}
func (m *KeyTomeCrypt) XXX_Size() int {
	return m.Size()
}
func (m *KeyTomeCrypt) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyTomeCrypt.DiscardUnknown(m)
}

var xxx_messageInfo_KeyTomeCrypt proto.InternalMessageInfo

func (m *KeyTomeCrypt) GetTome() []byte {
	if m != nil {
		return m.Tome
	}
	return nil
}

func (m *KeyTomeCrypt) GetKeyRef() *KeyRef {
	if m != nil {
		return m.KeyRef
	}
	return nil
}

func (m *KeyTomeCrypt) GetKeyInfo() *KeyInfo {
	if m != nil {
		return m.KeyInfo
	}
	return nil
}

// Err wraps errors
type Err struct {
	Code ErrCode `protobuf:"varint,1,opt,name=Code,proto3,enum=ski.ErrCode" json:"Code,omitempty"`
	// Msg is a human-readable info string that offers amplifying info about the given error.
	Msg                  string   `protobuf:"bytes,2,opt,name=Msg,proto3" json:"Msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Err) Reset()         { *m = Err{} }
func (m *Err) String() string { return proto.CompactTextString(m) }
func (*Err) ProtoMessage()    {}
func (*Err) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{9}
}
func (m *Err) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Err) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Err.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Err) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Err.Merge(m, src)
}
func (m *Err) XXX_Size() int {
	return m.Size()
}
func (m *Err) XXX_DiscardUnknown() {
	xxx_messageInfo_Err.DiscardUnknown(m)
}

var xxx_messageInfo_Err proto.InternalMessageInfo

func (m *Err) GetCode() ErrCode {
	if m != nil {
		return m.Code
	}
	return ErrCode_NoErr
}

func (m *Err) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterEnum("ski.KeyType", KeyType_name, KeyType_value)
	proto.RegisterEnum("ski.CryptoKitID", CryptoKitID_name, CryptoKitID_value)
	proto.RegisterEnum("ski.HashKitID", HashKitID_name, HashKitID_value)
	proto.RegisterEnum("ski.CryptOp", CryptOp_name, CryptOp_value)
	proto.RegisterEnum("ski.ErrCode", ErrCode_name, ErrCode_value)
	proto.RegisterType((*CryptOpArgs)(nil), "ski.CryptOpArgs")
	proto.RegisterType((*CryptOpOut)(nil), "ski.CryptOpOut")
	proto.RegisterType((*KeyInfo)(nil), "ski.KeyInfo")
	proto.RegisterType((*KeyRef)(nil), "ski.KeyRef")
	proto.RegisterType((*KeyEntry)(nil), "ski.KeyEntry")
	proto.RegisterType((*Keyring)(nil), "ski.Keyring")
	proto.RegisterType((*KeyTome)(nil), "ski.KeyTome")
	proto.RegisterType((*SigHeader)(nil), "ski.SigHeader")
	proto.RegisterType((*KeyTomeCrypt)(nil), "ski.KeyTomeCrypt")
	proto.RegisterType((*Err)(nil), "ski.Err")
}

func init() { proto.RegisterFile("ski/ski.proto", fileDescriptor_7c832fdcf6eb1a7a) }

var fileDescriptor_7c832fdcf6eb1a7a = []byte{
	// 1134 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x56, 0x4d, 0x6f, 0x23, 0x45,
	0x13, 0xf6, 0xf8, 0x3b, 0x65, 0x27, 0xe9, 0xf4, 0x26, 0xab, 0x51, 0x0e, 0x79, 0xbd, 0x7e, 0xd1,
	0xc6, 0x8a, 0xd0, 0xa2, 0xf5, 0x2a, 0x48, 0x0b, 0xc8, 0x22, 0x4e, 0x1c, 0x62, 0x39, 0x1b, 0x47,
	0xe3, 0x98, 0x2b, 0x9a, 0x78, 0xca, 0xde, 0x51, 0x3c, 0x33, 0x56, 0xcf, 0x38, 0xcb, 0xe4, 0x0f,
	0x00, 0x12, 0xdc, 0x39, 0x20, 0x71, 0xe4, 0x77, 0xc0, 0x85, 0x5d, 0x3e, 0x24, 0x0e, 0x70, 0x05,
	0x14, 0x2e, 0x20, 0x21, 0xf1, 0x17, 0x50, 0xf5, 0xf4, 0x4c, 0xc6, 0x1b, 0x2d, 0xb7, 0xa9, 0xa7,
	0xaa, 0xab, 0x9e, 0x7a, 0xaa, 0xba, 0x6d, 0x58, 0xf6, 0x2f, 0xec, 0x37, 0xfc, 0x0b, 0xfb, 0xc1,
	0x4c, 0x78, 0x81, 0xc7, 0x73, 0xfe, 0x85, 0x5d, 0xff, 0x5b, 0x83, 0xca, 0xbe, 0x08, 0x67, 0x41,
	0x7f, 0xb6, 0x27, 0x26, 0x3e, 0xbf, 0x0f, 0x25, 0x65, 0xea, 0x5a, 0x4d, 0x6b, 0xac, 0x34, 0xab,
	0x0f, 0xe8, 0x84, 0xc2, 0x8c, 0xd8, 0xc9, 0xdf, 0x01, 0x76, 0x80, 0x63, 0x73, 0x3e, 0x0d, 0x24,
	0xe2, 0xf5, 0xec, 0x40, 0xcf, 0xca, 0x03, 0xec, 0xe6, 0x00, 0xa1, 0xdd, 0x03, 0xe3, 0x56, 0x24,
	0x5f, 0x87, 0x42, 0x7b, 0x3e, 0xee, 0xba, 0x7a, 0xae, 0xa6, 0x35, 0xaa, 0x46, 0x64, 0xf0, 0x7b,
	0x50, 0xe8, 0xcf, 0x7a, 0x18, 0xea, 0xf9, 0x9a, 0xd6, 0xa8, 0x34, 0x2b, 0x32, 0x51, 0x0f, 0x43,
	0x03, 0xc7, 0x46, 0xe4, 0xe1, 0x3a, 0x94, 0x4e, 0x11, 0x05, 0x05, 0x15, 0xe4, 0xd1, 0xd8, 0xe4,
	0xaf, 0x41, 0xf1, 0xcc, 0x73, 0xb0, 0xeb, 0xea, 0x45, 0x79, 0xba, 0x1a, 0x9f, 0x26, 0xd4, 0x50,
	0xbe, 0xfa, 0xbb, 0x00, 0xaa, 0x83, 0xfe, 0x3c, 0xe0, 0x77, 0xa1, 0xd8, 0x9e, 0x8f, 0xfb, 0xf3,
	0x40, 0xf6, 0x5a, 0x35, 0x94, 0xc5, 0x37, 0xa1, 0xdc, 0x9f, 0x9d, 0xce, 0xcf, 0xa9, 0x4c, 0x56,
	0x7a, 0x12, 0xbb, 0xfe, 0xa5, 0x06, 0xa5, 0x1e, 0x86, 0x5d, 0x77, 0xec, 0x91, 0x58, 0x54, 0x20,
	0x9c, 0xe1, 0x82, 0x58, 0x0a, 0x33, 0x62, 0x27, 0x6f, 0x2a, 0x8d, 0x23, 0x3d, 0x5e, 0xa9, 0x53,
	0x3a, 0x88, 0xd7, 0xa0, 0x72, 0x66, 0x3b, 0xb8, 0x2f, 0xd0, 0x0c, 0xd0, 0x92, 0x42, 0xe5, 0x8c,
	0x34, 0x44, 0xec, 0x15, 0xc7, 0x7c, 0xc4, 0x5e, 0x31, 0x6c, 0x43, 0x31, 0x12, 0x8d, 0x72, 0xf4,
	0x30, 0x14, 0xb6, 0x3b, 0x39, 0x31, 0x1d, 0x54, 0x4d, 0xa6, 0xa1, 0x54, 0x8e, 0xec, 0x42, 0x8e,
	0x63, 0x28, 0xf7, 0x30, 0xec, 0xb8, 0x81, 0x08, 0x55, 0x97, 0xd4, 0xb0, 0xcc, 0x90, 0x92, 0x96,
	0x30, 0x23, 0x51, 0x83, 0x66, 0x23, 0xec, 0x4b, 0x4a, 0x56, 0x54, 0xb3, 0x89, 0xcc, 0xfa, 0xa7,
	0x91, 0x66, 0x54, 0x95, 0x73, 0xc8, 0xa7, 0xc8, 0xc8, 0x6f, 0x7e, 0x0f, 0xf2, 0x3d, 0x0c, 0x7d,
	0x3d, 0x5b, 0xcb, 0x35, 0x2a, 0xcd, 0xe5, 0x38, 0xbd, 0x2c, 0x6f, 0x48, 0x17, 0xbf, 0x0f, 0x2b,
	0x03, 0x4f, 0x04, 0x68, 0xb5, 0x43, 0x45, 0x98, 0x14, 0x29, 0x1b, 0x2f, 0xa1, 0xbc, 0x0e, 0xd5,
	0x13, 0x7c, 0x86, 0x7e, 0xb0, 0x20, 0xcd, 0x02, 0x56, 0xb7, 0xa3, 0xb1, 0x79, 0x0e, 0x72, 0x06,
	0x39, 0x03, 0x2f, 0x25, 0x99, 0x9c, 0x41, 0x9f, 0xbc, 0x21, 0x3b, 0x27, 0xaa, 0x31, 0x9f, 0xa4,
	0x5d, 0x02, 0x8d, 0xc4, 0x4b, 0xa5, 0xe2, 0xe2, 0xb2, 0xa3, 0x88, 0xd0, 0x02, 0x56, 0xff, 0x47,
	0x83, 0xa5, 0x81, 0x3d, 0x39, 0x42, 0xd3, 0x42, 0xc1, 0xdf, 0x82, 0xd5, 0x81, 0x3d, 0x71, 0x51,
	0xdc, 0xdc, 0x19, 0xed, 0x15, 0xbb, 0xf0, 0x72, 0xa0, 0xac, 0x26, 0xa1, 0x85, 0x79, 0x2d, 0x60,
	0xfc, 0x75, 0x58, 0x3a, 0x32, 0xfd, 0xa7, 0xd1, 0x96, 0x15, 0x65, 0xe6, 0x15, 0x99, 0x39, 0x41,
	0x8d, 0x9b, 0x00, 0xda, 0xf2, 0x88, 0xd7, 0xe0, 0x4a, 0x2f, 0xd5, 0xb4, 0xc6, 0xb2, 0x91, 0xd8,
	0xb4, 0x39, 0xd1, 0xf7, 0xbe, 0x67, 0xe1, 0x48, 0x2f, 0x4b, 0x77, 0x1a, 0x92, 0x77, 0xc7, 0xb3,
	0xc2, 0xc1, 0x95, 0xbe, 0x54, 0xd3, 0x1a, 0x79, 0x43, 0x59, 0x75, 0x0f, 0xaa, 0x4a, 0x5c, 0xc9,
	0x9d, 0xe6, 0x4d, 0x46, 0x3c, 0x6f, 0xa9, 0xfa, 0xff, 0xe3, 0x0d, 0xd5, 0xe1, 0xf6, 0x4d, 0x8f,
	0x97, 0x37, 0xb5, 0x76, 0x95, 0xff, 0x58, 0xbb, 0xfa, 0x63, 0xc8, 0x75, 0x84, 0xe0, 0x35, 0xc8,
	0x13, 0xb1, 0x85, 0x8b, 0xd8, 0x11, 0x92, 0xac, 0x21, 0x3d, 0x34, 0xeb, 0x27, 0xfe, 0x44, 0x0a,
	0xb7, 0x64, 0xd0, 0xe7, 0x4e, 0x3f, 0xb9, 0xbf, 0x7c, 0x15, 0x2a, 0x43, 0xd7, 0x9f, 0xe1, 0xc8,
	0x1e, 0xdb, 0x68, 0xb1, 0x0c, 0x67, 0x50, 0x1d, 0x84, 0x8e, 0x83, 0x81, 0xb0, 0x47, 0x3d, 0x0c,
	0x99, 0xc6, 0xd7, 0x60, 0x79, 0xcf, 0x4f, 0x43, 0x59, 0xbe, 0x02, 0x40, 0x03, 0xb0, 0xdd, 0x09,
	0xd9, 0xb9, 0x9d, 0xb7, 0x17, 0x2e, 0x3a, 0xdf, 0x80, 0xb5, 0x54, 0xd2, 0xc8, 0xc3, 0x32, 0xbc,
	0x4c, 0x57, 0x60, 0x7f, 0xca, 0x34, 0x5e, 0x81, 0x52, 0xe7, 0xa0, 0xb9, 0xbb, 0xfb, 0xf0, 0x31,
	0xcb, 0xee, 0x7c, 0xa6, 0xa5, 0xc6, 0xc7, 0xef, 0x02, 0x4f, 0x9d, 0x55, 0x38, 0xcb, 0xf0, 0x75,
	0x60, 0xc7, 0x38, 0x31, 0x47, 0x61, 0x0f, 0x47, 0x23, 0xf3, 0xe2, 0x83, 0xe6, 0xee, 0x9b, 0x4c,
	0xbb, 0x85, 0xee, 0x3e, 0x6c, 0xb2, 0x2c, 0xaf, 0x42, 0x79, 0x70, 0xb4, 0xf7, 0x48, 0xc6, 0xe4,
	0x12, 0x8b, 0x7c, 0x79, 0x6a, 0xb8, 0x3d, 0x35, 0x2f, 0xb0, 0x79, 0x2e, 0xdd, 0x85, 0x34, 0x40,
	0x11, 0xc5, 0x9d, 0xaf, 0xb4, 0xe4, 0xb7, 0x80, 0x28, 0x53, 0xa3, 0x2c, 0x43, 0x2d, 0x77, 0xdc,
	0x11, 0xc1, 0x83, 0xd0, 0x61, 0x1a, 0xd9, 0x07, 0x98, 0xd8, 0x59, 0x52, 0x49, 0xf9, 0xcf, 0x3c,
	0x7a, 0x9b, 0x59, 0x8e, 0xdf, 0x81, 0x55, 0x15, 0x72, 0x28, 0x3c, 0x47, 0x82, 0x79, 0x8a, 0xeb,
	0x3a, 0x33, 0x4f, 0x04, 0x43, 0xdf, 0x76, 0x27, 0xa7, 0xcf, 0x58, 0x41, 0x1e, 0xfd, 0x30, 0x0d,
	0x15, 0x39, 0x87, 0x95, 0x28, 0x2a, 0x39, 0x59, 0xa2, 0xc9, 0x44, 0x61, 0xaa, 0x40, 0x79, 0xe7,
	0x45, 0x0e, 0x4a, 0x6a, 0xd6, 0x7c, 0x09, 0x0a, 0x27, 0x5e, 0x47, 0x08, 0x96, 0xe1, 0x1c, 0x96,
	0x87, 0xae, 0xed, 0xcc, 0xa6, 0xe8, 0xa0, 0x1b, 0xa0, 0xc5, 0x3e, 0xda, 0xe6, 0xab, 0x00, 0x43,
	0xd7, 0x35, 0x1d, 0xb4, 0x28, 0xe6, 0xe3, 0x6d, 0xce, 0xa0, 0xd2, 0x75, 0x03, 0x14, 0xae, 0x39,
	0x25, 0xe4, 0x93, 0x6d, 0xbe, 0x06, 0xd5, 0x3d, 0xdf, 0x47, 0x11, 0x1c, 0x9a, 0xf6, 0x14, 0x2d,
	0xf6, 0xc5, 0x36, 0xff, 0x1f, 0x6c, 0x26, 0x73, 0xdd, 0x9b, 0x0a, 0x34, 0xad, 0xd0, 0xc0, 0x89,
	0xed, 0x07, 0x28, 0xd0, 0x62, 0x5f, 0xb7, 0xf8, 0x26, 0x6c, 0x0c, 0x5d, 0x81, 0x23, 0x6f, 0xe2,
	0xda, 0x57, 0xf1, 0xa8, 0x69, 0x60, 0xdf, 0xb4, 0x88, 0x46, 0xdc, 0x7e, 0x94, 0xf0, 0x5b, 0x19,
	0xff, 0x3e, 0x0a, 0x7b, 0x1c, 0x92, 0xaa, 0x66, 0x30, 0x17, 0xa8, 0x7c, 0xcf, 0x5b, 0x54, 0xbf,
	0x6d, 0x5a, 0x3d, 0x0c, 0x0f, 0x3d, 0xe1, 0x98, 0x01, 0x7b, 0xd1, 0xe2, 0x3a, 0xdc, 0xe9, 0x61,
	0xf8, 0x1e, 0xba, 0x28, 0xcc, 0xc0, 0xf6, 0x5c, 0x15, 0xfc, 0x5d, 0x8b, 0xaf, 0xc3, 0x6a, 0xfc,
	0x9e, 0x7b, 0xc1, 0xa1, 0x37, 0x77, 0x2d, 0xf6, 0x7d, 0x8b, 0x6f, 0x00, 0x8b, 0xdf, 0xcf, 0x04,
	0xfe, 0x41, 0x06, 0xab, 0x45, 0x4a, 0xd0, 0x1f, 0x25, 0x3a, 0x40, 0xdf, 0xb7, 0x3d, 0xf7, 0xc4,
	0x0b, 0x0c, 0xea, 0x8d, 0xfd, 0x2c, 0x4b, 0xde, 0xea, 0xa8, 0x3f, 0x63, 0xbf, 0xc8, 0x7e, 0x9e,
	0x98, 0xc2, 0x7f, 0x6a, 0x4e, 0x15, 0x8d, 0x5f, 0x65, 0x8e, 0xa1, 0xeb, 0x2c, 0xa0, 0xbf, 0xc5,
	0xb4, 0x8f, 0xec, 0x4b, 0xd5, 0xdd, 0x99, 0x77, 0xec, 0x99, 0x16, 0xfb, 0x33, 0xf6, 0xd0, 0x63,
	0x10, 0x7b, 0x06, 0xe6, 0x25, 0xb2, 0xbf, 0x5a, 0x6d, 0xf6, 0xfc, 0x7a, 0x4b, 0xfb, 0xe9, 0x7a,
	0x4b, 0xfb, 0xfd, 0x7a, 0x4b, 0xfb, 0xfc, 0x8f, 0xad, 0xcc, 0x79, 0x51, 0xfe, 0x5d, 0x79, 0xf4,
	0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x5b, 0x19, 0x6a, 0xa7, 0xbf, 0x08, 0x00, 0x00,
}

func (m *CryptOpArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CryptOpArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CryptOpArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TomeIn != nil {
		{
			size, err := m.TomeIn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSki(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.PeerKey) > 0 {
		i -= len(m.PeerKey)
		copy(dAtA[i:], m.PeerKey)
		i = encodeVarintSki(dAtA, i, uint64(len(m.PeerKey)))
		i--
		dAtA[i] = 0x2a
	}
	if m.OpKey != nil {
		{
			size, err := m.OpKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSki(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.BufIn) > 0 {
		i -= len(m.BufIn)
		copy(dAtA[i:], m.BufIn)
		i = encodeVarintSki(dAtA, i, uint64(len(m.BufIn)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DefaultCryptoKit != 0 {
		i = encodeVarintSki(dAtA, i, uint64(m.DefaultCryptoKit))
		i--
		dAtA[i] = 0x10
	}
	if m.CryptOp != 0 {
		i = encodeVarintSki(dAtA, i, uint64(m.CryptOp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CryptOpOut) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CryptOpOut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CryptOpOut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OpPubKey) > 0 {
		i -= len(m.OpPubKey)
		copy(dAtA[i:], m.OpPubKey)
		i = encodeVarintSki(dAtA, i, uint64(len(m.OpPubKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BufOut) > 0 {
		i -= len(m.BufOut)
		copy(dAtA[i:], m.BufOut)
		i = encodeVarintSki(dAtA, i, uint64(len(m.BufOut)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KeyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintSki(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.TimeCreated != 0 {
		i = encodeVarintSki(dAtA, i, uint64(m.TimeCreated))
		i--
		dAtA[i] = 0x18
	}
	if m.CryptoKitID != 0 {
		i = encodeVarintSki(dAtA, i, uint64(m.CryptoKitID))
		i--
		dAtA[i] = 0x10
	}
	if m.KeyType != 0 {
		i = encodeVarintSki(dAtA, i, uint64(m.KeyType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KeyRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintSki(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KeyringName) > 0 {
		i -= len(m.KeyringName)
		copy(dAtA[i:], m.KeyringName)
		i = encodeVarintSki(dAtA, i, uint64(len(m.KeyringName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KeyEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PrivKey) > 0 {
		i -= len(m.PrivKey)
		copy(dAtA[i:], m.PrivKey)
		i = encodeVarintSki(dAtA, i, uint64(len(m.PrivKey)))
		i--
		dAtA[i] = 0x32
	}
	if m.KeyInfo != nil {
		{
			size, err := m.KeyInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSki(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Keyring) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Keyring) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Keyring) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NewestPubKey) > 0 {
		i -= len(m.NewestPubKey)
		copy(dAtA[i:], m.NewestPubKey)
		i = encodeVarintSki(dAtA, i, uint64(len(m.NewestPubKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.SortedByPubKey {
		i--
		if m.SortedByPubKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Keys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSki(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSki(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KeyTome) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyTome) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyTome) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SortedByName {
		i--
		if m.SortedByName {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Keyrings) > 0 {
		for iNdEx := len(m.Keyrings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Keyrings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSki(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Rev != 0 {
		i = encodeVarintSki(dAtA, i, uint64(m.Rev))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SigHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SigHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SigHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BodySz != 0 {
		i = encodeVarintSki(dAtA, i, uint64(m.BodySz))
		i--
		dAtA[i] = 0x48
	}
	if m.HeaderCodec != 0 {
		i = encodeVarintSki(dAtA, i, uint64(m.HeaderCodec))
		i--
		dAtA[i] = 0x40
	}
	if m.HeaderSz != 0 {
		i = encodeVarintSki(dAtA, i, uint64(m.HeaderSz))
		i--
		dAtA[i] = 0x38
	}
	if m.HashKitID != 0 {
		i = encodeVarintSki(dAtA, i, uint64(m.HashKitID))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SignerPubKey) > 0 {
		i -= len(m.SignerPubKey)
		copy(dAtA[i:], m.SignerPubKey)
		i = encodeVarintSki(dAtA, i, uint64(len(m.SignerPubKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.SignerCryptoKit != 0 {
		i = encodeVarintSki(dAtA, i, uint64(m.SignerCryptoKit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KeyTomeCrypt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyTomeCrypt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyTomeCrypt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.KeyInfo != nil {
		{
			size, err := m.KeyInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSki(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.KeyRef != nil {
		{
			size, err := m.KeyRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSki(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Tome) > 0 {
		i -= len(m.Tome)
		copy(dAtA[i:], m.Tome)
		i = encodeVarintSki(dAtA, i, uint64(len(m.Tome)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Err) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Err) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Err) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintSki(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintSki(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintSki(dAtA []byte, offset int, v uint64) int {
	offset -= sovSki(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CryptOpArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CryptOp != 0 {
		n += 1 + sovSki(uint64(m.CryptOp))
	}
	if m.DefaultCryptoKit != 0 {
		n += 1 + sovSki(uint64(m.DefaultCryptoKit))
	}
	l = len(m.BufIn)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	if m.OpKey != nil {
		l = m.OpKey.Size()
		n += 1 + l + sovSki(uint64(l))
	}
	l = len(m.PeerKey)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	if m.TomeIn != nil {
		l = m.TomeIn.Size()
		n += 1 + l + sovSki(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CryptOpOut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BufOut)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	l = len(m.OpPubKey)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyType != 0 {
		n += 1 + sovSki(uint64(m.KeyType))
	}
	if m.CryptoKitID != 0 {
		n += 1 + sovSki(uint64(m.CryptoKitID))
	}
	if m.TimeCreated != 0 {
		n += 1 + sovSki(uint64(m.TimeCreated))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyringName)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyInfo != nil {
		l = m.KeyInfo.Size()
		n += 1 + l + sovSki(uint64(l))
	}
	l = len(m.PrivKey)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Keyring) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	if len(m.Keys) > 0 {
		for _, e := range m.Keys {
			l = e.Size()
			n += 1 + l + sovSki(uint64(l))
		}
	}
	if m.SortedByPubKey {
		n += 2
	}
	l = len(m.NewestPubKey)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyTome) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rev != 0 {
		n += 1 + sovSki(uint64(m.Rev))
	}
	if len(m.Keyrings) > 0 {
		for _, e := range m.Keyrings {
			l = e.Size()
			n += 1 + l + sovSki(uint64(l))
		}
	}
	if m.SortedByName {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SigHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SignerCryptoKit != 0 {
		n += 1 + sovSki(uint64(m.SignerCryptoKit))
	}
	l = len(m.SignerPubKey)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	if m.HashKitID != 0 {
		n += 1 + sovSki(uint64(m.HashKitID))
	}
	if m.HeaderSz != 0 {
		n += 1 + sovSki(uint64(m.HeaderSz))
	}
	if m.HeaderCodec != 0 {
		n += 1 + sovSki(uint64(m.HeaderCodec))
	}
	if m.BodySz != 0 {
		n += 1 + sovSki(uint64(m.BodySz))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyTomeCrypt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tome)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	if m.KeyRef != nil {
		l = m.KeyRef.Size()
		n += 1 + l + sovSki(uint64(l))
	}
	if m.KeyInfo != nil {
		l = m.KeyInfo.Size()
		n += 1 + l + sovSki(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Err) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovSki(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSki(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSki(x uint64) (n int) {
	return sovSki(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CryptOpArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CryptOpArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CryptOpArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CryptOp", wireType)
			}
			m.CryptOp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CryptOp |= CryptOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultCryptoKit", wireType)
			}
			m.DefaultCryptoKit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultCryptoKit |= CryptoKitID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufIn", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BufIn = append(m.BufIn[:0], dAtA[iNdEx:postIndex]...)
			if m.BufIn == nil {
				m.BufIn = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpKey == nil {
				m.OpKey = &KeyRef{}
			}
			if err := m.OpKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerKey = append(m.PeerKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PeerKey == nil {
				m.PeerKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TomeIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TomeIn == nil {
				m.TomeIn = &KeyTome{}
			}
			if err := m.TomeIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CryptOpOut) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CryptOpOut: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CryptOpOut: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufOut", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BufOut = append(m.BufOut[:0], dAtA[iNdEx:postIndex]...)
			if m.BufOut == nil {
				m.BufOut = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpPubKey = append(m.OpPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.OpPubKey == nil {
				m.OpPubKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			m.KeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyType |= KeyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CryptoKitID", wireType)
			}
			m.CryptoKitID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CryptoKitID |= CryptoKitID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeCreated", wireType)
			}
			m.TimeCreated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeCreated |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyringName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyringName = append(m.KeyringName[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyringName == nil {
				m.KeyringName = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyInfo == nil {
				m.KeyInfo = &KeyInfo{}
			}
			if err := m.KeyInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivKey = append(m.PrivKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrivKey == nil {
				m.PrivKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Keyring) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Keyring: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Keyring: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, &KeyEntry{})
			if err := m.Keys[len(m.Keys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortedByPubKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SortedByPubKey = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewestPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewestPubKey = append(m.NewestPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.NewestPubKey == nil {
				m.NewestPubKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyTome) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyTome: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyTome: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			m.Rev = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rev |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyrings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyrings = append(m.Keyrings, &Keyring{})
			if err := m.Keyrings[len(m.Keyrings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortedByName", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SortedByName = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SigHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SigHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SigHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignerCryptoKit", wireType)
			}
			m.SignerCryptoKit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignerCryptoKit |= CryptoKitID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignerPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignerPubKey = append(m.SignerPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SignerPubKey == nil {
				m.SignerPubKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashKitID", wireType)
			}
			m.HashKitID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HashKitID |= HashKitID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderSz", wireType)
			}
			m.HeaderSz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeaderSz |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderCodec", wireType)
			}
			m.HeaderCodec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeaderCodec |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodySz", wireType)
			}
			m.BodySz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BodySz |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyTomeCrypt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyTomeCrypt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyTomeCrypt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tome", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tome = append(m.Tome[:0], dAtA[iNdEx:postIndex]...)
			if m.Tome == nil {
				m.Tome = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRef == nil {
				m.KeyRef = &KeyRef{}
			}
			if err := m.KeyRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyInfo == nil {
				m.KeyInfo = &KeyInfo{}
			}
			if err := m.KeyInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Err) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Err: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Err: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= ErrCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSki(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSki
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSki
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSki
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSki
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSki
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSki
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSki        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSki          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSki = fmt.Errorf("proto: unexpected end of group")
)
