// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ski/ski.proto

package ski

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	plan "github.com/plan-systems/plan-core/plan" /// Redirected by build-go-protobufs :)
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// KeyType identifies how a key operates
type KeyType int32

const (
	KeyType_Unspecified   KeyType = 0
	KeyType_SymmetricKey  KeyType = 1
	KeyType_AsymmetricKey KeyType = 2
	KeyType_SigningKey    KeyType = 3
)

var KeyType_name = map[int32]string{
	0: "Unspecified",
	1: "SymmetricKey",
	2: "AsymmetricKey",
	3: "SigningKey",
}

var KeyType_value = map[string]int32{
	"Unspecified":   0,
	"SymmetricKey":  1,
	"AsymmetricKey": 2,
	"SigningKey":    3,
}

func (x KeyType) String() string {
	return proto.EnumName(KeyType_name, int32(x))
}

func (KeyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{0}
}

// CryptoKitID identifies an encryption suite that implements ski.CryptoKit
type CryptoKitID int32

const (
	CryptoKitID_DEFAULT_KIT CryptoKitID = 0
	CryptoKitID_NaCl        CryptoKitID = 1
	CryptoKitID_ED25519     CryptoKitID = 2
)

var CryptoKitID_name = map[int32]string{
	0: "DEFAULT_KIT",
	1: "NaCl",
	2: "ED25519",
}

var CryptoKitID_value = map[string]int32{
	"DEFAULT_KIT": 0,
	"NaCl":        1,
	"ED25519":     2,
}

func (x CryptoKitID) String() string {
	return proto.EnumName(CryptoKitID_name, int32(x))
}

func (CryptoKitID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{1}
}

// CryptoKitID identifies a hash algorithm that implements ski.HaskKit
type HashKitID int32

const (
	HashKitID_DEFAULT_HASH_KIT HashKitID = 0
	HashKitID_LegacyKeccak_256 HashKitID = 1
	HashKitID_LegacyKeccak_512 HashKitID = 2
	HashKitID_SHA3_256         HashKitID = 3
	HashKitID_SHA3_512         HashKitID = 4
	HashKitID_Blake2b_256      HashKitID = 5
	HashKitID_Blake2b_512      HashKitID = 6
)

var HashKitID_name = map[int32]string{
	0: "DEFAULT_HASH_KIT",
	1: "LegacyKeccak_256",
	2: "LegacyKeccak_512",
	3: "SHA3_256",
	4: "SHA3_512",
	5: "Blake2b_256",
	6: "Blake2b_512",
}

var HashKitID_value = map[string]int32{
	"DEFAULT_HASH_KIT": 0,
	"LegacyKeccak_256": 1,
	"LegacyKeccak_512": 2,
	"SHA3_256":         3,
	"SHA3_512":         4,
	"Blake2b_256":      5,
	"Blake2b_512":      6,
}

func (x HashKitID) String() string {
	return proto.EnumName(HashKitID_name, int32(x))
}

func (HashKitID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{2}
}

type CryptOp int32

const (
	// Generates a signature for BufIn using the referenced signing key, placing the signature into BufOut.
	CryptOp_SIGN CryptOp = 0
	// Encrypts BufIn using the symmetric key referenced by a Keyring "name" and key named by its pub key.
	CryptOp_ENCRYPT_SYM CryptOp = 1
	// Decrypts BufIn using the referenced symmetric key.
	CryptOp_DECRYPT_SYM CryptOp = 2
	// Encrypts BufIn for a recipient holding the private key associated with the pub key contained in PeerKey,
	//    encrypting using the referenced asymmetric key and placing the encrypted result into BufOut.
	CryptOp_ENCRYPT_TO_PEER CryptOp = 3
	// Decrypts BufIn from a sender holding the private key associated with the pub key contained in PeerKey,
	//    decrypting using the referenced asymmetric key and placing the decrypted result into BufOut.
	CryptOp_DECRYPT_FROM_PEER CryptOp = 4
	// Inverse of EXPORT_USING_PW
	// Identical to IMPORT_FROM_PEER except that BufIn is instead decrypted via CryptoKit.DecryptUsingPassword(),
	//    using CryptOp.PeerKey as a the password.
	CryptOp_IMPORT_USING_PW CryptOp = 5
	// Inverse of IMPORT_USING_PW
	// Identical to EXPORT_TO_PEER except the output serialized KeyTome is encrypted via CryptoKit.EncryptUsingPassword(),
	//    using CryptOp.PeerKey as a the password.
	CryptOp_EXPORT_USING_PW CryptOp = 6
	// Inverse of EXPORT_TO_PEER
	// First, performs as DECRYPT_FROM_PEER.
	// The result/output buf is then unmarshalled (assumed to be a ski.KeyTome protobuf) and is merged into the host KeyTome.
	// See ski.ImportKeys() for how the incoming KeyTome is merged into the host KeyTome.
	CryptOp_IMPORT_FROM_PEER CryptOp = 7
	// Inverse of IMPORT_FROM_PEER
	// For each entry in CryptOpArgs.TomeIn, PubKey is used to lookup a corresponding KeyEntry in the host KeyTome.
	// Each KeyEntry with a matching PubKey is copied into a new temp KeyTome, into the appropriate Keyring,
	//    creating a Keyring if it does not yet exist.
	// If a Keyring appears in CryptOpArgs.TomeIn but contains no entries, the entire Keyring will be exported.
	// If a Keyring or KeyEntry from TomeIn isn't found, an error is returned.
	// See KeyTome.ExportUsingGuide() for how TomeIn is handled.
	// On completion, the temp KeyTome is serialized, assigned to CryptOpArgs.BufIn, and ENCRYPT_TO_PEER is executed.
	CryptOp_EXPORT_TO_PEER CryptOp = 8
)

var CryptOp_name = map[int32]string{
	0: "SIGN",
	1: "ENCRYPT_SYM",
	2: "DECRYPT_SYM",
	3: "ENCRYPT_TO_PEER",
	4: "DECRYPT_FROM_PEER",
	5: "IMPORT_USING_PW",
	6: "EXPORT_USING_PW",
	7: "IMPORT_FROM_PEER",
	8: "EXPORT_TO_PEER",
}

var CryptOp_value = map[string]int32{
	"SIGN":              0,
	"ENCRYPT_SYM":       1,
	"DECRYPT_SYM":       2,
	"ENCRYPT_TO_PEER":   3,
	"DECRYPT_FROM_PEER": 4,
	"IMPORT_USING_PW":   5,
	"EXPORT_USING_PW":   6,
	"IMPORT_FROM_PEER":  7,
	"EXPORT_TO_PEER":    8,
}

func (x CryptOp) String() string {
	return proto.EnumName(CryptOp_name, int32(x))
}

func (CryptOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{3}
}

type CryptOpArgs struct {
	// Specifies which op to invoke for these given set of args
	CryptOp CryptOp `protobuf:"varint,1,opt,name=crypt_op,json=cryptOp,proto3,enum=ski.CryptOp" json:"crypt_op,omitempty"`
	// Specifies the default CryptoKit for ops when not specified.
	DefaultCryptoKit CryptoKitID `protobuf:"varint,2,opt,name=default_crypto_kit,json=defaultCryptoKit,proto3,enum=ski.CryptoKitID" json:"default_crypto_kit,omitempty"`
	// The source/input buffer that is signed/encrypted/decrypted.
	BufIn []byte `protobuf:"bytes,3,opt,name=buf_in,json=bufIn,proto3" json:"buf_in,omitempty"`
	// A reference to an existing KeyEntry in the host's KeyTome used as the key for this op's encryption/decryption.
	OpKey *KeyRef `protobuf:"bytes,4,opt,name=op_key,json=opKey,proto3" json:"op_key,omitempty"`
	// For ENCRYPT_TO_PEER and EXPORT_TO_PEER, this is what the recipient will use for OpKey.PubKey.
	// For DECRYPT_FROM_PEER and IMPORT_FROM_PEER, this is what the sender used for OpKey.PubKey.
	// For IMPORT_USING_PW and EXPORT_USING_PW, this is the password.
	PeerKey []byte `protobuf:"bytes,5,opt,name=peer_key,json=peerKey,proto3" json:"peer_key,omitempty"`
	// Keyring and key info used to identify existing (or to-be-created) keys in the host's KeyTome.
	// Used for EXPORT_TO_PEER and GENERATE_KEYS.
	TomeIn               *KeyTome `protobuf:"bytes,6,opt,name=tome_in,json=tomeIn,proto3" json:"tome_in,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CryptOpArgs) Reset()         { *m = CryptOpArgs{} }
func (m *CryptOpArgs) String() string { return proto.CompactTextString(m) }
func (*CryptOpArgs) ProtoMessage()    {}
func (*CryptOpArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{0}
}
func (m *CryptOpArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CryptOpArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CryptOpArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CryptOpArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CryptOpArgs.Merge(m, src)
}
func (m *CryptOpArgs) XXX_Size() int {
	return m.Size()
}
func (m *CryptOpArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_CryptOpArgs.DiscardUnknown(m)
}

var xxx_messageInfo_CryptOpArgs proto.InternalMessageInfo

func (m *CryptOpArgs) GetCryptOp() CryptOp {
	if m != nil {
		return m.CryptOp
	}
	return CryptOp_SIGN
}

func (m *CryptOpArgs) GetDefaultCryptoKit() CryptoKitID {
	if m != nil {
		return m.DefaultCryptoKit
	}
	return CryptoKitID_DEFAULT_KIT
}

func (m *CryptOpArgs) GetBufIn() []byte {
	if m != nil {
		return m.BufIn
	}
	return nil
}

func (m *CryptOpArgs) GetOpKey() *KeyRef {
	if m != nil {
		return m.OpKey
	}
	return nil
}

func (m *CryptOpArgs) GetPeerKey() []byte {
	if m != nil {
		return m.PeerKey
	}
	return nil
}

func (m *CryptOpArgs) GetTomeIn() *KeyTome {
	if m != nil {
		return m.TomeIn
	}
	return nil
}

type CryptOpOut struct {
	// Output buf from the given crypto op (and depends on the given CryptOp)
	BufOut []byte `protobuf:"bytes,1,opt,name=buf_out,json=bufOut,proto3" json:"buf_out,omitempty"`
	// Returns the pub key used in the op (needed when CryptOpArgs.OpKey.PubKey wasn't specified)
	OpPubKey             []byte   `protobuf:"bytes,2,opt,name=op_pub_key,json=opPubKey,proto3" json:"op_pub_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CryptOpOut) Reset()         { *m = CryptOpOut{} }
func (m *CryptOpOut) String() string { return proto.CompactTextString(m) }
func (*CryptOpOut) ProtoMessage()    {}
func (*CryptOpOut) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{1}
}
func (m *CryptOpOut) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CryptOpOut) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CryptOpOut.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CryptOpOut) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CryptOpOut.Merge(m, src)
}
func (m *CryptOpOut) XXX_Size() int {
	return m.Size()
}
func (m *CryptOpOut) XXX_DiscardUnknown() {
	xxx_messageInfo_CryptOpOut.DiscardUnknown(m)
}

var xxx_messageInfo_CryptOpOut proto.InternalMessageInfo

func (m *CryptOpOut) GetBufOut() []byte {
	if m != nil {
		return m.BufOut
	}
	return nil
}

func (m *CryptOpOut) GetOpPubKey() []byte {
	if m != nil {
		return m.OpPubKey
	}
	return nil
}

// KeyInfo specifies info an existing KeyEntry or and KeyEntry this is to be created.
//
// KeyInfo exists in two modes/uses:
//    1) Generated/copied from an existing KeyEntry
//    2) Key gen mode: used as a guide to generate a new key
//         a) Fields used: KeyType and CryptoKitID (other fields ignored)
type KeyInfo struct {
	// Specifies the type of key this is (optional)
	KeyType KeyType `protobuf:"varint,1,opt,name=key_type,json=keyType,proto3,enum=ski.KeyType" json:"key_type,omitempty"`
	// Specifies which crypto suite to invoke.
	CryptoKit CryptoKitID `protobuf:"varint,2,opt,name=crypto_kit,json=cryptoKit,proto3,enum=ski.CryptoKitID" json:"crypto_kit,omitempty"`
	// Unix timestamp when this key was created (or 0 if not set)
	TimeCreated int64 `protobuf:"varint,3,opt,name=time_created,json=timeCreated,proto3" json:"time_created,omitempty"`
	// Public part of the key; how this key is also referenced publicly (in base-256 form)
	PubKey               []byte   `protobuf:"bytes,4,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyInfo) Reset()         { *m = KeyInfo{} }
func (m *KeyInfo) String() string { return proto.CompactTextString(m) }
func (*KeyInfo) ProtoMessage()    {}
func (*KeyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{2}
}
func (m *KeyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyInfo.Merge(m, src)
}
func (m *KeyInfo) XXX_Size() int {
	return m.Size()
}
func (m *KeyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_KeyInfo proto.InternalMessageInfo

func (m *KeyInfo) GetKeyType() KeyType {
	if m != nil {
		return m.KeyType
	}
	return KeyType_Unspecified
}

func (m *KeyInfo) GetCryptoKit() CryptoKitID {
	if m != nil {
		return m.CryptoKit
	}
	return CryptoKitID_DEFAULT_KIT
}

func (m *KeyInfo) GetTimeCreated() int64 {
	if m != nil {
		return m.TimeCreated
	}
	return 0
}

func (m *KeyInfo) GetPubKey() []byte {
	if m != nil {
		return m.PubKey
	}
	return nil
}

type KeyRef struct {
	// Specifies the Keyring that the key resides on (required when referencing a KeyEntry in a KeyTome).
	KeyringName []byte `protobuf:"bytes,1,opt,name=keyring_name,json=keyringName,proto3" json:"keyring_name,omitempty"`
	// The pub key of the key being referenced (or len()==0 to imply the newest key in the cited keyring).
	// Note that the complete pub key isn't required, just a sufficiently long matching prefix (typically 16-64 bytes).
	PubKey               []byte   `protobuf:"bytes,2,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyRef) Reset()         { *m = KeyRef{} }
func (m *KeyRef) String() string { return proto.CompactTextString(m) }
func (*KeyRef) ProtoMessage()    {}
func (*KeyRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{3}
}
func (m *KeyRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyRef.Merge(m, src)
}
func (m *KeyRef) XXX_Size() int {
	return m.Size()
}
func (m *KeyRef) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyRef.DiscardUnknown(m)
}

var xxx_messageInfo_KeyRef proto.InternalMessageInfo

func (m *KeyRef) GetKeyringName() []byte {
	if m != nil {
		return m.KeyringName
	}
	return nil
}

func (m *KeyRef) GetPubKey() []byte {
	if m != nil {
		return m.PubKey
	}
	return nil
}

// KeyEntry is used in 3 ways:
//    1) Storage/Export mode: used to store all fields of a fully generated key
//         - KeyEntry.PrivKey != nil
//    2) Ref/Spec mode: used to reference an existing key somewhere else
//         - KeyEntry.PrivKey == nil
//         - Fields used: KeyInfo.PubKey (other fields ignored)
//    3) KeyGen mode: used as a guide to generate a new key
//         - Fields used: KeyInfo.KeyType and KeyInfo.CryptoKitID (other fields ignored)
type KeyEntry struct {
	// Info about this key
	KeyInfo *KeyInfo `protobuf:"bytes,1,opt,name=key_info,json=keyInfo,proto3" json:"key_info,omitempty"`
	// Private part of the key -- should be used and copied carefully.
	// When a KeyEntry is used to reference/specify an existing key, this field is not set and/or is ignored.
	PrivKey              []byte   `protobuf:"bytes,6,opt,name=priv_key,json=privKey,proto3" json:"priv_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyEntry) Reset()         { *m = KeyEntry{} }
func (m *KeyEntry) String() string { return proto.CompactTextString(m) }
func (*KeyEntry) ProtoMessage()    {}
func (*KeyEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{4}
}
func (m *KeyEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyEntry.Merge(m, src)
}
func (m *KeyEntry) XXX_Size() int {
	return m.Size()
}
func (m *KeyEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyEntry.DiscardUnknown(m)
}

var xxx_messageInfo_KeyEntry proto.InternalMessageInfo

func (m *KeyEntry) GetKeyInfo() *KeyInfo {
	if m != nil {
		return m.KeyInfo
	}
	return nil
}

func (m *KeyEntry) GetPrivKey() []byte {
	if m != nil {
		return m.PrivKey
	}
	return nil
}

type Keyring struct {
	// Any binary name for this Keyring (except a zero-length name).
	Name []byte `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Ordered list of KeyEntry (potentially sorted by KeyInfo.PubKey)
	Keys []*KeyEntry `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	// If set, []Keys is sorted by KeyInfo.PubKey via ski.CompareEntries()
	SortedByPubKey bool `protobuf:"varint,3,opt,name=sorted_by_pub_key,json=sortedByPubKey,proto3" json:"sorted_by_pub_key,omitempty"`
	// PubKey of the KeyEntry in this keyring that has the largest TimeCreated (or nil if not known/determined)
	NewestPubKey         []byte   `protobuf:"bytes,4,opt,name=newest_pub_key,json=newestPubKey,proto3" json:"newest_pub_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Keyring) Reset()         { *m = Keyring{} }
func (m *Keyring) String() string { return proto.CompactTextString(m) }
func (*Keyring) ProtoMessage()    {}
func (*Keyring) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{5}
}
func (m *Keyring) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Keyring) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Keyring.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Keyring) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Keyring.Merge(m, src)
}
func (m *Keyring) XXX_Size() int {
	return m.Size()
}
func (m *Keyring) XXX_DiscardUnknown() {
	xxx_messageInfo_Keyring.DiscardUnknown(m)
}

var xxx_messageInfo_Keyring proto.InternalMessageInfo

func (m *Keyring) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *Keyring) GetKeys() []*KeyEntry {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Keyring) GetSortedByPubKey() bool {
	if m != nil {
		return m.SortedByPubKey
	}
	return false
}

func (m *Keyring) GetNewestPubKey() []byte {
	if m != nil {
		return m.NewestPubKey
	}
	return nil
}

type KeyTome struct {
	// Incremented each time this KeyTome is altered.
	Rev int64 `protobuf:"varint,1,opt,name=rev,proto3" json:"rev,omitempty"`
	// Ordered list of Keyrings (potentially sorted by Keyring.Name)
	Keyrings []*Keyring `protobuf:"bytes,2,rep,name=keyrings,proto3" json:"keyrings,omitempty"`
	// If set, []Keyrings is sorted by Keyring.Name via bytes.Compare()
	SortedByName         bool     `protobuf:"varint,3,opt,name=sorted_by_name,json=sortedByName,proto3" json:"sorted_by_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyTome) Reset()         { *m = KeyTome{} }
func (m *KeyTome) String() string { return proto.CompactTextString(m) }
func (*KeyTome) ProtoMessage()    {}
func (*KeyTome) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{6}
}
func (m *KeyTome) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyTome) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyTome.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyTome) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyTome.Merge(m, src)
}
func (m *KeyTome) XXX_Size() int {
	return m.Size()
}
func (m *KeyTome) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyTome.DiscardUnknown(m)
}

var xxx_messageInfo_KeyTome proto.InternalMessageInfo

func (m *KeyTome) GetRev() int64 {
	if m != nil {
		return m.Rev
	}
	return 0
}

func (m *KeyTome) GetKeyrings() []*Keyring {
	if m != nil {
		return m.Keyrings
	}
	return nil
}

func (m *KeyTome) GetSortedByName() bool {
	if m != nil {
		return m.SortedByName
	}
	return false
}

type SigHeader struct {
	// References a signing key -- who and what crypto kit signed the payload header.
	SignerCryptoKit CryptoKitID `protobuf:"varint,1,opt,name=signer_crypto_kit,json=signerCryptoKit,proto3,enum=ski.CryptoKitID" json:"signer_crypto_kit,omitempty"`
	SignerPubKey    []byte      `protobuf:"bytes,2,opt,name=signer_pub_key,json=signerPubKey,proto3" json:"signer_pub_key,omitempty"`
	// Specifies which hash kit to use to perform payload hashing
	HashKit HashKitID `protobuf:"varint,6,opt,name=hash_kit,json=hashKit,proto3,enum=ski.HashKitID" json:"hash_kit,omitempty"`
	// Size of the "header" payload (i.e. the payload that is also hashed and signed)
	HeaderSz       uint32        `protobuf:"varint,7,opt,name=header_sz,json=headerSz,proto3" json:"header_sz,omitempty"`
	HeaderEncoding plan.Encoding `protobuf:"varint,8,opt,name=header_encoding,json=headerEncoding,proto3,enum=plan.Encoding" json:"header_encoding,omitempty"`
	// Size of the "body" payload (i.e. the payload that is NOT hashed signed)
	BodySz               uint64   `protobuf:"varint,9,opt,name=body_sz,json=bodySz,proto3" json:"body_sz,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SigHeader) Reset()         { *m = SigHeader{} }
func (m *SigHeader) String() string { return proto.CompactTextString(m) }
func (*SigHeader) ProtoMessage()    {}
func (*SigHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c832fdcf6eb1a7a, []int{7}
}
func (m *SigHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SigHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SigHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SigHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigHeader.Merge(m, src)
}
func (m *SigHeader) XXX_Size() int {
	return m.Size()
}
func (m *SigHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_SigHeader.DiscardUnknown(m)
}

var xxx_messageInfo_SigHeader proto.InternalMessageInfo

func (m *SigHeader) GetSignerCryptoKit() CryptoKitID {
	if m != nil {
		return m.SignerCryptoKit
	}
	return CryptoKitID_DEFAULT_KIT
}

func (m *SigHeader) GetSignerPubKey() []byte {
	if m != nil {
		return m.SignerPubKey
	}
	return nil
}

func (m *SigHeader) GetHashKit() HashKitID {
	if m != nil {
		return m.HashKit
	}
	return HashKitID_DEFAULT_HASH_KIT
}

func (m *SigHeader) GetHeaderSz() uint32 {
	if m != nil {
		return m.HeaderSz
	}
	return 0
}

func (m *SigHeader) GetHeaderEncoding() plan.Encoding {
	if m != nil {
		return m.HeaderEncoding
	}
	return plan.Encoding_Unspecified
}

func (m *SigHeader) GetBodySz() uint64 {
	if m != nil {
		return m.BodySz
	}
	return 0
}

func init() {
	proto.RegisterEnum("ski.KeyType", KeyType_name, KeyType_value)
	proto.RegisterEnum("ski.CryptoKitID", CryptoKitID_name, CryptoKitID_value)
	proto.RegisterEnum("ski.HashKitID", HashKitID_name, HashKitID_value)
	proto.RegisterEnum("ski.CryptOp", CryptOp_name, CryptOp_value)
	proto.RegisterType((*CryptOpArgs)(nil), "ski.CryptOpArgs")
	proto.RegisterType((*CryptOpOut)(nil), "ski.CryptOpOut")
	proto.RegisterType((*KeyInfo)(nil), "ski.KeyInfo")
	proto.RegisterType((*KeyRef)(nil), "ski.KeyRef")
	proto.RegisterType((*KeyEntry)(nil), "ski.KeyEntry")
	proto.RegisterType((*Keyring)(nil), "ski.Keyring")
	proto.RegisterType((*KeyTome)(nil), "ski.KeyTome")
	proto.RegisterType((*SigHeader)(nil), "ski.SigHeader")
}

func init() { proto.RegisterFile("ski/ski.proto", fileDescriptor_7c832fdcf6eb1a7a) }

var fileDescriptor_7c832fdcf6eb1a7a = []byte{
	// 933 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0xdd, 0x6e, 0xe2, 0x46,
	0x14, 0x8e, 0x81, 0xd8, 0xe6, 0xe0, 0x80, 0x33, 0xdd, 0x55, 0xe9, 0x8f, 0x22, 0x16, 0xb5, 0x2a,
	0x9b, 0x8b, 0x5d, 0x2d, 0x2b, 0x5a, 0x55, 0xaa, 0x2a, 0x11, 0xc2, 0x2e, 0x88, 0x0d, 0xa0, 0x31,
	0x51, 0xbb, 0x57, 0x96, 0x31, 0x03, 0x58, 0x0e, 0xb6, 0x65, 0x9b, 0x54, 0x93, 0x37, 0xa8, 0x7a,
	0xd5, 0xbb, 0xde, 0xf5, 0x29, 0xfa, 0x0e, 0xbd, 0xec, 0x23, 0x54, 0xe9, 0x23, 0xf4, 0x05, 0xaa,
	0x33, 0x63, 0xf3, 0xa3, 0xaa, 0x52, 0x6f, 0xa2, 0x99, 0xef, 0x7c, 0xe7, 0x9b, 0xef, 0x7c, 0xc3,
	0x38, 0x70, 0x96, 0xf8, 0xde, 0xcb, 0xc4, 0xf7, 0x5e, 0x44, 0x71, 0x98, 0x86, 0xa4, 0x98, 0xf8,
	0xde, 0xc7, 0xb5, 0xe8, 0xce, 0x09, 0x5e, 0xe2, 0x1f, 0x89, 0x36, 0xff, 0x56, 0xa0, 0xd2, 0x8b,
	0x79, 0x94, 0x4e, 0xa2, 0x6e, 0xbc, 0x4a, 0xc8, 0x17, 0xa0, 0xbb, 0xb8, 0xb5, 0xc3, 0xa8, 0xae,
	0x34, 0x94, 0x56, 0xb5, 0x6d, 0xbc, 0x40, 0x8d, 0x8c, 0x43, 0x35, 0x57, 0x2e, 0xc8, 0xb7, 0x40,
	0x16, 0x6c, 0xe9, 0x6c, 0xef, 0x52, 0x5b, 0x40, 0xa1, 0xed, 0x7b, 0x69, 0xbd, 0x20, 0x5a, 0xcc,
	0x7d, 0x4b, 0x38, 0xf2, 0xd2, 0xe1, 0x35, 0x35, 0x33, 0xee, 0x0e, 0x23, 0x4f, 0x41, 0x9d, 0x6f,
	0x97, 0xb6, 0x17, 0xd4, 0x8b, 0x0d, 0xa5, 0x65, 0xd0, 0xd3, 0xf9, 0x76, 0x39, 0x0c, 0x48, 0x13,
	0xd4, 0x30, 0xb2, 0x7d, 0xc6, 0xeb, 0xa5, 0x86, 0xd2, 0xaa, 0xb4, 0x2b, 0x42, 0x6a, 0xc4, 0x38,
	0x65, 0x4b, 0x7a, 0x1a, 0x46, 0x23, 0xc6, 0xc9, 0x47, 0xa0, 0x47, 0x8c, 0xc5, 0x82, 0x75, 0x2a,
	0x9a, 0x35, 0xdc, 0x63, 0xe9, 0x73, 0xd0, 0xd2, 0x70, 0xc3, 0x50, 0x56, 0x15, 0xfd, 0x46, 0xde,
	0x3f, 0x0b, 0x37, 0x8c, 0xaa, 0x58, 0x1c, 0x06, 0xcd, 0x1e, 0x40, 0x36, 0xd0, 0x64, 0x9b, 0x92,
	0x0f, 0x41, 0x43, 0x2b, 0xe1, 0x36, 0x15, 0x23, 0x1b, 0x14, 0x9d, 0x61, 0xe1, 0x53, 0x80, 0x30,
	0xb2, 0xa3, 0xed, 0x5c, 0x1c, 0x55, 0x10, 0x35, 0x3d, 0x8c, 0xa6, 0xdb, 0xf9, 0x88, 0xf1, 0xe6,
	0xaf, 0x0a, 0x68, 0x23, 0xc6, 0x87, 0xc1, 0x32, 0xc4, 0xd8, 0x7c, 0xc6, 0xed, 0x94, 0x47, 0xec,
	0x28, 0x36, 0x3c, 0x98, 0x47, 0x8c, 0x6a, 0xbe, 0x5c, 0x90, 0x97, 0x00, 0xff, 0x23, 0xae, 0xb2,
	0xbb, 0xcb, 0xe9, 0x19, 0x18, 0xa9, 0xb7, 0x61, 0xb6, 0x1b, 0x33, 0x27, 0x65, 0x0b, 0x91, 0x56,
	0x91, 0x56, 0x10, 0xeb, 0x49, 0x08, 0xfd, 0xe7, 0x1e, 0x4b, 0xd2, 0x7f, 0x24, 0x1d, 0x5e, 0x83,
	0x2a, 0x93, 0x43, 0x15, 0x9f, 0xf1, 0xd8, 0x0b, 0x56, 0x76, 0xe0, 0x6c, 0x58, 0x36, 0x67, 0x25,
	0xc3, 0xc6, 0xce, 0x86, 0x1d, 0xaa, 0x14, 0x8e, 0x54, 0xc6, 0xa0, 0x8f, 0x18, 0xef, 0x07, 0x69,
	0xcc, 0xf3, 0x39, 0xbd, 0x60, 0x19, 0x0a, 0x8d, 0x83, 0x80, 0x31, 0x07, 0x31, 0xa7, 0x08, 0x04,
	0xef, 0x28, 0xf6, 0xee, 0x85, 0x9c, 0x9a, 0xdd, 0x51, 0xec, 0xdd, 0xa3, 0xde, 0xcf, 0x32, 0x37,
	0x3c, 0x98, 0x10, 0x28, 0x1d, 0xf8, 0x11, 0x6b, 0xf2, 0x0c, 0x4a, 0x3e, 0xe3, 0x49, 0xbd, 0xd0,
	0x28, 0xb6, 0x2a, 0xed, 0xb3, 0x5c, 0x5f, 0x18, 0xa0, 0xa2, 0x44, 0x9e, 0xc3, 0x79, 0x12, 0xc6,
	0x29, 0x5b, 0xd8, 0x73, 0xbe, 0xbb, 0x1f, 0x4c, 0x46, 0xa7, 0x55, 0x59, 0xb8, 0xe2, 0xf2, 0x96,
	0xc8, 0x67, 0x50, 0x0d, 0xd8, 0x0f, 0x2c, 0x49, 0xed, 0xe3, 0x8c, 0x0c, 0x89, 0x66, 0x77, 0xe9,
	0x0b, 0x4b, 0xf8, 0x1b, 0x21, 0x26, 0x14, 0x63, 0x76, 0x2f, 0x1c, 0x15, 0x29, 0x2e, 0x49, 0x4b,
	0x0c, 0x8d, 0x7e, 0x73, 0x53, 0xbb, 0xa1, 0x11, 0xa4, 0xbb, 0x2a, 0x1e, 0xb6, 0xf7, 0x25, 0x06,
	0x93, 0xa6, 0x8c, 0xdc, 0x14, 0x26, 0xdd, 0xfc, 0xb1, 0x00, 0x65, 0xcb, 0x5b, 0x0d, 0x98, 0xb3,
	0x60, 0x31, 0xf9, 0x06, 0xce, 0x13, 0x6f, 0x15, 0xb0, 0xf8, 0xf0, 0x1d, 0x29, 0xff, 0xf1, 0xc3,
	0xa8, 0x49, 0xea, 0xfe, 0x19, 0xe1, 0x89, 0xb2, 0xfb, 0xf8, 0xf2, 0x0c, 0x89, 0x66, 0x21, 0x3c,
	0x07, 0x7d, 0xed, 0x24, 0x6b, 0x21, 0xad, 0x0a, 0xe9, 0xaa, 0x90, 0x1e, 0x38, 0xc9, 0x5a, 0x0a,
	0x6b, 0x6b, 0xb9, 0x24, 0x9f, 0x40, 0x79, 0x2d, 0x8c, 0xd9, 0xc9, 0x43, 0x5d, 0x6b, 0x28, 0xad,
	0x33, 0xaa, 0x4b, 0xc0, 0x7a, 0x20, 0x5f, 0x41, 0x2d, 0x2b, 0xb2, 0xc0, 0x0d, 0x17, 0x5e, 0xb0,
	0xaa, 0xeb, 0x99, 0x9c, 0xf8, 0xa6, 0xf4, 0x33, 0x94, 0x56, 0x25, 0x2d, 0xdf, 0x8b, 0x27, 0x16,
	0x2e, 0x38, 0x6a, 0x96, 0x1b, 0x4a, 0xab, 0x44, 0x55, 0xdc, 0x5a, 0x0f, 0x97, 0x13, 0x19, 0x3c,
	0x3e, 0x8d, 0x1a, 0x54, 0x6e, 0x83, 0x24, 0x62, 0xae, 0xb7, 0xf4, 0xd8, 0xc2, 0x3c, 0x21, 0x26,
	0x18, 0x16, 0xdf, 0x6c, 0x58, 0x1a, 0x7b, 0xee, 0x88, 0x71, 0x53, 0x21, 0xe7, 0x70, 0xd6, 0x4d,
	0x0e, 0xa1, 0x02, 0xa9, 0x02, 0x58, 0xde, 0x2a, 0xf0, 0x82, 0x15, 0xee, 0x8b, 0x97, 0x9d, 0xec,
	0x7b, 0x26, 0x03, 0x43, 0xd1, 0xeb, 0xfe, 0x9b, 0xee, 0xed, 0xbb, 0x99, 0x3d, 0x1a, 0xce, 0xcc,
	0x13, 0xa2, 0x43, 0x69, 0xec, 0xf4, 0xee, 0x4c, 0x85, 0x54, 0x40, 0xeb, 0x5f, 0xb7, 0x3b, 0x9d,
	0x57, 0x5f, 0x9b, 0x85, 0xcb, 0x9f, 0x14, 0x28, 0xef, 0xd2, 0x20, 0x4f, 0xc0, 0xcc, 0xbb, 0x06,
	0x5d, 0x6b, 0x90, 0xb5, 0x3e, 0x01, 0xf3, 0x1d, 0x5b, 0x39, 0x2e, 0x1f, 0x31, 0xd7, 0x75, 0x7c,
	0xbb, 0xdd, 0xf9, 0xd2, 0x54, 0xfe, 0x85, 0x76, 0x5e, 0xb5, 0xcd, 0x02, 0x31, 0x40, 0xb7, 0x06,
	0xdd, 0xd7, 0x82, 0x53, 0xdc, 0xed, 0xb0, 0x56, 0x42, 0x4f, 0x57, 0x77, 0x8e, 0xcf, 0xda, 0x73,
	0x51, 0x3e, 0x3d, 0x04, 0x90, 0xa1, 0x5e, 0xfe, 0xa6, 0x80, 0x96, 0x7d, 0xa0, 0xd0, 0xb0, 0x35,
	0x7c, 0x3b, 0x36, 0x4f, 0x90, 0xd6, 0x1f, 0xf7, 0xe8, 0xfb, 0xe9, 0xcc, 0xb6, 0xde, 0xdf, 0x98,
	0x8a, 0x1c, 0x6e, 0x0f, 0x14, 0xc8, 0x07, 0x50, 0xcb, 0x19, 0xb3, 0x89, 0x3d, 0xed, 0xf7, 0xa9,
	0x59, 0x24, 0x4f, 0xe1, 0x3c, 0x67, 0xbd, 0xa1, 0x93, 0x1b, 0x09, 0x97, 0x90, 0x3b, 0xbc, 0x99,
	0x4e, 0xe8, 0xcc, 0xbe, 0xb5, 0x86, 0xe3, 0xb7, 0xf6, 0xf4, 0x3b, 0xf3, 0x54, 0x08, 0x7c, 0x7f,
	0x0c, 0xaa, 0x38, 0x61, 0xc6, 0xdc, 0xf7, 0x6b, 0x84, 0x40, 0x35, 0xa3, 0xe6, 0x47, 0xe9, 0x57,
	0xe6, 0xef, 0x8f, 0x17, 0xca, 0x1f, 0x8f, 0x17, 0xca, 0x9f, 0x8f, 0x17, 0xca, 0x2f, 0x7f, 0x5d,
	0x9c, 0xcc, 0x55, 0xf1, 0x6f, 0xe6, 0xf5, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xcc, 0x3c, 0xcc,
	0xe6, 0x8d, 0x06, 0x00, 0x00,
}

func (m *CryptOpArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CryptOpArgs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CryptOp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSki(dAtA, i, uint64(m.CryptOp))
	}
	if m.DefaultCryptoKit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSki(dAtA, i, uint64(m.DefaultCryptoKit))
	}
	if len(m.BufIn) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSki(dAtA, i, uint64(len(m.BufIn)))
		i += copy(dAtA[i:], m.BufIn)
	}
	if m.OpKey != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSki(dAtA, i, uint64(m.OpKey.Size()))
		n1, err1 := m.OpKey.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if len(m.PeerKey) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSki(dAtA, i, uint64(len(m.PeerKey)))
		i += copy(dAtA[i:], m.PeerKey)
	}
	if m.TomeIn != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSki(dAtA, i, uint64(m.TomeIn.Size()))
		n2, err2 := m.TomeIn.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CryptOpOut) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CryptOpOut) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BufOut) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSki(dAtA, i, uint64(len(m.BufOut)))
		i += copy(dAtA[i:], m.BufOut)
	}
	if len(m.OpPubKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSki(dAtA, i, uint64(len(m.OpPubKey)))
		i += copy(dAtA[i:], m.OpPubKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KeyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSki(dAtA, i, uint64(m.KeyType))
	}
	if m.CryptoKit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSki(dAtA, i, uint64(m.CryptoKit))
	}
	if m.TimeCreated != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSki(dAtA, i, uint64(m.TimeCreated))
	}
	if len(m.PubKey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSki(dAtA, i, uint64(len(m.PubKey)))
		i += copy(dAtA[i:], m.PubKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KeyRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyRef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.KeyringName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSki(dAtA, i, uint64(len(m.KeyringName)))
		i += copy(dAtA[i:], m.KeyringName)
	}
	if len(m.PubKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSki(dAtA, i, uint64(len(m.PubKey)))
		i += copy(dAtA[i:], m.PubKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KeyEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSki(dAtA, i, uint64(m.KeyInfo.Size()))
		n3, err3 := m.KeyInfo.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	if len(m.PrivKey) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSki(dAtA, i, uint64(len(m.PrivKey)))
		i += copy(dAtA[i:], m.PrivKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Keyring) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Keyring) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSki(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Keys) > 0 {
		for _, msg := range m.Keys {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSki(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SortedByPubKey {
		dAtA[i] = 0x18
		i++
		if m.SortedByPubKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.NewestPubKey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSki(dAtA, i, uint64(len(m.NewestPubKey)))
		i += copy(dAtA[i:], m.NewestPubKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KeyTome) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyTome) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rev != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSki(dAtA, i, uint64(m.Rev))
	}
	if len(m.Keyrings) > 0 {
		for _, msg := range m.Keyrings {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSki(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SortedByName {
		dAtA[i] = 0x18
		i++
		if m.SortedByName {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SigHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SigHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SignerCryptoKit != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSki(dAtA, i, uint64(m.SignerCryptoKit))
	}
	if len(m.SignerPubKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSki(dAtA, i, uint64(len(m.SignerPubKey)))
		i += copy(dAtA[i:], m.SignerPubKey)
	}
	if m.HashKit != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintSki(dAtA, i, uint64(m.HashKit))
	}
	if m.HeaderSz != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintSki(dAtA, i, uint64(m.HeaderSz))
	}
	if m.HeaderEncoding != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintSki(dAtA, i, uint64(m.HeaderEncoding))
	}
	if m.BodySz != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintSki(dAtA, i, uint64(m.BodySz))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintSki(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CryptOpArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CryptOp != 0 {
		n += 1 + sovSki(uint64(m.CryptOp))
	}
	if m.DefaultCryptoKit != 0 {
		n += 1 + sovSki(uint64(m.DefaultCryptoKit))
	}
	l = len(m.BufIn)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	if m.OpKey != nil {
		l = m.OpKey.Size()
		n += 1 + l + sovSki(uint64(l))
	}
	l = len(m.PeerKey)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	if m.TomeIn != nil {
		l = m.TomeIn.Size()
		n += 1 + l + sovSki(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CryptOpOut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BufOut)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	l = len(m.OpPubKey)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyType != 0 {
		n += 1 + sovSki(uint64(m.KeyType))
	}
	if m.CryptoKit != 0 {
		n += 1 + sovSki(uint64(m.CryptoKit))
	}
	if m.TimeCreated != 0 {
		n += 1 + sovSki(uint64(m.TimeCreated))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyringName)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyInfo != nil {
		l = m.KeyInfo.Size()
		n += 1 + l + sovSki(uint64(l))
	}
	l = len(m.PrivKey)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Keyring) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	if len(m.Keys) > 0 {
		for _, e := range m.Keys {
			l = e.Size()
			n += 1 + l + sovSki(uint64(l))
		}
	}
	if m.SortedByPubKey {
		n += 2
	}
	l = len(m.NewestPubKey)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyTome) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rev != 0 {
		n += 1 + sovSki(uint64(m.Rev))
	}
	if len(m.Keyrings) > 0 {
		for _, e := range m.Keyrings {
			l = e.Size()
			n += 1 + l + sovSki(uint64(l))
		}
	}
	if m.SortedByName {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SigHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SignerCryptoKit != 0 {
		n += 1 + sovSki(uint64(m.SignerCryptoKit))
	}
	l = len(m.SignerPubKey)
	if l > 0 {
		n += 1 + l + sovSki(uint64(l))
	}
	if m.HashKit != 0 {
		n += 1 + sovSki(uint64(m.HashKit))
	}
	if m.HeaderSz != 0 {
		n += 1 + sovSki(uint64(m.HeaderSz))
	}
	if m.HeaderEncoding != 0 {
		n += 1 + sovSki(uint64(m.HeaderEncoding))
	}
	if m.BodySz != 0 {
		n += 1 + sovSki(uint64(m.BodySz))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSki(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSki(x uint64) (n int) {
	return sovSki(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CryptOpArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CryptOpArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CryptOpArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CryptOp", wireType)
			}
			m.CryptOp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CryptOp |= CryptOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultCryptoKit", wireType)
			}
			m.DefaultCryptoKit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultCryptoKit |= CryptoKitID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufIn", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BufIn = append(m.BufIn[:0], dAtA[iNdEx:postIndex]...)
			if m.BufIn == nil {
				m.BufIn = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpKey == nil {
				m.OpKey = &KeyRef{}
			}
			if err := m.OpKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerKey = append(m.PeerKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PeerKey == nil {
				m.PeerKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TomeIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TomeIn == nil {
				m.TomeIn = &KeyTome{}
			}
			if err := m.TomeIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CryptOpOut) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CryptOpOut: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CryptOpOut: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufOut", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BufOut = append(m.BufOut[:0], dAtA[iNdEx:postIndex]...)
			if m.BufOut == nil {
				m.BufOut = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpPubKey = append(m.OpPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.OpPubKey == nil {
				m.OpPubKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			m.KeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyType |= KeyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CryptoKit", wireType)
			}
			m.CryptoKit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CryptoKit |= CryptoKitID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeCreated", wireType)
			}
			m.TimeCreated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeCreated |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyringName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyringName = append(m.KeyringName[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyringName == nil {
				m.KeyringName = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyInfo == nil {
				m.KeyInfo = &KeyInfo{}
			}
			if err := m.KeyInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivKey = append(m.PrivKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrivKey == nil {
				m.PrivKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Keyring) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Keyring: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Keyring: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, &KeyEntry{})
			if err := m.Keys[len(m.Keys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortedByPubKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SortedByPubKey = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewestPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewestPubKey = append(m.NewestPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.NewestPubKey == nil {
				m.NewestPubKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyTome) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyTome: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyTome: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			m.Rev = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rev |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyrings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyrings = append(m.Keyrings, &Keyring{})
			if err := m.Keyrings[len(m.Keyrings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortedByName", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SortedByName = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SigHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSki
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SigHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SigHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignerCryptoKit", wireType)
			}
			m.SignerCryptoKit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignerCryptoKit |= CryptoKitID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignerPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSki
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSki
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignerPubKey = append(m.SignerPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SignerPubKey == nil {
				m.SignerPubKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashKit", wireType)
			}
			m.HashKit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HashKit |= HashKitID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderSz", wireType)
			}
			m.HeaderSz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeaderSz |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderEncoding", wireType)
			}
			m.HeaderEncoding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeaderEncoding |= plan.Encoding(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodySz", wireType)
			}
			m.BodySz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSki
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BodySz |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSki(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSki
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSki(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSki
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSki
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSki
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSki
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthSki
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSki
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSki(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthSki
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSki = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSki   = fmt.Errorf("proto: integer overflow")
)
