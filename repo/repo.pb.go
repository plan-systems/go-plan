// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: repo/repo.proto

package repo

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Const int32

const (
	Const_ConstDefs Const = 0
	// TIDSz is the byte size of a TID, a hash with a leading embedded big endian binary time index.
	// The purpose of a TID is that it can be sorted chronologically in order to facilitate
	// storage, searching, and syndication in large-scale (real-world) TID blob repositories.
	//
	// Byte layout is designed so that TIDs are sortable by the embedded timestamp:
	//    0:6   - Standard UTC timestamp in unix seconds (big endian)
	//    6:8   - Timestamp fraction (big endian)
	//    8:30  - Signature/hash
	Const_TIDSz Const = 30
	// TIDEncodedLen is the ASCII-compatible string length of a (binary) TID encoded into its base32 form.
	Const_TIDEncodedLen Const = 48
	// TIDTimestampSz is the number of left-hand bytes in a TID reserved for a time index value.
	Const_TIDTimestampSz Const = 8
	// DefaultGrpcServicePort is the TCP port the service RepoGrpc should run on by default.
	Const_DefaultGrpcServicePort Const = 5192
)

var Const_name = map[int32]string{
	0:    "ConstDefs",
	30:   "TIDSz",
	48:   "TIDEncodedLen",
	8:    "TIDTimestampSz",
	5192: "DefaultGrpcServicePort",
}

var Const_value = map[string]int32{
	"ConstDefs":              0,
	"TIDSz":                  30,
	"TIDEncodedLen":          48,
	"TIDTimestampSz":         8,
	"DefaultGrpcServicePort": 5192,
}

func (x Const) String() string {
	return proto.EnumName(Const_name, int32(x))
}

func (Const) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{0}
}

// ChReqOp is a code describing the purpose and format of the ChReq that it resides in.
type ChReqOp int32

const (
	// Auto means to see if ChReq.PutReq or ChReq.GetReq is set and execute whichever is set.
	ChReqOp_Auto ChReqOp = 0
	// CancelReq tells the server to close/cancel the ChReq referenced by ChReq.ReqID.
	ChReqOp_CancelReq ChReqOp = 1
	// Modifies session access, allowing a caller to do things like:
	//   - establish access as a specific identity
	//   - supply a crypto info, ultimately allowing decryption to occur for subsequent access.
	ChReqOp_AccessGrant ChReqOp = 2
)

var ChReqOp_name = map[int32]string{
	0: "Auto",
	1: "CancelReq",
	2: "AccessGrant",
}

var ChReqOp_value = map[string]int32{
	"Auto":        0,
	"CancelReq":   1,
	"AccessGrant": 2,
}

func (x ChReqOp) String() string {
	return proto.EnumName(ChReqOp_name, int32(x))
}

func (ChReqOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{1}
}

// KeypathScope specifies which entires are considered relevant to a given Keypath.
type KeypathScope int32

const (
	KeypathScope_NoScope        KeypathScope = 0
	KeypathScope_EntryAtKeypath KeypathScope = 1
	KeypathScope_Shallow        KeypathScope = 2
	KeypathScope_ShallowAndDeep KeypathScope = 4
)

var KeypathScope_name = map[int32]string{
	0: "NoScope",
	1: "EntryAtKeypath",
	2: "Shallow",
	4: "ShallowAndDeep",
}

var KeypathScope_value = map[string]int32{
	"NoScope":        0,
	"EntryAtKeypath": 1,
	"Shallow":        2,
	"ShallowAndDeep": 4,
}

func (x KeypathScope) String() string {
	return proto.EnumName(KeypathScope_name, int32(x))
}

func (KeypathScope) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{2}
}

type ResolveMode int32

const (
	ResolveMode_Raw                 ResolveMode = 0
	ResolveMode_ResolveByTime       ResolveMode = 1
	ResolveMode_ResolveByMemberRank ResolveMode = 2
	ResolveMode_ResolveByGrantRank  ResolveMode = 3
)

var ResolveMode_name = map[int32]string{
	0: "Raw",
	1: "ResolveByTime",
	2: "ResolveByMemberRank",
	3: "ResolveByGrantRank",
}

var ResolveMode_value = map[string]int32{
	"Raw":                 0,
	"ResolveByTime":       1,
	"ResolveByMemberRank": 2,
	"ResolveByGrantRank":  3,
}

func (x ResolveMode) String() string {
	return proto.EnumName(ResolveMode_name, int32(x))
}

func (ResolveMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{3}
}

// NodeOp is a collection of NodeOp values that express how a Node is to be interpreted.
type NodeOp int32

const (
	// NodeUpdate means this Node should update/overwrite the Node that is already at the given Keypath.
	NodeOp_NodeUpdate NodeOp = 0
	// NodeRemove means the Node at the given Keypath path should be deleted/removed.
	NodeOp_NodeRemove NodeOp = 2
	// NodeRemoveAll is similar to NodeRemove, but includes all sub keypaths.
	NodeOp_NodeRemoveAll NodeOp = 3
	// ReqComplete means the referenced request (via Node.ReqID) has successfully completed.
	// Other values in the Node are contextual based on request that was completed.
	NodeOp_ReqComplete NodeOp = 10
	// ReqDiscarded means the referenced request failed and/or has been canceled.
	// If Node.Attachment != nil, then it is a serialized ReqErr describing why it was discarded.
	// As with ReqComplete, the referenced request is now complete, so the given ReqID is now available for (re)use.
	NodeOp_ReqDiscarded NodeOp = 11
	// ChSyncSuspend signals to the client that a state update is about to be sent (in the form of a sequence of entry ops).
	// When all state change messages have been sent, the server sends ChSyncResume.
	NodeOp_ChSyncSuspend NodeOp = 20
	// ChSyncResume signals that all pending state changes are have been sent (i.e. channel state is now synced)
	// If Node.Str is set, it's set to a StateURI that represents the current channel state.
	NodeOp_ChSyncResume NodeOp = 21
)

var NodeOp_name = map[int32]string{
	0:  "NodeUpdate",
	2:  "NodeRemove",
	3:  "NodeRemoveAll",
	10: "ReqComplete",
	11: "ReqDiscarded",
	20: "ChSyncSuspend",
	21: "ChSyncResume",
}

var NodeOp_value = map[string]int32{
	"NodeUpdate":    0,
	"NodeRemove":    2,
	"NodeRemoveAll": 3,
	"ReqComplete":   10,
	"ReqDiscarded":  11,
	"ChSyncSuspend": 20,
	"ChSyncResume":  21,
}

func (x NodeOp) String() string {
	return proto.EnumName(NodeOp_name, int32(x))
}

func (NodeOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{4}
}

type NodeScaleMode int32

const (
	NodeScaleMode_AutoScale  NodeScaleMode = 0
	NodeScaleMode_FixedScale NodeScaleMode = 1
)

var NodeScaleMode_name = map[int32]string{
	0: "AutoScale",
	1: "FixedScale",
}

var NodeScaleMode_value = map[string]int32{
	"AutoScale":  0,
	"FixedScale": 1,
}

func (x NodeScaleMode) String() string {
	return proto.EnumName(NodeScaleMode_name, int32(x))
}

func (NodeScaleMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{5}
}

type TextFormat int32

const (
	TextFormat_PlainText TextFormat = 0
	TextFormat_RTF       TextFormat = 1
	TextFormat_HTML      TextFormat = 2
)

var TextFormat_name = map[int32]string{
	0: "PlainText",
	1: "RTF",
	2: "HTML",
}

var TextFormat_value = map[string]int32{
	"PlainText": 0,
	"RTF":       1,
	"HTML":      2,
}

func (x TextFormat) String() string {
	return proto.EnumName(TextFormat_name, int32(x))
}

func (TextFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{6}
}

// ErrCode expresses status and error codes.
type ErrCode int32

const (
	ErrCode_NoErr                   ErrCode = 0
	ErrCode_UnnamedErr              ErrCode = 5000
	ErrCode_InternalErr             ErrCode = 5001
	ErrCode_UnsupporteReqOp         ErrCode = 5002
	ErrCode_ReqCanceled             ErrCode = 5003
	ErrCode_ShuttingDown            ErrCode = 5004
	ErrCode_Disconnected            ErrCode = 5005
	ErrCode_ReqIDNotFound           ErrCode = 5010
	ErrCode_InvalidKeypath          ErrCode = 5020
	ErrCode_InvalidURI              ErrCode = 5021
	ErrCode_FailedToOpenChURI       ErrCode = 5022
	ErrCode_NothingToCommit         ErrCode = 5030
	ErrCode_CommitFailed            ErrCode = 5031
	ErrCode_DomainNotFound          ErrCode = 5032
	ErrCode_CorruptChEntry          ErrCode = 5040
	ErrCode_ViolatesAppendOnly      ErrCode = 5100
	ErrCode_InsufficientPermissions ErrCode = 5101
	ErrCode_ChProtocolNotRecognized ErrCode = 5201
)

var ErrCode_name = map[int32]string{
	0:    "NoErr",
	5000: "UnnamedErr",
	5001: "InternalErr",
	5002: "UnsupporteReqOp",
	5003: "ReqCanceled",
	5004: "ShuttingDown",
	5005: "Disconnected",
	5010: "ReqIDNotFound",
	5020: "InvalidKeypath",
	5021: "InvalidURI",
	5022: "FailedToOpenChURI",
	5030: "NothingToCommit",
	5031: "CommitFailed",
	5032: "DomainNotFound",
	5040: "CorruptChEntry",
	5100: "ViolatesAppendOnly",
	5101: "InsufficientPermissions",
	5201: "ChProtocolNotRecognized",
}

var ErrCode_value = map[string]int32{
	"NoErr":                   0,
	"UnnamedErr":              5000,
	"InternalErr":             5001,
	"UnsupporteReqOp":         5002,
	"ReqCanceled":             5003,
	"ShuttingDown":            5004,
	"Disconnected":            5005,
	"ReqIDNotFound":           5010,
	"InvalidKeypath":          5020,
	"InvalidURI":              5021,
	"FailedToOpenChURI":       5022,
	"NothingToCommit":         5030,
	"CommitFailed":            5031,
	"DomainNotFound":          5032,
	"CorruptChEntry":          5040,
	"ViolatesAppendOnly":      5100,
	"InsufficientPermissions": 5101,
	"ChProtocolNotRecognized": 5201,
}

func (x ErrCode) String() string {
	return proto.EnumName(ErrCode_name, int32(x))
}

func (ErrCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{7}
}

// TxnStatus describes the status of a Tx or RawTx
type TxnStatus int32

const (
	// New means tx is yet to be committed to storage
	TxnStatus_New TxnStatus = 0
)

var TxnStatus_name = map[int32]string{
	0: "New",
}

var TxnStatus_value = map[string]int32{
	"New": 0,
}

func (x TxnStatus) String() string {
	return proto.EnumName(TxnStatus_name, int32(x))
}

func (TxnStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{8}
}

// GetOp gets the all the channel entries for the given Keypath and the specified scope.
type GetOp struct {
	// Keypath and Scope together imply which entries are returned.
	Keypath string       `protobuf:"bytes,2,opt,name=Keypath,proto3" json:"Keypath,omitempty"`
	Scope   KeypathScope `protobuf:"varint,3,opt,name=Scope,proto3,enum=repo.KeypathScope" json:"Scope,omitempty"`
	// MaintainSync causes the ChReq to remain open and receive state updates for qualifying keypaths via ChSyncSuspend/ChSyncResume
	MaintainSync         bool     `protobuf:"varint,9,opt,name=MaintainSync,proto3" json:"MaintainSync,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetOp) Reset()         { *m = GetOp{} }
func (m *GetOp) String() string { return proto.CompactTextString(m) }
func (*GetOp) ProtoMessage()    {}
func (*GetOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{0}
}
func (m *GetOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOp.Merge(m, src)
}
func (m *GetOp) XXX_Size() int {
	return m.Size()
}
func (m *GetOp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOp.DiscardUnknown(m)
}

var xxx_messageInfo_GetOp proto.InternalMessageInfo

func (m *GetOp) GetKeypath() string {
	if m != nil {
		return m.Keypath
	}
	return ""
}

func (m *GetOp) GetScope() KeypathScope {
	if m != nil {
		return m.Scope
	}
	return KeypathScope_NoScope
}

func (m *GetOp) GetMaintainSync() bool {
	if m != nil {
		return m.MaintainSync
	}
	return false
}

// TxOp atomically commits Entries[] (patches) to the given channel URI
// In the corresponding reply ReqComplete message, Node.Attachment is set to the resulting TxID.
type TxOp struct {
	// ChStateURI expresses the channel URI that this op applies to.
	ChStateURI *ChStateURI `protobuf:"bytes,3,opt,name=ChStateURI,proto3" json:"ChStateURI,omitempty"`
	// ChannelGenesis creates a new channel in the domain name specified in ChReq.URI.
	// ChReq.Entries[] are entries that are written into the new channel (and are part of the genesis tx).
	// In the corresponding reply ReqComplete message, Node.Str is set to the URI of the newly created channel.
	ChannelGenesis bool `protobuf:"varint,4,opt,name=ChannelGenesis,proto3" json:"ChannelGenesis,omitempty"`
	// Entries are changes to be applied to the target channel.
	Entries              []*Node  `protobuf:"bytes,6,rep,name=Entries,proto3" json:"Entries,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxOp) Reset()         { *m = TxOp{} }
func (m *TxOp) String() string { return proto.CompactTextString(m) }
func (*TxOp) ProtoMessage()    {}
func (*TxOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{1}
}
func (m *TxOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxOp.Merge(m, src)
}
func (m *TxOp) XXX_Size() int {
	return m.Size()
}
func (m *TxOp) XXX_DiscardUnknown() {
	xxx_messageInfo_TxOp.DiscardUnknown(m)
}

var xxx_messageInfo_TxOp proto.InternalMessageInfo

func (m *TxOp) GetChStateURI() *ChStateURI {
	if m != nil {
		return m.ChStateURI
	}
	return nil
}

func (m *TxOp) GetChannelGenesis() bool {
	if m != nil {
		return m.ChannelGenesis
	}
	return false
}

func (m *TxOp) GetEntries() []*Node {
	if m != nil {
		return m.Entries
	}
	return nil
}

type EnclaveAccess struct {
	// Specifies the key pathname for this operation.
	Keypath string `protobuf:"bytes,1,opt,name=Keypath,proto3" json:"Keypath,omitempty"`
	// This will evolve in time, but in general, the client authenticates by submitting a hash of biometric-based input.
	// (e.g. pin, password, key-fob, bio-fingerprints) and a token from the previous session.
	// From this, a symmetric key is (re)created and used to access the member's primary key hive (for the given Keypath)
	Passhash             []byte   `protobuf:"bytes,5,opt,name=Passhash,proto3" json:"Passhash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnclaveAccess) Reset()         { *m = EnclaveAccess{} }
func (m *EnclaveAccess) String() string { return proto.CompactTextString(m) }
func (*EnclaveAccess) ProtoMessage()    {}
func (*EnclaveAccess) Descriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{2}
}
func (m *EnclaveAccess) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnclaveAccess) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnclaveAccess.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnclaveAccess) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnclaveAccess.Merge(m, src)
}
func (m *EnclaveAccess) XXX_Size() int {
	return m.Size()
}
func (m *EnclaveAccess) XXX_DiscardUnknown() {
	xxx_messageInfo_EnclaveAccess.DiscardUnknown(m)
}

var xxx_messageInfo_EnclaveAccess proto.InternalMessageInfo

func (m *EnclaveAccess) GetKeypath() string {
	if m != nil {
		return m.Keypath
	}
	return ""
}

func (m *EnclaveAccess) GetPasshash() []byte {
	if m != nil {
		return m.Passhash
	}
	return nil
}

// ChReq is generalized request sent from client to server via ServeChannel().
// The client sends a stream of ChReqs and monitors the Nodes that a server sends back to monitor status and completion.
type ChReq struct {
	// ReqOp requests that the given op to be execute on ChReq.Entries
	ReqOp ChReqOp `protobuf:"varint,1,opt,name=ReqOp,proto3,enum=repo.ChReqOp" json:"ReqOp,omitempty"`
	// ReqID is a client-assigned ID that allows the client and server to reference this ChReq in the future.
	// Node.ReqComplete & ReqDiscarded is how the server signals when this request is considered closed/complete.
	ReqID int32 `protobuf:"varint,2,opt,name=ReqID,proto3" json:"ReqID,omitempty"`
	// ChURI identifies the channel URI that this ChReq is requesting to access.
	// Channel URIs take the form of "<DomainName>[/<ChID>]".
	ChURI string `protobuf:"bytes,3,opt,name=ChURI,proto3" json:"ChURI,omitempty"`
	// ChStateURI expresses the channel URI that this op applies to.
	// If not set, it will be auto-assigned by parsing ChReq.ChURI.
	ChStateURI *ChStateURI `protobuf:"bytes,4,opt,name=ChStateURI,proto3" json:"ChStateURI,omitempty"`
	// When ReqOp == ChReqOp.Auto, one of these ops is to be executed.
	// It's an error to set more than one of these.
	GetOp                *GetOp   `protobuf:"bytes,10,opt,name=GetOp,proto3" json:"GetOp,omitempty"`
	TxOp                 *TxOp    `protobuf:"bytes,11,opt,name=TxOp,proto3" json:"TxOp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChReq) Reset()         { *m = ChReq{} }
func (m *ChReq) String() string { return proto.CompactTextString(m) }
func (*ChReq) ProtoMessage()    {}
func (*ChReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{3}
}
func (m *ChReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChReq.Merge(m, src)
}
func (m *ChReq) XXX_Size() int {
	return m.Size()
}
func (m *ChReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ChReq.DiscardUnknown(m)
}

var xxx_messageInfo_ChReq proto.InternalMessageInfo

func (m *ChReq) GetReqOp() ChReqOp {
	if m != nil {
		return m.ReqOp
	}
	return ChReqOp_Auto
}

func (m *ChReq) GetReqID() int32 {
	if m != nil {
		return m.ReqID
	}
	return 0
}

func (m *ChReq) GetChURI() string {
	if m != nil {
		return m.ChURI
	}
	return ""
}

func (m *ChReq) GetChStateURI() *ChStateURI {
	if m != nil {
		return m.ChStateURI
	}
	return nil
}

func (m *ChReq) GetGetOp() *GetOp {
	if m != nil {
		return m.GetOp
	}
	return nil
}

func (m *ChReq) GetTxOp() *TxOp {
	if m != nil {
		return m.TxOp
	}
	return nil
}

// Node is the generalized response object a server sends to the client as it processes each ChReq sent by the client.
// Node is also the standard "atomic" unit of information in a channel.
// A repo channel is a key-value trie data structure where Node.Keypath maps to a Node body.
type Node struct {
	// Op tells the client with this channel open that kind of Node this is.
	Op NodeOp `protobuf:"varint,1,opt,name=Op,proto3,enum=repo.NodeOp" json:"Op,omitempty"`
	// ReqID references the originating ChReq that this Node is in response to.
	ReqID int32 `protobuf:"varint,2,opt,name=ReqID,proto3" json:"ReqID,omitempty"`
	// Keypath is a POSIX-style pathname of this channel entry (for safety, "/" specifies the root path, not "").
	// Each path component in a valid Keypath must have a length of at least 2.
	Keypath string `protobuf:"bytes,5,opt,name=Keypath,proto3" json:"Keypath,omitempty"`
	// RevID is the timestamp when this entry was submitted to the host channel in UTC seconds (where one sec is 2^16 ticks)
	RevID int64 `protobuf:"varint,10,opt,name=RevID,proto3" json:"RevID,omitempty"`
	// ParentRevID identifies the RevID of the Node instance that this node is replacing.
	// If this is 0, a Node at this keypath did not exist when this Node was submitted.
	ParentRevID int64 `protobuf:"varint,11,opt,name=ParentRevID,proto3" json:"ParentRevID,omitempty"`
	// TypeID is a "multi-codec" style (POSIX-style type pathname) that self-describes this Node and the information within it.
	TypeID string `protobuf:"bytes,15,opt,name=TypeID,proto3" json:"TypeID,omitempty"`
	// GlyphURI is a loose analog to the conventional use of "icon" and refer to a unit-sized graphic or volume.
	// Glyph URIs can allow the encoding of arbitrary parameters (such as color), allowing variants to be offered at no cost.
	// A given glyph URI often has both a 2D ("sprite") and 3D object form and is chosen based on where it's instanced.
	GlyphURI  string        `protobuf:"bytes,20,opt,name=GlyphURI,proto3" json:"GlyphURI,omitempty"`
	ScaleMode NodeScaleMode `protobuf:"varint,21,opt,name=ScaleMode,proto3,enum=repo.NodeScaleMode" json:"ScaleMode,omitempty"`
	// Text is a human readable descriptor for this item, with TextFormat describing what format it's in.
	Text       string     `protobuf:"bytes,22,opt,name=Text,proto3" json:"Text,omitempty"`
	TextFormat TextFormat `protobuf:"varint,23,opt,name=TextFormat,proto3,enum=repo.TextFormat" json:"TextFormat,omitempty"`
	// Optional values that can express needed values in accordance of TypeID.
	Str string `protobuf:"bytes,24,opt,name=Str,proto3" json:"Str,omitempty"`
	Int int64  `protobuf:"varint,25,opt,name=Int,proto3" json:"Int,omitempty"`
	// Attachment is useful to attach any buffer, typically decoded based on Node.Op, Node.Keypath, or Node.TypeID.
	// Max size is limited to ~ 3.5MB.
	Attachment []byte `protobuf:"bytes,30,opt,name=Attachment,proto3" json:"Attachment,omitempty"`
	// AssetURI specifies an asset URI (typically implicitly placed at this node's position, scale, and orientation.
	// Asset URIs allow the encoding of arbitrary parameters (such as color), allowing variants to be offered at no cost.
	AssetURI string `protobuf:"bytes,35,opt,name=AssetURI,proto3" json:"AssetURI,omitempty"`
	// X1, X2, and X3 are coordinates or values expressed in any unit.
	// A channel client can later declare how to interpret these coordinates so that a channel server and provide indexed services.
	// Shoutout to the 3 domains that reflect all theoretical completeness: alpha (finite), omega (unending), and the inaccessible cardinal(s).
	// Special thanks to Michael at Vsauce: https://www.youtube.com/watch?v=SrU9YDoXE88
	X1 float64 `protobuf:"fixed64,41,opt,name=X1,proto3" json:"X1,omitempty"`
	X2 float64 `protobuf:"fixed64,42,opt,name=X2,proto3" json:"X2,omitempty"`
	X3 float64 `protobuf:"fixed64,43,opt,name=X3,proto3" json:"X3,omitempty"`
	// Scale1 to Scale3 express the scale of this Node.
	// If all three values are 0, they are all implicitly 1.
	// If Scale2 or Scale3 == 0, then it is implicitly Scale1.
	Scale1 float32 `protobuf:"fixed32,51,opt,name=Scale1,proto3" json:"Scale1,omitempty"`
	Scale2 float32 `protobuf:"fixed32,52,opt,name=Scale2,proto3" json:"Scale2,omitempty"`
	Scale3 float32 `protobuf:"fixed32,53,opt,name=Scale3,proto3" json:"Scale3,omitempty"`
	// Rotate1 - Rotate3 the orientation of this Node using Euler angles.
	Rotate1              float32  `protobuf:"fixed32,60,opt,name=Rotate1,proto3" json:"Rotate1,omitempty"`
	Rotate2              float32  `protobuf:"fixed32,61,opt,name=Rotate2,proto3" json:"Rotate2,omitempty"`
	Rotate3              float32  `protobuf:"fixed32,62,opt,name=Rotate3,proto3" json:"Rotate3,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{4}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetOp() NodeOp {
	if m != nil {
		return m.Op
	}
	return NodeOp_NodeUpdate
}

func (m *Node) GetReqID() int32 {
	if m != nil {
		return m.ReqID
	}
	return 0
}

func (m *Node) GetKeypath() string {
	if m != nil {
		return m.Keypath
	}
	return ""
}

func (m *Node) GetRevID() int64 {
	if m != nil {
		return m.RevID
	}
	return 0
}

func (m *Node) GetParentRevID() int64 {
	if m != nil {
		return m.ParentRevID
	}
	return 0
}

func (m *Node) GetTypeID() string {
	if m != nil {
		return m.TypeID
	}
	return ""
}

func (m *Node) GetGlyphURI() string {
	if m != nil {
		return m.GlyphURI
	}
	return ""
}

func (m *Node) GetScaleMode() NodeScaleMode {
	if m != nil {
		return m.ScaleMode
	}
	return NodeScaleMode_AutoScale
}

func (m *Node) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Node) GetTextFormat() TextFormat {
	if m != nil {
		return m.TextFormat
	}
	return TextFormat_PlainText
}

func (m *Node) GetStr() string {
	if m != nil {
		return m.Str
	}
	return ""
}

func (m *Node) GetInt() int64 {
	if m != nil {
		return m.Int
	}
	return 0
}

func (m *Node) GetAttachment() []byte {
	if m != nil {
		return m.Attachment
	}
	return nil
}

func (m *Node) GetAssetURI() string {
	if m != nil {
		return m.AssetURI
	}
	return ""
}

func (m *Node) GetX1() float64 {
	if m != nil {
		return m.X1
	}
	return 0
}

func (m *Node) GetX2() float64 {
	if m != nil {
		return m.X2
	}
	return 0
}

func (m *Node) GetX3() float64 {
	if m != nil {
		return m.X3
	}
	return 0
}

func (m *Node) GetScale1() float32 {
	if m != nil {
		return m.Scale1
	}
	return 0
}

func (m *Node) GetScale2() float32 {
	if m != nil {
		return m.Scale2
	}
	return 0
}

func (m *Node) GetScale3() float32 {
	if m != nil {
		return m.Scale3
	}
	return 0
}

func (m *Node) GetRotate1() float32 {
	if m != nil {
		return m.Rotate1
	}
	return 0
}

func (m *Node) GetRotate2() float32 {
	if m != nil {
		return m.Rotate2
	}
	return 0
}

func (m *Node) GetRotate3() float32 {
	if m != nil {
		return m.Rotate3
	}
	return 0
}

// ReqErr wraps errors and is typically used in conjunction with NodeOp.ChReqErr
type ReqErr struct {
	Code ErrCode `protobuf:"varint,1,opt,name=Code,proto3,enum=repo.ErrCode" json:"Code,omitempty"`
	// Msg is a human-readable info string that offers amplifying info about the given error.
	Msg                  string   `protobuf:"bytes,2,opt,name=Msg,proto3" json:"Msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReqErr) Reset()         { *m = ReqErr{} }
func (m *ReqErr) String() string { return proto.CompactTextString(m) }
func (*ReqErr) ProtoMessage()    {}
func (*ReqErr) Descriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{5}
}
func (m *ReqErr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReqErr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReqErr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReqErr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqErr.Merge(m, src)
}
func (m *ReqErr) XXX_Size() int {
	return m.Size()
}
func (m *ReqErr) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqErr.DiscardUnknown(m)
}

var xxx_messageInfo_ReqErr proto.InternalMessageInfo

func (m *ReqErr) GetCode() ErrCode {
	if m != nil {
		return m.Code
	}
	return ErrCode_NoErr
}

func (m *ReqErr) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// Tx contains all the info for a channel changeset.
// TODO -- this is a short-term workaround to get things running and it contents will be replaced with proper fields.
type Tx struct {
	// Derivative content (set to nil for serialization)
	TID  []byte `protobuf:"bytes,1,opt,name=TID,proto3" json:"TID,omitempty"`
	Hash []byte `protobuf:"bytes,2,opt,name=Hash,proto3" json:"Hash,omitempty"`
	// Content
	TxOp                 *TxOp    `protobuf:"bytes,10,opt,name=TxOp,proto3" json:"TxOp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tx) Reset()         { *m = Tx{} }
func (m *Tx) String() string { return proto.CompactTextString(m) }
func (*Tx) ProtoMessage()    {}
func (*Tx) Descriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{6}
}
func (m *Tx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tx.Merge(m, src)
}
func (m *Tx) XXX_Size() int {
	return m.Size()
}
func (m *Tx) XXX_DiscardUnknown() {
	xxx_messageInfo_Tx.DiscardUnknown(m)
}

var xxx_messageInfo_Tx proto.InternalMessageInfo

func (m *Tx) GetTID() []byte {
	if m != nil {
		return m.TID
	}
	return nil
}

func (m *Tx) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *Tx) GetTxOp() *TxOp {
	if m != nil {
		return m.TxOp
	}
	return nil
}

// ChStateURI fully specifies a channel URI at a given state.
type ChStateURI struct {
	// DomainName specifies the parent community/context name of the given channel ID.  Domain names are how
	// channel syndication properties, storage quotas, and prioritization are possible at the vault level.
	DomainName string `protobuf:"bytes,1,opt,name=DomainName,proto3" json:"DomainName,omitempty"`
	// ChID_TID specifies a channel's TID for a given domain name.
	// If this is not set, then the channel ID is considered to be non-binary and is contained in ChID.
	ChID_TID []byte `protobuf:"bytes,2,opt,name=ChID_TID,json=ChIDTID,proto3" json:"ChID_TID,omitempty"`
	// ChID is a UTF8 string name of this channel.
	// IF both ChID and ChID_TID are set, ChID is assumed to contain the base32 representation of ChID_TID.
	ChID string `protobuf:"bytes,3,opt,name=ChID,proto3" json:"ChID,omitempty"`
	// StateURI is a token that expresses a specific channel state.
	// If this is not set, the latest state of the channel is implied.
	// By convention this is a POSIX-style pathname in the form "<StateContextID>[/<SubStateID>]*"
	StateURI             string   `protobuf:"bytes,4,opt,name=StateURI,proto3" json:"StateURI,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChStateURI) Reset()         { *m = ChStateURI{} }
func (m *ChStateURI) String() string { return proto.CompactTextString(m) }
func (*ChStateURI) ProtoMessage()    {}
func (*ChStateURI) Descriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{7}
}
func (m *ChStateURI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChStateURI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChStateURI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChStateURI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChStateURI.Merge(m, src)
}
func (m *ChStateURI) XXX_Size() int {
	return m.Size()
}
func (m *ChStateURI) XXX_DiscardUnknown() {
	xxx_messageInfo_ChStateURI.DiscardUnknown(m)
}

var xxx_messageInfo_ChStateURI proto.InternalMessageInfo

func (m *ChStateURI) GetDomainName() string {
	if m != nil {
		return m.DomainName
	}
	return ""
}

func (m *ChStateURI) GetChID_TID() []byte {
	if m != nil {
		return m.ChID_TID
	}
	return nil
}

func (m *ChStateURI) GetChID() string {
	if m != nil {
		return m.ChID
	}
	return ""
}

func (m *ChStateURI) GetStateURI() string {
	if m != nil {
		return m.StateURI
	}
	return ""
}

// RawTx reflects a Tx that has been is packed and sealed.
type RawTx struct {
	// TID identifies this Txn (and is a hash or signature for contained Tx)
	TID []byte `protobuf:"bytes,1,opt,name=TID,proto3" json:"TID,omitempty"`
	// TxnStatus information about the associated txn
	TxnStatus            TxnStatus `protobuf:"varint,2,opt,name=TxnStatus,proto3,enum=repo.TxnStatus" json:"TxnStatus,omitempty"`
	Header               []byte    `protobuf:"bytes,10,opt,name=Header,proto3" json:"Header,omitempty"`
	Body                 []byte    `protobuf:"bytes,11,opt,name=Body,proto3" json:"Body,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *RawTx) Reset()         { *m = RawTx{} }
func (m *RawTx) String() string { return proto.CompactTextString(m) }
func (*RawTx) ProtoMessage()    {}
func (*RawTx) Descriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{8}
}
func (m *RawTx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawTx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawTx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawTx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawTx.Merge(m, src)
}
func (m *RawTx) XXX_Size() int {
	return m.Size()
}
func (m *RawTx) XXX_DiscardUnknown() {
	xxx_messageInfo_RawTx.DiscardUnknown(m)
}

var xxx_messageInfo_RawTx proto.InternalMessageInfo

func (m *RawTx) GetTID() []byte {
	if m != nil {
		return m.TID
	}
	return nil
}

func (m *RawTx) GetTxnStatus() TxnStatus {
	if m != nil {
		return m.TxnStatus
	}
	return TxnStatus_New
}

func (m *RawTx) GetHeader() []byte {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *RawTx) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func init() {
	proto.RegisterEnum("repo.Const", Const_name, Const_value)
	proto.RegisterEnum("repo.ChReqOp", ChReqOp_name, ChReqOp_value)
	proto.RegisterEnum("repo.KeypathScope", KeypathScope_name, KeypathScope_value)
	proto.RegisterEnum("repo.ResolveMode", ResolveMode_name, ResolveMode_value)
	proto.RegisterEnum("repo.NodeOp", NodeOp_name, NodeOp_value)
	proto.RegisterEnum("repo.NodeScaleMode", NodeScaleMode_name, NodeScaleMode_value)
	proto.RegisterEnum("repo.TextFormat", TextFormat_name, TextFormat_value)
	proto.RegisterEnum("repo.ErrCode", ErrCode_name, ErrCode_value)
	proto.RegisterEnum("repo.TxnStatus", TxnStatus_name, TxnStatus_value)
	proto.RegisterType((*GetOp)(nil), "repo.GetOp")
	proto.RegisterType((*TxOp)(nil), "repo.TxOp")
	proto.RegisterType((*EnclaveAccess)(nil), "repo.EnclaveAccess")
	proto.RegisterType((*ChReq)(nil), "repo.ChReq")
	proto.RegisterType((*Node)(nil), "repo.Node")
	proto.RegisterType((*ReqErr)(nil), "repo.ReqErr")
	proto.RegisterType((*Tx)(nil), "repo.Tx")
	proto.RegisterType((*ChStateURI)(nil), "repo.ChStateURI")
	proto.RegisterType((*RawTx)(nil), "repo.RawTx")
}

func init() { proto.RegisterFile("repo/repo.proto", fileDescriptor_9766af4c08a0998e) }

var fileDescriptor_9766af4c08a0998e = []byte{
	// 1417 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0xcf, 0x6f, 0x1b, 0x4f,
	0x15, 0xf7, 0x3a, 0x76, 0x12, 0x3f, 0x3b, 0xce, 0x74, 0x9a, 0x6f, 0xb2, 0xdf, 0x52, 0x19, 0xd7,
	0x45, 0xd8, 0x18, 0x11, 0x1a, 0x1b, 0x6e, 0x14, 0xc9, 0xf5, 0x26, 0xa9, 0x69, 0xe3, 0x58, 0x63,
	0x07, 0x55, 0x5c, 0xd0, 0x74, 0xf7, 0x25, 0x5e, 0xb1, 0x9e, 0xd9, 0xec, 0x8e, 0x93, 0xb8, 0x57,
	0x24, 0xc4, 0xcf, 0x0b, 0x27, 0x0e, 0xc0, 0x11, 0x10, 0x27, 0xfe, 0x8c, 0x5e, 0x90, 0xe0, 0x2f,
	0x00, 0x95, 0x2b, 0xfc, 0x0d, 0xa0, 0x99, 0x5d, 0xdb, 0x9b, 0x8a, 0x4a, 0xdf, 0x8b, 0xfd, 0x3e,
	0x9f, 0xf7, 0xf6, 0xcd, 0xbc, 0xcf, 0x7b, 0x33, 0xbb, 0xb0, 0x1b, 0x61, 0x28, 0xbf, 0xa9, 0x7f,
	0x0e, 0xc3, 0x48, 0x2a, 0x49, 0x0b, 0xda, 0x6e, 0x48, 0x28, 0x9e, 0xa2, 0x3a, 0x0f, 0xa9, 0x0d,
	0x5b, 0xaf, 0x70, 0x11, 0x72, 0x35, 0xb5, 0xf3, 0x75, 0xab, 0x55, 0x62, 0x4b, 0x48, 0x5b, 0x50,
	0x1c, 0xbb, 0x32, 0x44, 0x7b, 0xa3, 0x6e, 0xb5, 0xaa, 0x1d, 0x7a, 0x68, 0x92, 0xa4, 0x5e, 0xe3,
	0x61, 0x49, 0x00, 0x6d, 0x40, 0xe5, 0x8c, 0xfb, 0x42, 0x71, 0x5f, 0x8c, 0x17, 0xc2, 0xb5, 0x4b,
	0x75, 0xab, 0xb5, 0xcd, 0xee, 0x71, 0x8d, 0x9f, 0x58, 0x50, 0x98, 0xdc, 0x9d, 0x87, 0xf4, 0x19,
	0x40, 0x7f, 0x3a, 0x56, 0x5c, 0xe1, 0x05, 0x1b, 0x98, 0xdc, 0xe5, 0x0e, 0x49, 0x72, 0xaf, 0x79,
	0x96, 0x89, 0xa1, 0x5f, 0x85, 0x6a, 0x7f, 0xca, 0x85, 0xc0, 0xe0, 0x14, 0x05, 0xc6, 0x7e, 0x6c,
	0x17, 0xcc, 0x02, 0x1f, 0xb1, 0xf4, 0x2b, 0xb0, 0x75, 0x2c, 0x54, 0xe4, 0x63, 0x6c, 0x6f, 0xd6,
	0x37, 0x5a, 0xe5, 0x0e, 0x24, 0x69, 0x87, 0xd2, 0x43, 0xb6, 0x74, 0x35, 0x8e, 0x61, 0xe7, 0x58,
	0xb8, 0x01, 0xbf, 0xc1, 0x9e, 0xeb, 0x62, 0x1c, 0x67, 0x15, 0xb0, 0xee, 0x2b, 0xf0, 0x08, 0xb6,
	0x47, 0x3c, 0x8e, 0xa7, 0x3c, 0x9e, 0xda, 0xc5, 0xba, 0xd5, 0xaa, 0xb0, 0x15, 0x6e, 0xfc, 0xd5,
	0x82, 0x62, 0x7f, 0xca, 0xf0, 0x9a, 0x3e, 0x85, 0x22, 0xc3, 0xeb, 0xf3, 0xd0, 0x3c, 0x5d, 0xed,
	0xec, 0x2c, 0x6b, 0x31, 0x24, 0x4b, 0x7c, 0x74, 0xcf, 0x04, 0x0d, 0x1c, 0x23, 0x72, 0x91, 0x25,
	0x40, 0xb3, 0xfd, 0xe9, 0x52, 0x86, 0x12, 0x4b, 0xc0, 0x47, 0x0a, 0x15, 0xbe, 0x80, 0x42, 0x4f,
	0xd2, 0x6e, 0xda, 0x60, 0x82, 0xcb, 0x49, 0xb0, 0xa1, 0x58, 0xda, 0xe7, 0x5a, 0x22, 0xbf, 0x5d,
	0x36, 0x11, 0xa9, 0x32, 0x9a, 0x61, 0x86, 0x6f, 0xfc, 0xa3, 0x00, 0x05, 0x2d, 0x14, 0x7d, 0x0c,
	0xf9, 0x55, 0x2d, 0x95, 0xb5, 0x80, 0xe7, 0x21, 0xcb, 0x7f, 0xb2, 0x8e, 0x8c, 0x84, 0xc5, 0xfb,
	0x12, 0x9a, 0xf8, 0x9b, 0x81, 0x63, 0x76, 0xb6, 0xc1, 0x12, 0x40, 0xeb, 0x50, 0x1e, 0xf1, 0x08,
	0x85, 0x4a, 0x7c, 0x65, 0xe3, 0xcb, 0x52, 0x74, 0x1f, 0x36, 0x27, 0x8b, 0x10, 0x07, 0x8e, 0xbd,
	0x6b, 0x12, 0xa6, 0x48, 0xb7, 0xe4, 0x34, 0x58, 0x84, 0x46, 0xb4, 0x3d, 0xe3, 0x59, 0x61, 0x7a,
	0x04, 0xa5, 0xb1, 0xcb, 0x03, 0x3c, 0x93, 0x1e, 0xda, 0x9f, 0x99, 0x02, 0x1e, 0xae, 0x0b, 0x58,
	0xb9, 0xd8, 0x3a, 0x8a, 0x52, 0x28, 0x4c, 0xf0, 0x4e, 0xd9, 0xfb, 0x26, 0x95, 0xb1, 0xb5, 0xfc,
	0xfa, 0xff, 0x44, 0x46, 0x33, 0xae, 0xec, 0x03, 0x93, 0x27, 0x95, 0x7f, 0xcd, 0xb3, 0x4c, 0x0c,
	0x25, 0xb0, 0x31, 0x56, 0x91, 0x6d, 0x9b, 0x24, 0xda, 0xd4, 0xcc, 0x40, 0x28, 0xfb, 0x73, 0x53,
	0x98, 0x36, 0x69, 0x0d, 0xa0, 0xa7, 0x14, 0x77, 0xa7, 0x33, 0x14, 0xca, 0xae, 0x99, 0x69, 0xca,
	0x30, 0xba, 0xb0, 0x5e, 0x1c, 0xa3, 0xd2, 0x85, 0x3d, 0x4d, 0x0a, 0x5b, 0x62, 0x5a, 0x85, 0xfc,
	0x9b, 0x23, 0xfb, 0x6b, 0x75, 0xab, 0x65, 0xb1, 0xfc, 0x9b, 0x23, 0x83, 0x3b, 0x76, 0x3b, 0xc5,
	0x1d, 0x83, 0xbb, 0xf6, 0xd7, 0x53, 0xdc, 0xd5, 0xe2, 0x99, 0x12, 0x8f, 0xec, 0x6e, 0xdd, 0x6a,
	0xe5, 0x59, 0x8a, 0x56, 0x7c, 0xc7, 0xfe, 0x56, 0x86, 0xef, 0xac, 0xf8, 0xae, 0xfd, 0xed, 0x0c,
	0xdf, 0xd5, 0x6d, 0x65, 0x52, 0xcf, 0xd8, 0x91, 0xfd, 0x1d, 0xe3, 0x58, 0xc2, 0xb5, 0xa7, 0x63,
	0x3f, 0xcf, 0x7a, 0x3a, 0x6b, 0x4f, 0xd7, 0xfe, 0x6e, 0xd6, 0xd3, 0x6d, 0x3c, 0x87, 0x4d, 0x86,
	0xd7, 0xc7, 0x51, 0x44, 0x9f, 0x40, 0xa1, 0xaf, 0x7b, 0x74, 0xef, 0xc0, 0x1c, 0x47, 0x91, 0x26,
	0x99, 0x71, 0x69, 0x01, 0xcf, 0xe2, 0xab, 0xf4, 0x4a, 0xd2, 0x66, 0xe3, 0x7b, 0x90, 0x9f, 0xdc,
	0x69, 0x7e, 0x32, 0x70, 0xcc, 0x93, 0x15, 0xa6, 0x4d, 0xdd, 0xc2, 0x97, 0xfa, 0x80, 0xe6, 0x0d,
	0x65, 0xec, 0xd5, 0xb0, 0xc3, 0x27, 0x86, 0xfd, 0x36, 0x7b, 0xc2, 0x74, 0x6b, 0x1c, 0x39, 0xe3,
	0xbe, 0x18, 0xf2, 0x19, 0xa6, 0x77, 0x40, 0x86, 0xa1, 0x9f, 0xc3, 0x76, 0x7f, 0x3a, 0x70, 0x7e,
	0x38, 0x49, 0xc7, 0xbe, 0xc2, 0xb6, 0x34, 0x4e, 0x17, 0xd7, 0x66, 0x7a, 0x7e, 0x8d, 0xad, 0x3b,
	0x79, 0xef, 0xf0, 0x96, 0xd8, 0x0a, 0x37, 0x14, 0x14, 0x19, 0xbf, 0xfd, 0xbf, 0x75, 0x7c, 0x03,
	0x4a, 0x93, 0x3b, 0xa1, 0x23, 0xe7, 0xb1, 0x59, 0xa6, 0xda, 0xd9, 0x5d, 0x6e, 0x3c, 0xa5, 0xd9,
	0x3a, 0x42, 0xf7, 0xec, 0x25, 0x72, 0x0f, 0x23, 0x53, 0x64, 0x85, 0xa5, 0x48, 0xef, 0xe8, 0x85,
	0xf4, 0x16, 0xe6, 0x4c, 0x55, 0x98, 0xb1, 0xdb, 0x08, 0xc5, 0xbe, 0x14, 0xb1, 0xa2, 0x3b, 0x50,
	0x32, 0x86, 0x83, 0x97, 0x31, 0xc9, 0xd1, 0x12, 0x14, 0x27, 0x03, 0x67, 0xfc, 0x8e, 0xd4, 0xe8,
	0x03, 0xd8, 0x99, 0x0c, 0x9c, 0x63, 0xe1, 0x4a, 0x0f, 0xbd, 0xd7, 0x28, 0xc8, 0x33, 0x4a, 0xa1,
	0x3a, 0x19, 0x38, 0x13, 0x7f, 0x86, 0xb1, 0xe2, 0xb3, 0x70, 0xfc, 0x8e, 0x6c, 0xd3, 0x2f, 0xc1,
	0xbe, 0x83, 0x97, 0x7c, 0x1e, 0xa8, 0xd3, 0x28, 0x74, 0xc7, 0x18, 0xdd, 0xf8, 0x2e, 0x8e, 0x64,
	0xa4, 0xc8, 0xfb, 0x56, 0xbb, 0x0b, 0x5b, 0xe9, 0xad, 0x47, 0xb7, 0xa1, 0xd0, 0x9b, 0x2b, 0x49,
	0x72, 0x66, 0x49, 0x2e, 0x5c, 0x0c, 0x18, 0x5e, 0x13, 0x8b, 0xee, 0x42, 0x39, 0xb9, 0x76, 0x4f,
	0x23, 0x2e, 0x14, 0xc9, 0xb7, 0x47, 0x50, 0xc9, 0xbe, 0x52, 0x68, 0x19, 0xb6, 0x86, 0xd2, 0x98,
	0x24, 0xa7, 0xb7, 0xa0, 0xaf, 0xed, 0x45, 0x4f, 0xa5, 0x31, 0xc4, 0xd2, 0x01, 0xe3, 0x29, 0x0f,
	0x02, 0x79, 0x4b, 0xf2, 0x3a, 0x20, 0x05, 0x3d, 0xe1, 0x39, 0x88, 0x21, 0x29, 0xb4, 0x7f, 0x00,
	0x65, 0x86, 0xb1, 0x0c, 0x6e, 0x92, 0x23, 0xbe, 0x05, 0x1b, 0x8c, 0xdf, 0x92, 0x9c, 0x2e, 0x31,
	0xe5, 0x5f, 0x2c, 0x74, 0x55, 0xc4, 0xa2, 0x07, 0xf0, 0x70, 0x45, 0x9d, 0xe1, 0xec, 0x2d, 0x46,
	0x8c, 0x8b, 0x1f, 0x91, 0x3c, 0xdd, 0x07, 0xba, 0x72, 0x98, 0x9d, 0x1a, 0x7e, 0xa3, 0xfd, 0x63,
	0x0b, 0x36, 0x93, 0xdb, 0x90, 0x56, 0x01, 0xb4, 0x75, 0x11, 0x7a, 0x5c, 0xe9, 0xbd, 0xa6, 0x98,
	0xe1, 0x4c, 0xde, 0x20, 0xc9, 0xeb, 0xe5, 0xd6, 0xb8, 0x17, 0x04, 0x64, 0x43, 0x17, 0xcf, 0xf0,
	0xba, 0x2f, 0x67, 0x61, 0x80, 0x0a, 0x09, 0x50, 0x02, 0x15, 0x86, 0xd7, 0x8e, 0x1f, 0xbb, 0x3c,
	0xf2, 0xd0, 0x23, 0x65, 0xfd, 0x54, 0x7f, 0xaa, 0x5f, 0x98, 0xe3, 0x79, 0x1c, 0xa2, 0xf0, 0xc8,
	0x9e, 0x0e, 0x4a, 0x28, 0x86, 0xf1, 0x7c, 0x86, 0xe4, 0xb3, 0xf6, 0x61, 0x92, 0x7a, 0x7d, 0x8d,
	0xed, 0x40, 0x49, 0xcb, 0x6d, 0x88, 0x64, 0x2b, 0x27, 0xfe, 0x1d, 0x7a, 0x09, 0xb6, 0xda, 0x87,
	0xd9, 0x1b, 0x4d, 0x07, 0x8f, 0x02, 0xee, 0x0b, 0x4d, 0x91, 0x9c, 0xd1, 0x67, 0x72, 0x42, 0x2c,
	0xdd, 0xb3, 0x97, 0x93, 0xb3, 0xd7, 0x24, 0xdf, 0xfe, 0x6f, 0x1e, 0xb6, 0xd2, 0xe3, 0xa8, 0x67,
	0x64, 0x28, 0x8f, 0xa3, 0x88, 0xe4, 0xe8, 0x2e, 0xc0, 0x85, 0x10, 0x7c, 0x86, 0x9e, 0xc6, 0x3f,
	0x6d, 0x52, 0x02, 0xe5, 0x81, 0x50, 0x18, 0x09, 0x1e, 0x68, 0xe6, 0x67, 0x4d, 0xba, 0x07, 0xbb,
	0x17, 0x22, 0x9e, 0x87, 0xa1, 0x8c, 0x14, 0x9a, 0x51, 0x20, 0x3f, 0x37, 0x71, 0xba, 0x6e, 0x33,
	0x06, 0xe8, 0x91, 0x5f, 0x34, 0xe9, 0x03, 0xa8, 0x8c, 0xa7, 0x73, 0xa5, 0x7c, 0x71, 0xe5, 0xc8,
	0x5b, 0x41, 0x7e, 0x69, 0x28, 0x2d, 0x84, 0x14, 0x02, 0x5d, 0x85, 0x1e, 0xf9, 0x55, 0x93, 0x52,
	0xdd, 0xb1, 0xeb, 0x81, 0x33, 0x94, 0xea, 0x44, 0xce, 0x85, 0x47, 0x7e, 0xdd, 0xa4, 0x0f, 0xa1,
	0x3a, 0x10, 0x37, 0x3c, 0xf0, 0xbd, 0xe5, 0x48, 0xfc, 0xb6, 0xa9, 0x77, 0x96, 0x92, 0x17, 0x6c,
	0x40, 0x7e, 0xd7, 0xa4, 0xfb, 0xf0, 0xe0, 0x84, 0xfb, 0x01, 0x7a, 0x13, 0x79, 0x1e, 0xa2, 0x30,
	0xef, 0x55, 0xf2, 0x7b, 0xb3, 0xbf, 0xa1, 0x54, 0x53, 0x5f, 0x5c, 0x4d, 0x64, 0x5f, 0xce, 0x66,
	0xbe, 0x22, 0x7f, 0x30, 0x4b, 0x27, 0x20, 0x79, 0x86, 0xfc, 0xd1, 0x2c, 0x93, 0xde, 0x00, 0xcb,
	0xb5, 0xff, 0x64, 0xc8, 0xbe, 0x8c, 0xa2, 0x79, 0xa8, 0xfa, 0x53, 0x33, 0x97, 0xe4, 0x2f, 0x4d,
	0x7a, 0x00, 0xf4, 0xfb, 0xbe, 0x0c, 0xb8, 0xc2, 0xb8, 0x17, 0xea, 0x96, 0x9d, 0x8b, 0x60, 0x41,
	0xfe, 0xdd, 0xa4, 0x8f, 0xe1, 0x60, 0x20, 0xe2, 0xf9, 0xe5, 0xa5, 0xef, 0xfa, 0x28, 0xd4, 0x08,
	0xa3, 0x99, 0x1f, 0xc7, 0xbe, 0x14, 0x31, 0xf9, 0x8f, 0xf1, 0xf6, 0xa7, 0x23, 0xfd, 0x45, 0xe6,
	0xca, 0x60, 0x28, 0x15, 0x43, 0x57, 0x5e, 0x09, 0xff, 0x1d, 0x7a, 0xe4, 0xef, 0xad, 0xf6, 0x5e,
	0xe6, 0x32, 0xd0, 0x1d, 0x1a, 0xe2, 0x2d, 0xc9, 0x75, 0x9e, 0xc3, 0x36, 0xc3, 0x50, 0xea, 0xa3,
	0x47, 0x8f, 0xf4, 0x84, 0x86, 0x32, 0x3d, 0x82, 0x63, 0x34, 0x99, 0x69, 0x39, 0xf3, 0xf1, 0xf1,
	0x28, 0xf3, 0xf9, 0xd3, 0xb2, 0x9e, 0x59, 0x2f, 0xbe, 0xfc, 0xfe, 0x43, 0xcd, 0xfa, 0xdb, 0x87,
	0x9a, 0xf5, 0xcf, 0x0f, 0x35, 0xeb, 0x37, 0xff, 0xaa, 0xe5, 0xfe, 0x9c, 0xaf, 0x8c, 0x02, 0x2e,
	0xc6, 0xce, 0xab, 0x43, 0x9d, 0xeb, 0xed, 0xa6, 0xf9, 0x42, 0xec, 0xfe, 0x2f, 0x00, 0x00, 0xff,
	0xff, 0x8a, 0x03, 0xa6, 0xca, 0x34, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RepoGrpcClient is the client API for RepoGrpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RepoGrpcClient interface {
	// RepoServiceSession opens the specified channel at a given state and executes a stream of requests from the client.
	// The return stream reports completion or status of active requests and remains open as long as the client stream remains open.
	// The beating heart of PLAN: channels, streams, information, security, trust, sessions.
	RepoServiceSession(ctx context.Context, opts ...grpc.CallOption) (RepoGrpc_RepoServiceSessionClient, error)
}

type repoGrpcClient struct {
	cc *grpc.ClientConn
}

func NewRepoGrpcClient(cc *grpc.ClientConn) RepoGrpcClient {
	return &repoGrpcClient{cc}
}

func (c *repoGrpcClient) RepoServiceSession(ctx context.Context, opts ...grpc.CallOption) (RepoGrpc_RepoServiceSessionClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RepoGrpc_serviceDesc.Streams[0], "/repo.RepoGrpc/RepoServiceSession", opts...)
	if err != nil {
		return nil, err
	}
	x := &repoGrpcRepoServiceSessionClient{stream}
	return x, nil
}

type RepoGrpc_RepoServiceSessionClient interface {
	Send(*ChReq) error
	Recv() (*Node, error)
	grpc.ClientStream
}

type repoGrpcRepoServiceSessionClient struct {
	grpc.ClientStream
}

func (x *repoGrpcRepoServiceSessionClient) Send(m *ChReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *repoGrpcRepoServiceSessionClient) Recv() (*Node, error) {
	m := new(Node)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RepoGrpcServer is the server API for RepoGrpc service.
type RepoGrpcServer interface {
	// RepoServiceSession opens the specified channel at a given state and executes a stream of requests from the client.
	// The return stream reports completion or status of active requests and remains open as long as the client stream remains open.
	// The beating heart of PLAN: channels, streams, information, security, trust, sessions.
	RepoServiceSession(RepoGrpc_RepoServiceSessionServer) error
}

// UnimplementedRepoGrpcServer can be embedded to have forward compatible implementations.
type UnimplementedRepoGrpcServer struct {
}

func (*UnimplementedRepoGrpcServer) RepoServiceSession(srv RepoGrpc_RepoServiceSessionServer) error {
	return status.Errorf(codes.Unimplemented, "method RepoServiceSession not implemented")
}

func RegisterRepoGrpcServer(s *grpc.Server, srv RepoGrpcServer) {
	s.RegisterService(&_RepoGrpc_serviceDesc, srv)
}

func _RepoGrpc_RepoServiceSession_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RepoGrpcServer).RepoServiceSession(&repoGrpcRepoServiceSessionServer{stream})
}

type RepoGrpc_RepoServiceSessionServer interface {
	Send(*Node) error
	Recv() (*ChReq, error)
	grpc.ServerStream
}

type repoGrpcRepoServiceSessionServer struct {
	grpc.ServerStream
}

func (x *repoGrpcRepoServiceSessionServer) Send(m *Node) error {
	return x.ServerStream.SendMsg(m)
}

func (x *repoGrpcRepoServiceSessionServer) Recv() (*ChReq, error) {
	m := new(ChReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _RepoGrpc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "repo.RepoGrpc",
	HandlerType: (*RepoGrpcServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RepoServiceSession",
			Handler:       _RepoGrpc_RepoServiceSession_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "repo/repo.proto",
}

func (m *GetOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaintainSync {
		i--
		if m.MaintainSync {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Scope != 0 {
		i = encodeVarintRepo(dAtA, i, uint64(m.Scope))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Keypath) > 0 {
		i -= len(m.Keypath)
		copy(dAtA[i:], m.Keypath)
		i = encodeVarintRepo(dAtA, i, uint64(len(m.Keypath)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TxOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRepo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.ChannelGenesis {
		i--
		if m.ChannelGenesis {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ChStateURI != nil {
		{
			size, err := m.ChStateURI.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRepo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *EnclaveAccess) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnclaveAccess) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnclaveAccess) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Passhash) > 0 {
		i -= len(m.Passhash)
		copy(dAtA[i:], m.Passhash)
		i = encodeVarintRepo(dAtA, i, uint64(len(m.Passhash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Keypath) > 0 {
		i -= len(m.Keypath)
		copy(dAtA[i:], m.Keypath)
		i = encodeVarintRepo(dAtA, i, uint64(len(m.Keypath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TxOp != nil {
		{
			size, err := m.TxOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRepo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.GetOp != nil {
		{
			size, err := m.GetOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRepo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ChStateURI != nil {
		{
			size, err := m.ChStateURI.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRepo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ChURI) > 0 {
		i -= len(m.ChURI)
		copy(dAtA[i:], m.ChURI)
		i = encodeVarintRepo(dAtA, i, uint64(len(m.ChURI)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ReqID != 0 {
		i = encodeVarintRepo(dAtA, i, uint64(m.ReqID))
		i--
		dAtA[i] = 0x10
	}
	if m.ReqOp != 0 {
		i = encodeVarintRepo(dAtA, i, uint64(m.ReqOp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rotate3 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rotate3))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf5
	}
	if m.Rotate2 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rotate2))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xed
	}
	if m.Rotate1 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rotate1))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe5
	}
	if m.Scale3 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale3))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xad
	}
	if m.Scale2 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale2))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa5
	}
	if m.Scale1 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale1))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9d
	}
	if m.X3 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X3))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd9
	}
	if m.X2 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X2))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd1
	}
	if m.X1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X1))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc9
	}
	if len(m.AssetURI) > 0 {
		i -= len(m.AssetURI)
		copy(dAtA[i:], m.AssetURI)
		i = encodeVarintRepo(dAtA, i, uint64(len(m.AssetURI)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if len(m.Attachment) > 0 {
		i -= len(m.Attachment)
		copy(dAtA[i:], m.Attachment)
		i = encodeVarintRepo(dAtA, i, uint64(len(m.Attachment)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.Int != 0 {
		i = encodeVarintRepo(dAtA, i, uint64(m.Int))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if len(m.Str) > 0 {
		i -= len(m.Str)
		copy(dAtA[i:], m.Str)
		i = encodeVarintRepo(dAtA, i, uint64(len(m.Str)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.TextFormat != 0 {
		i = encodeVarintRepo(dAtA, i, uint64(m.TextFormat))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintRepo(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.ScaleMode != 0 {
		i = encodeVarintRepo(dAtA, i, uint64(m.ScaleMode))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.GlyphURI) > 0 {
		i -= len(m.GlyphURI)
		copy(dAtA[i:], m.GlyphURI)
		i = encodeVarintRepo(dAtA, i, uint64(len(m.GlyphURI)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.TypeID) > 0 {
		i -= len(m.TypeID)
		copy(dAtA[i:], m.TypeID)
		i = encodeVarintRepo(dAtA, i, uint64(len(m.TypeID)))
		i--
		dAtA[i] = 0x7a
	}
	if m.ParentRevID != 0 {
		i = encodeVarintRepo(dAtA, i, uint64(m.ParentRevID))
		i--
		dAtA[i] = 0x58
	}
	if m.RevID != 0 {
		i = encodeVarintRepo(dAtA, i, uint64(m.RevID))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Keypath) > 0 {
		i -= len(m.Keypath)
		copy(dAtA[i:], m.Keypath)
		i = encodeVarintRepo(dAtA, i, uint64(len(m.Keypath)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ReqID != 0 {
		i = encodeVarintRepo(dAtA, i, uint64(m.ReqID))
		i--
		dAtA[i] = 0x10
	}
	if m.Op != 0 {
		i = encodeVarintRepo(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReqErr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqErr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReqErr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintRepo(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintRepo(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TxOp != nil {
		{
			size, err := m.TxOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRepo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintRepo(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TID) > 0 {
		i -= len(m.TID)
		copy(dAtA[i:], m.TID)
		i = encodeVarintRepo(dAtA, i, uint64(len(m.TID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChStateURI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChStateURI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChStateURI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StateURI) > 0 {
		i -= len(m.StateURI)
		copy(dAtA[i:], m.StateURI)
		i = encodeVarintRepo(dAtA, i, uint64(len(m.StateURI)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ChID) > 0 {
		i -= len(m.ChID)
		copy(dAtA[i:], m.ChID)
		i = encodeVarintRepo(dAtA, i, uint64(len(m.ChID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChID_TID) > 0 {
		i -= len(m.ChID_TID)
		copy(dAtA[i:], m.ChID_TID)
		i = encodeVarintRepo(dAtA, i, uint64(len(m.ChID_TID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DomainName) > 0 {
		i -= len(m.DomainName)
		copy(dAtA[i:], m.DomainName)
		i = encodeVarintRepo(dAtA, i, uint64(len(m.DomainName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RawTx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawTx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawTx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintRepo(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Header) > 0 {
		i -= len(m.Header)
		copy(dAtA[i:], m.Header)
		i = encodeVarintRepo(dAtA, i, uint64(len(m.Header)))
		i--
		dAtA[i] = 0x52
	}
	if m.TxnStatus != 0 {
		i = encodeVarintRepo(dAtA, i, uint64(m.TxnStatus))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TID) > 0 {
		i -= len(m.TID)
		copy(dAtA[i:], m.TID)
		i = encodeVarintRepo(dAtA, i, uint64(len(m.TID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintRepo(dAtA []byte, offset int, v uint64) int {
	offset -= sovRepo(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GetOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Keypath)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.Scope != 0 {
		n += 1 + sovRepo(uint64(m.Scope))
	}
	if m.MaintainSync {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChStateURI != nil {
		l = m.ChStateURI.Size()
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.ChannelGenesis {
		n += 2
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovRepo(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnclaveAccess) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Keypath)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	l = len(m.Passhash)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReqOp != 0 {
		n += 1 + sovRepo(uint64(m.ReqOp))
	}
	if m.ReqID != 0 {
		n += 1 + sovRepo(uint64(m.ReqID))
	}
	l = len(m.ChURI)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.ChStateURI != nil {
		l = m.ChStateURI.Size()
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.GetOp != nil {
		l = m.GetOp.Size()
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.TxOp != nil {
		l = m.TxOp.Size()
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovRepo(uint64(m.Op))
	}
	if m.ReqID != 0 {
		n += 1 + sovRepo(uint64(m.ReqID))
	}
	l = len(m.Keypath)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.RevID != 0 {
		n += 1 + sovRepo(uint64(m.RevID))
	}
	if m.ParentRevID != 0 {
		n += 1 + sovRepo(uint64(m.ParentRevID))
	}
	l = len(m.TypeID)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	l = len(m.GlyphURI)
	if l > 0 {
		n += 2 + l + sovRepo(uint64(l))
	}
	if m.ScaleMode != 0 {
		n += 2 + sovRepo(uint64(m.ScaleMode))
	}
	l = len(m.Text)
	if l > 0 {
		n += 2 + l + sovRepo(uint64(l))
	}
	if m.TextFormat != 0 {
		n += 2 + sovRepo(uint64(m.TextFormat))
	}
	l = len(m.Str)
	if l > 0 {
		n += 2 + l + sovRepo(uint64(l))
	}
	if m.Int != 0 {
		n += 2 + sovRepo(uint64(m.Int))
	}
	l = len(m.Attachment)
	if l > 0 {
		n += 2 + l + sovRepo(uint64(l))
	}
	l = len(m.AssetURI)
	if l > 0 {
		n += 2 + l + sovRepo(uint64(l))
	}
	if m.X1 != 0 {
		n += 10
	}
	if m.X2 != 0 {
		n += 10
	}
	if m.X3 != 0 {
		n += 10
	}
	if m.Scale1 != 0 {
		n += 6
	}
	if m.Scale2 != 0 {
		n += 6
	}
	if m.Scale3 != 0 {
		n += 6
	}
	if m.Rotate1 != 0 {
		n += 6
	}
	if m.Rotate2 != 0 {
		n += 6
	}
	if m.Rotate3 != 0 {
		n += 6
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReqErr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovRepo(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TID)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.TxOp != nil {
		l = m.TxOp.Size()
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChStateURI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DomainName)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	l = len(m.ChID_TID)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	l = len(m.ChID)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	l = len(m.StateURI)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RawTx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TID)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.TxnStatus != 0 {
		n += 1 + sovRepo(uint64(m.TxnStatus))
	}
	l = len(m.Header)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRepo(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRepo(x uint64) (n int) {
	return sovRepo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keypath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keypath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			m.Scope = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scope |= KeypathScope(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintainSync", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaintainSync = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRepo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChStateURI", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChStateURI == nil {
				m.ChStateURI = &ChStateURI{}
			}
			if err := m.ChStateURI.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelGenesis", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChannelGenesis = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Node{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRepo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnclaveAccess) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnclaveAccess: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnclaveAccess: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keypath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keypath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passhash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Passhash = append(m.Passhash[:0], dAtA[iNdEx:postIndex]...)
			if m.Passhash == nil {
				m.Passhash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRepo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqOp", wireType)
			}
			m.ReqOp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqOp |= ChReqOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqID", wireType)
			}
			m.ReqID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChStateURI", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChStateURI == nil {
				m.ChStateURI = &ChStateURI{}
			}
			if err := m.ChStateURI.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetOp == nil {
				m.GetOp = &GetOp{}
			}
			if err := m.GetOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxOp == nil {
				m.TxOp = &TxOp{}
			}
			if err := m.TxOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRepo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= NodeOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqID", wireType)
			}
			m.ReqID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keypath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keypath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevID", wireType)
			}
			m.RevID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RevID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentRevID", wireType)
			}
			m.ParentRevID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentRevID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlyphURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GlyphURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleMode", wireType)
			}
			m.ScaleMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScaleMode |= NodeScaleMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TextFormat", wireType)
			}
			m.TextFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TextFormat |= TextFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int", wireType)
			}
			m.Int = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Int |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attachment", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attachment = append(m.Attachment[:0], dAtA[iNdEx:postIndex]...)
			if m.Attachment == nil {
				m.Attachment = []byte{}
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 41:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X1", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X1 = float64(math.Float64frombits(v))
		case 42:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X2", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X2 = float64(math.Float64frombits(v))
		case 43:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X3", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X3 = float64(math.Float64frombits(v))
		case 51:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale1 = float32(math.Float32frombits(v))
		case 52:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale2 = float32(math.Float32frombits(v))
		case 53:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale3", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale3 = float32(math.Float32frombits(v))
		case 60:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rotate1 = float32(math.Float32frombits(v))
		case 61:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rotate2 = float32(math.Float32frombits(v))
		case 62:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate3", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rotate3 = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipRepo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqErr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqErr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqErr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= ErrCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRepo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TID = append(m.TID[:0], dAtA[iNdEx:postIndex]...)
			if m.TID == nil {
				m.TID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxOp == nil {
				m.TxOp = &TxOp{}
			}
			if err := m.TxOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRepo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChStateURI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChStateURI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChStateURI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChID_TID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChID_TID = append(m.ChID_TID[:0], dAtA[iNdEx:postIndex]...)
			if m.ChID_TID == nil {
				m.ChID_TID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRepo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawTx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawTx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawTx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TID = append(m.TID[:0], dAtA[iNdEx:postIndex]...)
			if m.TID == nil {
				m.TID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnStatus", wireType)
			}
			m.TxnStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnStatus |= TxnStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Header = append(m.Header[:0], dAtA[iNdEx:postIndex]...)
			if m.Header == nil {
				m.Header = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRepo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRepo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRepo
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRepo
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRepo
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRepo        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRepo          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRepo = fmt.Errorf("proto: unexpected end of group")
)
