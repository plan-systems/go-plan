// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: repo/repo.proto

package repo

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	pdi "github.com/plan-systems/plan-core/pdi" /// Redirected by build-go-proto.sh :)
	plan "github.com/plan-systems/plan-core/plan" /// Redirected by build-go-proto.sh :)
	ski "github.com/plan-systems/plan-core/ski" /// Redirected by build-go-proto.sh :)
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ChSessionFlags int32

const (
	// If set, entry bodies will be included
	ChSessionFlags_INCLUDE_BODY ChSessionFlags = 0
	// IF set, entries that are deferred (in addition to live entries) are included.
	ChSessionFlags_DEFERRED_ENTRIES ChSessionFlags = 1
	// If set, entries with op type EntryOp_POST_CONTENT will be sent
	ChSessionFlags_CONTENT_ENTRIES ChSessionFlags = 2
	// If set, entries with op type EntryOp_NEW_CHANNEL_EPOCH will be sent.
	ChSessionFlags_NEW_EPOCH_ENTRIES ChSessionFlags = 3
)

var ChSessionFlags_name = map[int32]string{
	0: "INCLUDE_BODY",
	1: "DEFERRED_ENTRIES",
	2: "CONTENT_ENTRIES",
	3: "NEW_EPOCH_ENTRIES",
}

var ChSessionFlags_value = map[string]int32{
	"INCLUDE_BODY":      0,
	"DEFERRED_ENTRIES":  1,
	"CONTENT_ENTRIES":   2,
	"NEW_EPOCH_ENTRIES": 3,
}

func (x ChSessionFlags) String() string {
	return proto.EnumName(ChSessionFlags_name, int32(x))
}

func (ChSessionFlags) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{0}
}

type MsgOp int32

const (
	// This Msg functionally does nothing but serves as a heartbeat to indicate the channel session is open and operating normally.
	MsgOp_OK MsgOp = 0
	// Msg.BUF0 is a ski.KeyTome protobuf that contains community keys that should be added to the member session on the repo side.
	MsgOp_ADD_COMMUNITY_KEYS MsgOp = 1
	// When the repo sees this op, it will retain the community keyring up to the given unix timestamp in T0.
	// If the community keyring should not be retained, set T0 to 0 (or any timestamp in the past),
	MsgOp_RETAIN_COMMUNITY_KEYS MsgOp = 2
	// Sent in response to a CH_NEW_ENTRY_READY (to the repo)
	// Msg.ITEMS is a list of raw txns of an entry ready to be committed.
	MsgOp_COMMIT_TXNS MsgOp = 3
	MsgOp_RESERVED_4  MsgOp = 4
	MsgOp_RESERVED_5  MsgOp = 5
	// Sent to the client following OpenMemberSession.
	MsgOp_MEMBER_SESSION_READY MsgOp = 6
	// Sent in response to a COMMIT_TXNS (to the client)
	// msg.EntryInfo and msg EntryState contain info associated with the given txn (may be nil)
	MsgOp_COMMIT_TXNS_COMPLETE MsgOp = 7
	// Sent to the member session when a new channel is to be created.
	// BODY is a marshalled ChannelEpoch.
	MsgOp_CH_GENESIS_ENTRY MsgOp = 8
	MsgOp_RESERVED_9       MsgOp = 9
	// Closes the session associated with the session ID.  Any subsequent Msgs addressed to this session ID will be ignored/dropped.
	MsgOp_CLOSE_CH_SESSION MsgOp = 10
	// Sent by the client when the user wishes to author a new content entry in the channel associated with this sessID.
	// The msg's EntryInfo contains basic info about the entry to build from.
	MsgOp_POST_CH_ENTRY MsgOp = 11
	// The ChSession seek to T0 and start returning a stream of CH_ENTRY msgs, effectively "replaying" the channel.
	// The param FLAGS contains number of ChSessionFlags
	MsgOp_RESET_ENTRY_READER MsgOp = 12
	MsgOp_RESERVED_13        MsgOp = 13
	MsgOp_RESERVED_14        MsgOp = 14
	// Sent to the client when the channel is closed
	MsgOp_CH_SESSION_CLOSED MsgOp = 15
	// The msg's EntryInfo is set and reflects an entry in the channel and BUF0 is the body.
	MsgOp_CH_ENTRY MsgOp = 16
	// Sent when an entry changes liveness
	MsgOp_CH_ENTRY_UPDATE MsgOp = 17
	// Sent in response to a POST_CH_ENTRY or CH_GENESIS_ENTRY to the client.
	// The msg's EntryInfo is ready to be encoded and encrypted with the body.
	// From there, client is expected to:
	//   1) pack+sign the readied EntryInfo with the entry body
	//   2) encrypt this newly generated "payload buffer" with the community key associated with CommunityEpoch cited in the EntryInfo
	//   3) Marshal the encrypted payload and community epoch ID into the final EntryCrypt.
	//   4) Encode the EntryCrypt into StorageProvider txns
	//   5) Submit the resulting txn(s) to the repo via COMMIT_TXNS.
	MsgOp_CH_NEW_ENTRY_READY MsgOp = 18
	MsgOp_RESERVED_19        MsgOp = 19
	MsgOp_RESERVED_20        MsgOp = 20
	// Send by the Workstation to the client.
	// BUF0 is a phost,WsLogin protobuf.
	// The client echos this msg back to the workstation on success.
	MsgOp_LOGIN_TO_WS_SEAT MsgOp = 21
	// BUF0 is the ChID of the channel to open.
	MsgOp_START_CH_SESSION MsgOp = 22
)

var MsgOp_name = map[int32]string{
	0:  "OK",
	1:  "ADD_COMMUNITY_KEYS",
	2:  "RETAIN_COMMUNITY_KEYS",
	3:  "COMMIT_TXNS",
	4:  "RESERVED_4",
	5:  "RESERVED_5",
	6:  "MEMBER_SESSION_READY",
	7:  "COMMIT_TXNS_COMPLETE",
	8:  "CH_GENESIS_ENTRY",
	9:  "RESERVED_9",
	10: "CLOSE_CH_SESSION",
	11: "POST_CH_ENTRY",
	12: "RESET_ENTRY_READER",
	13: "RESERVED_13",
	14: "RESERVED_14",
	15: "CH_SESSION_CLOSED",
	16: "CH_ENTRY",
	17: "CH_ENTRY_UPDATE",
	18: "CH_NEW_ENTRY_READY",
	19: "RESERVED_19",
	20: "RESERVED_20",
	21: "LOGIN_TO_WS_SEAT",
	22: "START_CH_SESSION",
}

var MsgOp_value = map[string]int32{
	"OK":                    0,
	"ADD_COMMUNITY_KEYS":    1,
	"RETAIN_COMMUNITY_KEYS": 2,
	"COMMIT_TXNS":           3,
	"RESERVED_4":            4,
	"RESERVED_5":            5,
	"MEMBER_SESSION_READY":  6,
	"COMMIT_TXNS_COMPLETE":  7,
	"CH_GENESIS_ENTRY":      8,
	"RESERVED_9":            9,
	"CLOSE_CH_SESSION":      10,
	"POST_CH_ENTRY":         11,
	"RESET_ENTRY_READER":    12,
	"RESERVED_13":           13,
	"RESERVED_14":           14,
	"CH_SESSION_CLOSED":     15,
	"CH_ENTRY":              16,
	"CH_ENTRY_UPDATE":       17,
	"CH_NEW_ENTRY_READY":    18,
	"RESERVED_19":           19,
	"RESERVED_20":           20,
	"LOGIN_TO_WS_SEAT":      21,
	"START_CH_SESSION":      22,
}

func (x MsgOp) String() string {
	return proto.EnumName(MsgOp_name, int32(x))
}

func (MsgOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{1}
}

type EntryStatus int32

const (
	// The given entry has been confirmed to be associated with unauthorized activity, a security breach, or inappropriate behavior.
	EntryStatus_DISBARRED EntryStatus = 0
	// This entry has yet to merged into the repo's channel subsystem.
	EntryStatus_AWAITING_MERGE EntryStatus = 1
	// This entry has been merged into the channel.
	EntryStatus_MERGED EntryStatus = 2
	// The given entry is deferred as a result of one of many possibilities encountered during
	// channel entry validation (see design-docs/PLAN-Proof-of-correctness.md). Specifically,
	// this means EntryState.Flags lacks one or more req'd flags in order for the entry to be live.
	EntryStatus_DEFERRED EntryStatus = 3
	// The given entry is considered authentic and a live operating part of the local community repo.
	// The corresponding EntryState.Flags contains all the flags required for an entry to be live.
	EntryStatus_LIVE EntryStatus = 4
)

var EntryStatus_name = map[int32]string{
	0: "DISBARRED",
	1: "AWAITING_MERGE",
	2: "MERGED",
	3: "DEFERRED",
	4: "LIVE",
}

var EntryStatus_value = map[string]int32{
	"DISBARRED":      0,
	"AWAITING_MERGE": 1,
	"MERGED":         2,
	"DEFERRED":       3,
	"LIVE":           4,
}

func (x EntryStatus) String() string {
	return proto.EnumName(EntryStatus_name, int32(x))
}

func (EntryStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{2}
}

// EntryFlags are bit shift values (not actual values)
type EntryFlag int32

const (
	// If not set, one or more parts of this entry are not self-consistent and/or do not self-validate.
	// By definition, once this flag is cleared, it will never reappear.
	EntryFlag_WELL_FORMED EntryFlag = 0
	// Set when this entry's author dependency has been written
	EntryFlag_AUTHOR_DEPENDENCY_WRITTEN EntryFlag = 1
	// Set when this entry's ACC dependency has been written
	EntryFlag_ACC_DEPENDENCY_WRITTEN EntryFlag = 2
	// Set if this entry's URID appears in the community's list of genesis entries.
	EntryFlag_GENESIS_ENTRY_VERIFIED EntryFlag = 3
	// Set if this entryOp == NEW_CHANNEL_EPOCH and has no previous channel epoch TID set.
	EntryFlag_IS_CHANNEL_GENESIS EntryFlag = 4
)

var EntryFlag_name = map[int32]string{
	0: "WELL_FORMED",
	1: "AUTHOR_DEPENDENCY_WRITTEN",
	2: "ACC_DEPENDENCY_WRITTEN",
	3: "GENESIS_ENTRY_VERIFIED",
	4: "IS_CHANNEL_GENESIS",
}

var EntryFlag_value = map[string]int32{
	"WELL_FORMED":               0,
	"AUTHOR_DEPENDENCY_WRITTEN": 1,
	"ACC_DEPENDENCY_WRITTEN":    2,
	"GENESIS_ENTRY_VERIFIED":    3,
	"IS_CHANNEL_GENESIS":        4,
}

func (x EntryFlag) String() string {
	return proto.EnumName(EntryFlag_name, int32(x))
}

func (EntryFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{3}
}

type MemberSessionReq struct {
	// Identifies a workstation/client installation (metaphorical to a "dumb" terminal in the 70's and 80's).
	// Two different members could have member sessions with the same workstation ID into a given repo (but not at the same time).
	WorkstationID []byte `protobuf:"bytes,1,opt,name=workstationID,proto3" json:"workstationID,omitempty"`
	// Which community this session wants to access
	CommunityID []byte `protobuf:"bytes,2,opt,name=communityID,proto3" json:"communityID,omitempty"`
	// The client member's info
	MemberEpoch *pdi.MemberEpoch `protobuf:"bytes,3,opt,name=member_epoch,json=memberEpoch,proto3" json:"member_epoch,omitempty"`
	// This will evolve in time, but in general, the client authenticates by submitting a token,
	//    which is a hash of biometric-based input (e.g. pin, password, key-fob, eye scan) plus
	//    a secure token from the previous session.
	// This is used to create a symmetric key to encrypt/decrypt the member's primary key hive
	//    that resides on the host.
	Passhash []byte `protobuf:"bytes,5,opt,name=passhash,proto3" json:"passhash,omitempty"`
	// When the above symmetric key is created, it's placed it and other session info into a "secret box",
	//    and is locked with a key only the host has has, and sent back as the "session token".
	// This allows the client to present the session_token (until it expires) instead of the client
	//    having to perform full biometric authentication.
	SessionToken         []byte   `protobuf:"bytes,6,opt,name=session_token,json=sessionToken,proto3" json:"session_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MemberSessionReq) Reset()         { *m = MemberSessionReq{} }
func (m *MemberSessionReq) String() string { return proto.CompactTextString(m) }
func (*MemberSessionReq) ProtoMessage()    {}
func (*MemberSessionReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{0}
}
func (m *MemberSessionReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemberSessionReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemberSessionReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemberSessionReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemberSessionReq.Merge(m, src)
}
func (m *MemberSessionReq) XXX_Size() int {
	return m.Size()
}
func (m *MemberSessionReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MemberSessionReq.DiscardUnknown(m)
}

var xxx_messageInfo_MemberSessionReq proto.InternalMessageInfo

func (m *MemberSessionReq) GetWorkstationID() []byte {
	if m != nil {
		return m.WorkstationID
	}
	return nil
}

func (m *MemberSessionReq) GetCommunityID() []byte {
	if m != nil {
		return m.CommunityID
	}
	return nil
}

func (m *MemberSessionReq) GetMemberEpoch() *pdi.MemberEpoch {
	if m != nil {
		return m.MemberEpoch
	}
	return nil
}

func (m *MemberSessionReq) GetPasshash() []byte {
	if m != nil {
		return m.Passhash
	}
	return nil
}

func (m *MemberSessionReq) GetSessionToken() []byte {
	if m != nil {
		return m.SessionToken
	}
	return nil
}

type ChInvocation struct {
	ChID                 []byte   `protobuf:"bytes,1,opt,name=chID,proto3" json:"chID,omitempty"`
	ChAdapterDesc        string   `protobuf:"bytes,10,opt,name=ch_adapter_desc,json=chAdapterDesc,proto3" json:"ch_adapter_desc,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChInvocation) Reset()         { *m = ChInvocation{} }
func (m *ChInvocation) String() string { return proto.CompactTextString(m) }
func (*ChInvocation) ProtoMessage()    {}
func (*ChInvocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{1}
}
func (m *ChInvocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChInvocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChInvocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChInvocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChInvocation.Merge(m, src)
}
func (m *ChInvocation) XXX_Size() int {
	return m.Size()
}
func (m *ChInvocation) XXX_DiscardUnknown() {
	xxx_messageInfo_ChInvocation.DiscardUnknown(m)
}

var xxx_messageInfo_ChInvocation proto.InternalMessageInfo

func (m *ChInvocation) GetChID() []byte {
	if m != nil {
		return m.ChID
	}
	return nil
}

func (m *ChInvocation) GetChAdapterDesc() string {
	if m != nil {
		return m.ChAdapterDesc
	}
	return ""
}

type Msg struct {
	// If originating from the client, this ID should be set to a unique, increasing ID.
	// All Msgs emitted in response to a previous Msg will cite its original ID, allowing the client to filter for a specific ID.
	ID uint32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// Describes the purpose of this op, what args it uses, and what it's intended to do.
	Op MsgOp `protobuf:"varint,2,opt,name=op,proto3,enum=repo.MsgOp" json:"op,omitempty"`
	// When a Msg originates, this value is used to route it to the correct internal channel session.
	// If 0, this msg is to/from the MemberSession itself for control messages, etc.
	ChSessID uint32 `protobuf:"varint,3,opt,name=ch_sessID,json=chSessID,proto3" json:"ch_sessID,omitempty"`
	// If the op involves a channel entry, then it will be set here.
	EntryInfo  *pdi.EntryInfo `protobuf:"bytes,10,opt,name=entry_info,json=entryInfo,proto3" json:"entry_info,omitempty"`
	EntryState *EntryState    `protobuf:"bytes,11,opt,name=entry_state,json=entryState,proto3" json:"entry_state,omitempty"`
	// If set, the op failed for the given reason
	Error string `protobuf:"bytes,12,opt,name=error,proto3" json:"error,omitempty"`
	// Params for the given MsgOp
	T0                   int64    `protobuf:"varint,20,opt,name=T0,proto3" json:"T0,omitempty"`
	FLAGS                uint32   `protobuf:"varint,21,opt,name=FLAGS,proto3" json:"FLAGS,omitempty"`
	BUF0                 []byte   `protobuf:"bytes,22,opt,name=BUF0,proto3" json:"BUF0,omitempty"`
	ITEMS                [][]byte `protobuf:"bytes,23,rep,name=ITEMS,proto3" json:"ITEMS,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Msg) Reset()         { *m = Msg{} }
func (m *Msg) String() string { return proto.CompactTextString(m) }
func (*Msg) ProtoMessage()    {}
func (*Msg) Descriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{2}
}
func (m *Msg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Msg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Msg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Msg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Msg.Merge(m, src)
}
func (m *Msg) XXX_Size() int {
	return m.Size()
}
func (m *Msg) XXX_DiscardUnknown() {
	xxx_messageInfo_Msg.DiscardUnknown(m)
}

var xxx_messageInfo_Msg proto.InternalMessageInfo

func (m *Msg) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Msg) GetOp() MsgOp {
	if m != nil {
		return m.Op
	}
	return MsgOp_OK
}

func (m *Msg) GetChSessID() uint32 {
	if m != nil {
		return m.ChSessID
	}
	return 0
}

func (m *Msg) GetEntryInfo() *pdi.EntryInfo {
	if m != nil {
		return m.EntryInfo
	}
	return nil
}

func (m *Msg) GetEntryState() *EntryState {
	if m != nil {
		return m.EntryState
	}
	return nil
}

func (m *Msg) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *Msg) GetT0() int64 {
	if m != nil {
		return m.T0
	}
	return 0
}

func (m *Msg) GetFLAGS() uint32 {
	if m != nil {
		return m.FLAGS
	}
	return 0
}

func (m *Msg) GetBUF0() []byte {
	if m != nil {
		return m.BUF0
	}
	return nil
}

func (m *Msg) GetITEMS() [][]byte {
	if m != nil {
		return m.ITEMS
	}
	return nil
}

type GenesisSeed struct {
	StorageEpoch         *pdi.StorageEpoch   `protobuf:"bytes,1,opt,name=storage_epoch,json=storageEpoch,proto3" json:"storage_epoch,omitempty"`
	CommunityEpoch       *pdi.CommunityEpoch `protobuf:"bytes,2,opt,name=community_epoch,json=communityEpoch,proto3" json:"community_epoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *GenesisSeed) Reset()         { *m = GenesisSeed{} }
func (m *GenesisSeed) String() string { return proto.CompactTextString(m) }
func (*GenesisSeed) ProtoMessage()    {}
func (*GenesisSeed) Descriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{3}
}
func (m *GenesisSeed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisSeed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisSeed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisSeed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisSeed.Merge(m, src)
}
func (m *GenesisSeed) XXX_Size() int {
	return m.Size()
}
func (m *GenesisSeed) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisSeed.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisSeed proto.InternalMessageInfo

func (m *GenesisSeed) GetStorageEpoch() *pdi.StorageEpoch {
	if m != nil {
		return m.StorageEpoch
	}
	return nil
}

func (m *GenesisSeed) GetCommunityEpoch() *pdi.CommunityEpoch {
	if m != nil {
		return m.CommunityEpoch
	}
	return nil
}

type RepoConfig struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RepoConfig) Reset()         { *m = RepoConfig{} }
func (m *RepoConfig) String() string { return proto.CompactTextString(m) }
func (*RepoConfig) ProtoMessage()    {}
func (*RepoConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{4}
}
func (m *RepoConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepoConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepoConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RepoConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepoConfig.Merge(m, src)
}
func (m *RepoConfig) XXX_Size() int {
	return m.Size()
}
func (m *RepoConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RepoConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RepoConfig proto.InternalMessageInfo

type RepoSeed struct {
	SignedGenesisSeed    []byte              `protobuf:"bytes,1,opt,name=signed_genesis_seed,json=signedGenesisSeed,proto3" json:"signed_genesis_seed,omitempty"`
	SuggestedDirName     string              `protobuf:"bytes,2,opt,name=suggested_dir_name,json=suggestedDirName,proto3" json:"suggested_dir_name,omitempty"`
	Services             []*plan.ServiceInfo `protobuf:"bytes,5,rep,name=services,proto3" json:"services,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *RepoSeed) Reset()         { *m = RepoSeed{} }
func (m *RepoSeed) String() string { return proto.CompactTextString(m) }
func (*RepoSeed) ProtoMessage()    {}
func (*RepoSeed) Descriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{5}
}
func (m *RepoSeed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepoSeed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepoSeed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RepoSeed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepoSeed.Merge(m, src)
}
func (m *RepoSeed) XXX_Size() int {
	return m.Size()
}
func (m *RepoSeed) XXX_DiscardUnknown() {
	xxx_messageInfo_RepoSeed.DiscardUnknown(m)
}

var xxx_messageInfo_RepoSeed proto.InternalMessageInfo

func (m *RepoSeed) GetSignedGenesisSeed() []byte {
	if m != nil {
		return m.SignedGenesisSeed
	}
	return nil
}

func (m *RepoSeed) GetSuggestedDirName() string {
	if m != nil {
		return m.SuggestedDirName
	}
	return ""
}

func (m *RepoSeed) GetServices() []*plan.ServiceInfo {
	if m != nil {
		return m.Services
	}
	return nil
}

// A community issues this to a person they want to invite into their community.  A copy of this record is written to member registry channel.
// This is passed in the clear and is used by a prospective member or guest's client to connect to a community.
type MemberSeed struct {
	RepoSeed *RepoSeed `protobuf:"bytes,1,opt,name=repo_seed,json=repoSeed,proto3" json:"repo_seed,omitempty"`
	// Exported and exported ski.KeyTome containing all keys needed for the recipient member.
	KeyTome     []byte           `protobuf:"bytes,3,opt,name=key_tome,json=keyTome,proto3" json:"key_tome,omitempty"`
	MemberEpoch *pdi.MemberEpoch `protobuf:"bytes,6,opt,name=member_epoch,json=memberEpoch,proto3" json:"member_epoch,omitempty"`
	// WHO sent this invitation (note: the member's signing key is used to create this invite)
	OriginMemberID       uint64       `protobuf:"fixed64,7,opt,name=origin_memberID,json=originMemberID,proto3" json:"origin_memberID,omitempty"`
	OriginSigningKey     *ski.KeyInfo `protobuf:"bytes,8,opt,name=origin_signing_key,json=originSigningKey,proto3" json:"origin_signing_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *MemberSeed) Reset()         { *m = MemberSeed{} }
func (m *MemberSeed) String() string { return proto.CompactTextString(m) }
func (*MemberSeed) ProtoMessage()    {}
func (*MemberSeed) Descriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{6}
}
func (m *MemberSeed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemberSeed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemberSeed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemberSeed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemberSeed.Merge(m, src)
}
func (m *MemberSeed) XXX_Size() int {
	return m.Size()
}
func (m *MemberSeed) XXX_DiscardUnknown() {
	xxx_messageInfo_MemberSeed.DiscardUnknown(m)
}

var xxx_messageInfo_MemberSeed proto.InternalMessageInfo

func (m *MemberSeed) GetRepoSeed() *RepoSeed {
	if m != nil {
		return m.RepoSeed
	}
	return nil
}

func (m *MemberSeed) GetKeyTome() []byte {
	if m != nil {
		return m.KeyTome
	}
	return nil
}

func (m *MemberSeed) GetMemberEpoch() *pdi.MemberEpoch {
	if m != nil {
		return m.MemberEpoch
	}
	return nil
}

func (m *MemberSeed) GetOriginMemberID() uint64 {
	if m != nil {
		return m.OriginMemberID
	}
	return 0
}

func (m *MemberSeed) GetOriginSigningKey() *ski.KeyInfo {
	if m != nil {
		return m.OriginSigningKey
	}
	return nil
}

type EntryState struct {
	Flags  uint32      `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	Status EntryStatus `protobuf:"varint,2,opt,name=status,proto3,enum=repo.EntryStatus" json:"status,omitempty"`
	// IF len() == 0, the implied body TID is the same as the entry info's TID (done to save space)
	// When entry 1 is superseded by entry 2, entry 2's TID appears in entry 1's EntryState.
	LiveIDs              []byte   `protobuf:"bytes,10,opt,name=liveIDs,proto3" json:"liveIDs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EntryState) Reset()         { *m = EntryState{} }
func (m *EntryState) String() string { return proto.CompactTextString(m) }
func (*EntryState) ProtoMessage()    {}
func (*EntryState) Descriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{7}
}
func (m *EntryState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntryState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntryState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntryState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntryState.Merge(m, src)
}
func (m *EntryState) XXX_Size() int {
	return m.Size()
}
func (m *EntryState) XXX_DiscardUnknown() {
	xxx_messageInfo_EntryState.DiscardUnknown(m)
}

var xxx_messageInfo_EntryState proto.InternalMessageInfo

func (m *EntryState) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *EntryState) GetStatus() EntryStatus {
	if m != nil {
		return m.Status
	}
	return EntryStatus_DISBARRED
}

func (m *EntryState) GetLiveIDs() []byte {
	if m != nil {
		return m.LiveIDs
	}
	return nil
}

type ChMgrState struct {
	// Incremented each time an entry is reversed/overturned.
	// This supports revalidation bookkeeping (triggered by a reversed entry)
	ValidationRev        int64    `protobuf:"varint,1,opt,name=validation_rev,json=validationRev,proto3" json:"validation_rev,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChMgrState) Reset()         { *m = ChMgrState{} }
func (m *ChMgrState) String() string { return proto.CompactTextString(m) }
func (*ChMgrState) ProtoMessage()    {}
func (*ChMgrState) Descriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{8}
}
func (m *ChMgrState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChMgrState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChMgrState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChMgrState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChMgrState.Merge(m, src)
}
func (m *ChMgrState) XXX_Size() int {
	return m.Size()
}
func (m *ChMgrState) XXX_DiscardUnknown() {
	xxx_messageInfo_ChMgrState.DiscardUnknown(m)
}

var xxx_messageInfo_ChMgrState proto.InternalMessageInfo

func (m *ChMgrState) GetValidationRev() int64 {
	if m != nil {
		return m.ValidationRev
	}
	return 0
}

type ChStoreState struct {
	ChannelID  []byte `protobuf:"bytes,1,opt,name=channelID,proto3" json:"channelID,omitempty"`
	ChProtocol string `protobuf:"bytes,2,opt,name=ch_protocol,json=chProtocol,proto3" json:"ch_protocol,omitempty"`
	// All entry TIDs up to this point (and including this TID) are not pending active validation.
	ValidatedUpto []byte `protobuf:"bytes,3,opt,name=validated_upto,json=validatedUpto,proto3" json:"validated_upto,omitempty"`
	//  If not set, this channel is not yet able to validate entries (e.g. ChUnknown can't)
	MergeEnabled         bool             `protobuf:"varint,4,opt,name=merge_enabled,json=mergeEnabled,proto3" json:"merge_enabled,omitempty"`
	ChannelInfo          *pdi.ChannelInfo `protobuf:"bytes,9,opt,name=channel_info,json=channelInfo,proto3" json:"channel_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ChStoreState) Reset()         { *m = ChStoreState{} }
func (m *ChStoreState) String() string { return proto.CompactTextString(m) }
func (*ChStoreState) ProtoMessage()    {}
func (*ChStoreState) Descriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{9}
}
func (m *ChStoreState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChStoreState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChStoreState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChStoreState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChStoreState.Merge(m, src)
}
func (m *ChStoreState) XXX_Size() int {
	return m.Size()
}
func (m *ChStoreState) XXX_DiscardUnknown() {
	xxx_messageInfo_ChStoreState.DiscardUnknown(m)
}

var xxx_messageInfo_ChStoreState proto.InternalMessageInfo

func (m *ChStoreState) GetChannelID() []byte {
	if m != nil {
		return m.ChannelID
	}
	return nil
}

func (m *ChStoreState) GetChProtocol() string {
	if m != nil {
		return m.ChProtocol
	}
	return ""
}

func (m *ChStoreState) GetValidatedUpto() []byte {
	if m != nil {
		return m.ValidatedUpto
	}
	return nil
}

func (m *ChStoreState) GetMergeEnabled() bool {
	if m != nil {
		return m.MergeEnabled
	}
	return false
}

func (m *ChStoreState) GetChannelInfo() *pdi.ChannelInfo {
	if m != nil {
		return m.ChannelInfo
	}
	return nil
}

type IntSet struct {
	Ints []uint64 `protobuf:"varint,1,rep,packed,name=ints,proto3" json:"ints,omitempty"`
	// Range: [From, To)
	From                 uint64   `protobuf:"varint,2,opt,name=from,proto3" json:"from,omitempty"`
	To                   uint64   `protobuf:"varint,3,opt,name=to,proto3" json:"to,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IntSet) Reset()         { *m = IntSet{} }
func (m *IntSet) String() string { return proto.CompactTextString(m) }
func (*IntSet) ProtoMessage()    {}
func (*IntSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{10}
}
func (m *IntSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IntSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IntSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntSet.Merge(m, src)
}
func (m *IntSet) XXX_Size() int {
	return m.Size()
}
func (m *IntSet) XXX_DiscardUnknown() {
	xxx_messageInfo_IntSet.DiscardUnknown(m)
}

var xxx_messageInfo_IntSet proto.InternalMessageInfo

func (m *IntSet) GetInts() []uint64 {
	if m != nil {
		return m.Ints
	}
	return nil
}

func (m *IntSet) GetFrom() uint64 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *IntSet) GetTo() uint64 {
	if m != nil {
		return m.To
	}
	return 0
}

type ChDependency struct {
	// Time index (and later) of applicable channel entries
	DepTime              int64    `protobuf:"varint,1,opt,name=dep_time,json=depTime,proto3" json:"dep_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChDependency) Reset()         { *m = ChDependency{} }
func (m *ChDependency) String() string { return proto.CompactTextString(m) }
func (*ChDependency) ProtoMessage()    {}
func (*ChDependency) Descriptor() ([]byte, []int) {
	return fileDescriptor_9766af4c08a0998e, []int{11}
}
func (m *ChDependency) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChDependency) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChDependency.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChDependency) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChDependency.Merge(m, src)
}
func (m *ChDependency) XXX_Size() int {
	return m.Size()
}
func (m *ChDependency) XXX_DiscardUnknown() {
	xxx_messageInfo_ChDependency.DiscardUnknown(m)
}

var xxx_messageInfo_ChDependency proto.InternalMessageInfo

func (m *ChDependency) GetDepTime() int64 {
	if m != nil {
		return m.DepTime
	}
	return 0
}

func init() {
	proto.RegisterEnum("repo.ChSessionFlags", ChSessionFlags_name, ChSessionFlags_value)
	proto.RegisterEnum("repo.MsgOp", MsgOp_name, MsgOp_value)
	proto.RegisterEnum("repo.EntryStatus", EntryStatus_name, EntryStatus_value)
	proto.RegisterEnum("repo.EntryFlag", EntryFlag_name, EntryFlag_value)
	proto.RegisterType((*MemberSessionReq)(nil), "repo.MemberSessionReq")
	proto.RegisterType((*ChInvocation)(nil), "repo.ChInvocation")
	proto.RegisterType((*Msg)(nil), "repo.Msg")
	proto.RegisterType((*GenesisSeed)(nil), "repo.GenesisSeed")
	proto.RegisterType((*RepoConfig)(nil), "repo.RepoConfig")
	proto.RegisterType((*RepoSeed)(nil), "repo.RepoSeed")
	proto.RegisterType((*MemberSeed)(nil), "repo.MemberSeed")
	proto.RegisterType((*EntryState)(nil), "repo.EntryState")
	proto.RegisterType((*ChMgrState)(nil), "repo.ChMgrState")
	proto.RegisterType((*ChStoreState)(nil), "repo.ChStoreState")
	proto.RegisterType((*IntSet)(nil), "repo.IntSet")
	proto.RegisterType((*ChDependency)(nil), "repo.ChDependency")
}

func init() { proto.RegisterFile("repo/repo.proto", fileDescriptor_9766af4c08a0998e) }

var fileDescriptor_9766af4c08a0998e = []byte{
	// 1456 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0x4f, 0x53, 0xe3, 0xc8,
	0x15, 0x47, 0xb6, 0x31, 0xf6, 0xb3, 0x6c, 0x37, 0xcd, 0x9f, 0x68, 0x98, 0x84, 0xb8, 0x9c, 0x7f,
	0x1e, 0x92, 0x01, 0x06, 0x26, 0xa9, 0x4c, 0x2a, 0x87, 0x18, 0xa9, 0x01, 0x05, 0x5b, 0xa6, 0x5a,
	0x62, 0x88, 0x4f, 0x5d, 0x1e, 0xa9, 0xb1, 0x55, 0x60, 0x49, 0x91, 0x04, 0x5b, 0x9c, 0xf7, 0xb8,
	0xd7, 0xad, 0x9a, 0xfd, 0x48, 0x7b, 0xda, 0x9a, 0x8f, 0xb0, 0x35, 0x7b, 0xdf, 0xcf, 0xb0, 0xd5,
	0x2d, 0xd9, 0xd8, 0xec, 0x1e, 0xf6, 0xe2, 0x7a, 0xef, 0xf7, 0x5e, 0xbf, 0xff, 0xef, 0x59, 0xd0,
	0x8c, 0x79, 0x14, 0x1e, 0x88, 0x9f, 0xfd, 0x28, 0x0e, 0xd3, 0x10, 0x97, 0x04, 0xbd, 0x53, 0x4f,
	0x6e, 0xfd, 0x83, 0xe4, 0xd6, 0xcf, 0xc0, 0x9d, 0x66, 0x74, 0x37, 0x0a, 0x0e, 0xc4, 0x4f, 0x0e,
	0xd4, 0x23, 0xcf, 0x3f, 0x88, 0xbc, 0x5c, 0xde, 0xfe, 0xa4, 0x00, 0xea, 0xf3, 0xe9, 0x07, 0x1e,
	0xdb, 0x3c, 0x49, 0xfc, 0x30, 0xa0, 0xfc, 0xff, 0xf8, 0x8f, 0x50, 0xff, 0x22, 0x8c, 0x6f, 0x93,
	0x74, 0x94, 0xfa, 0x61, 0x60, 0x1a, 0x9a, 0xd2, 0x52, 0x3a, 0x2a, 0x5d, 0x06, 0x71, 0x0b, 0x6a,
	0x6e, 0x38, 0x9d, 0xde, 0x07, 0x7e, 0xfa, 0x68, 0x1a, 0x5a, 0x41, 0xea, 0x2c, 0x42, 0xf8, 0x18,
	0xd4, 0xa9, 0xb4, 0xcd, 0x78, 0x14, 0xba, 0x13, 0xad, 0xd8, 0x52, 0x3a, 0xb5, 0x23, 0xb4, 0x2f,
	0xdc, 0x67, 0x4e, 0x89, 0xc0, 0x69, 0x6d, 0xfa, 0xc4, 0xe0, 0x1d, 0xa8, 0x44, 0xa3, 0x24, 0x99,
	0x8c, 0x92, 0x89, 0xb6, 0x2a, 0x6d, 0xce, 0x79, 0xfc, 0x07, 0xa8, 0x27, 0x59, 0x98, 0x2c, 0x0d,
	0x6f, 0x79, 0xa0, 0x95, 0xa5, 0x82, 0x9a, 0x83, 0x8e, 0xc0, 0xda, 0xff, 0x05, 0x55, 0x9f, 0x98,
	0xc1, 0x43, 0xe8, 0xca, 0x48, 0x31, 0x86, 0x92, 0x3b, 0x99, 0x27, 0x21, 0x69, 0xfc, 0x67, 0x68,
	0xba, 0x13, 0x36, 0xf2, 0x46, 0x51, 0xca, 0x63, 0xe6, 0xf1, 0xc4, 0xd5, 0xa0, 0xa5, 0x74, 0xaa,
	0xb4, 0xee, 0x4e, 0xba, 0x19, 0x6a, 0xf0, 0xc4, 0x6d, 0x7f, 0x2c, 0x40, 0xb1, 0x9f, 0x8c, 0x71,
	0x03, 0x0a, 0xb9, 0x85, 0x3a, 0x2d, 0x98, 0x06, 0x7e, 0x09, 0x85, 0x30, 0x92, 0x29, 0x37, 0x8e,
	0x6a, 0xfb, 0xb2, 0x09, 0xfd, 0x64, 0x3c, 0x88, 0x68, 0x21, 0x8c, 0xf0, 0x4b, 0xa8, 0xba, 0x13,
	0x26, 0x62, 0x32, 0x0d, 0x99, 0x73, 0x9d, 0x56, 0xdc, 0x89, 0x2d, 0x79, 0xfc, 0x1a, 0x80, 0x07,
	0x69, 0xfc, 0xc8, 0xfc, 0xe0, 0x26, 0x94, 0x4e, 0x6b, 0x47, 0x0d, 0x59, 0x11, 0x22, 0x60, 0x33,
	0xb8, 0x09, 0x69, 0x95, 0xcf, 0x48, 0xfc, 0x06, 0x6a, 0x99, 0xba, 0xa8, 0x3b, 0xd7, 0x6a, 0x79,
	0x05, 0xa5, 0x47, 0xf9, 0xc0, 0x16, 0x38, 0xcd, 0x6c, 0x4a, 0x1a, 0x6f, 0xc2, 0x2a, 0x8f, 0xe3,
	0x30, 0xd6, 0x54, 0x99, 0x51, 0xc6, 0x88, 0x0c, 0x9c, 0x43, 0x6d, 0xb3, 0xa5, 0x74, 0x8a, 0xb4,
	0xe0, 0x1c, 0x0a, 0xad, 0xd3, 0x5e, 0xf7, 0xcc, 0xd6, 0xb6, 0x64, 0x80, 0x19, 0x23, 0x6a, 0x75,
	0x72, 0x75, 0x7a, 0xa8, 0x6d, 0x67, 0xb5, 0x12, 0xb4, 0xd0, 0x34, 0x1d, 0xd2, 0xb7, 0xb5, 0xdf,
	0xb4, 0x8a, 0x1d, 0x95, 0x66, 0x4c, 0xfb, 0x4b, 0x05, 0x6a, 0x67, 0x3c, 0xe0, 0x89, 0x9f, 0xd8,
	0x9c, 0x7b, 0xf8, 0x1f, 0x50, 0x4f, 0xd2, 0x30, 0x1e, 0x8d, 0x79, 0xde, 0x6c, 0x45, 0x86, 0xba,
	0x2e, 0x53, 0xb3, 0x33, 0x49, 0xd6, 0x6d, 0x35, 0x59, 0xe0, 0xf0, 0xbf, 0xa1, 0x39, 0x1f, 0x99,
	0xfc, 0x65, 0x41, 0xbe, 0xdc, 0x90, 0x2f, 0xf5, 0x99, 0x2c, 0x7b, 0xdb, 0x70, 0x97, 0xf8, 0xb6,
	0x0a, 0x40, 0x79, 0x14, 0xea, 0x61, 0x70, 0xe3, 0x8f, 0xdb, 0x1f, 0x15, 0xa8, 0x08, 0x56, 0x06,
	0xb4, 0x0f, 0x1b, 0x89, 0x3f, 0x0e, 0xb8, 0xc7, 0xc6, 0x59, 0x98, 0x2c, 0xe1, 0xdc, 0xcb, 0xa7,
	0x60, 0x3d, 0x13, 0x2d, 0x26, 0xf0, 0x37, 0xc0, 0xc9, 0xfd, 0x78, 0xcc, 0x93, 0x94, 0x7b, 0xcc,
	0xf3, 0x63, 0x16, 0x8c, 0xa6, 0x5c, 0xc6, 0x52, 0xa5, 0x68, 0x2e, 0x31, 0xfc, 0xd8, 0x1a, 0x4d,
	0x39, 0x7e, 0x0d, 0x95, 0x84, 0xc7, 0x0f, 0xbe, 0xcb, 0x13, 0x6d, 0xb5, 0x55, 0xcc, 0x32, 0x15,
	0x5b, 0x66, 0x67, 0xa8, 0xec, 0xe3, 0x5c, 0xa5, 0xfd, 0xa3, 0x02, 0x30, 0x5b, 0x33, 0xee, 0xe1,
	0xbf, 0x42, 0x55, 0x74, 0xf0, 0x29, 0x22, 0x31, 0x03, 0xb2, 0xa7, 0xb3, 0xf0, 0x69, 0x25, 0x9e,
	0x25, 0xf2, 0x02, 0x2a, 0xb7, 0xfc, 0x91, 0xa5, 0xe1, 0x94, 0xcb, 0x69, 0x52, 0xe9, 0xda, 0x2d,
	0x7f, 0x74, 0xc2, 0x29, 0xff, 0xd9, 0x82, 0x95, 0x7f, 0xcd, 0x82, 0xfd, 0x05, 0x9a, 0x61, 0xec,
	0x8f, 0xfd, 0x80, 0x65, 0xa8, 0x69, 0x68, 0x6b, 0x2d, 0xa5, 0x53, 0xa6, 0x8d, 0x0c, 0xee, 0xe7,
	0x28, 0xfe, 0x17, 0xe0, 0x5c, 0x51, 0x54, 0xcb, 0x0f, 0xc6, 0xec, 0x96, 0x3f, 0x6a, 0x15, 0xe9,
	0x43, 0xdd, 0x17, 0x37, 0xe6, 0x82, 0x67, 0x03, 0x8b, 0x32, 0x3d, 0x3b, 0x53, 0xbb, 0xe0, 0x8f,
	0xed, 0x31, 0x00, 0x59, 0x1a, 0xc9, 0x9b, 0xbb, 0xd1, 0x38, 0xc9, 0x37, 0x28, 0x63, 0xf0, 0x2b,
	0x28, 0x8b, 0xa9, 0xbe, 0x4f, 0xf2, 0x45, 0x5a, 0x7f, 0x36, 0xd6, 0xf7, 0x09, 0xcd, 0x15, 0xb0,
	0x06, 0x6b, 0x77, 0xfe, 0x03, 0x37, 0x8d, 0x44, 0xae, 0x8c, 0x4a, 0x67, 0x6c, 0xfb, 0x18, 0x40,
	0x9f, 0xf4, 0xc7, 0x71, 0xe6, 0xe8, 0x4f, 0xd0, 0x78, 0x18, 0xdd, 0xf9, 0x9e, 0xdc, 0x7c, 0x16,
	0xf3, 0x07, 0xe9, 0xb1, 0x48, 0xeb, 0x4f, 0x28, 0xe5, 0x0f, 0xed, 0xef, 0x14, 0x71, 0x23, 0xc4,
	0x54, 0xf2, 0xec, 0xdd, 0x6f, 0xc5, 0xca, 0x8e, 0x82, 0x80, 0xdf, 0xcd, 0x0f, 0xc5, 0x13, 0x80,
	0x7f, 0x0f, 0x35, 0x77, 0xc2, 0xe4, 0xc1, 0x74, 0xc3, 0xbb, 0x7c, 0x26, 0xc0, 0x9d, 0x5c, 0xe6,
	0xc8, 0x82, 0x5b, 0xee, 0xb1, 0xfb, 0x28, 0x0d, 0xf3, 0x46, 0xd5, 0xe7, 0xe8, 0x55, 0x94, 0x86,
	0xe2, 0x7c, 0x4d, 0x79, 0x2c, 0x36, 0x24, 0x18, 0x7d, 0xb8, 0xe3, 0x9e, 0x56, 0x6a, 0x29, 0x9d,
	0x0a, 0x55, 0x25, 0x48, 0x32, 0x4c, 0xf4, 0x34, 0xf7, 0x9c, 0x9d, 0x88, 0xea, 0x42, 0x4f, 0xf5,
	0x3c, 0x24, 0x51, 0xf3, 0x9a, 0xfb, 0xc4, 0xb4, 0xff, 0x03, 0x65, 0x33, 0x48, 0x6d, 0x9e, 0x8a,
	0x0d, 0xf6, 0x83, 0x54, 0x54, 0xba, 0xd8, 0x29, 0x51, 0x49, 0x0b, 0xec, 0x26, 0x0e, 0xa7, 0x32,
	0xf0, 0x12, 0x95, 0xb4, 0xb8, 0x07, 0x79, 0x98, 0x25, 0x5a, 0x48, 0xc3, 0xf6, 0x2b, 0x51, 0x11,
	0x83, 0x47, 0x3c, 0xf0, 0x78, 0xe0, 0x3e, 0x8a, 0xa9, 0xf3, 0x78, 0xc4, 0x52, 0x7f, 0xca, 0xf3,
	0x1a, 0xae, 0x79, 0x3c, 0x72, 0xfc, 0x29, 0xdf, 0xf3, 0xa0, 0xa1, 0x4f, 0xf2, 0xbf, 0x8b, 0x53,
	0xd9, 0x49, 0x04, 0xaa, 0x69, 0xe9, 0xbd, 0x2b, 0x83, 0xb0, 0x93, 0x81, 0x31, 0x44, 0x2b, 0x78,
	0x13, 0x90, 0x41, 0x4e, 0x09, 0xa5, 0xc4, 0x60, 0xc4, 0x72, 0xa8, 0x49, 0x6c, 0xa4, 0xe0, 0x0d,
	0x68, 0xea, 0x03, 0xcb, 0x21, 0x96, 0x33, 0x07, 0x0b, 0x78, 0x0b, 0xd6, 0x2d, 0x72, 0xcd, 0xc8,
	0xe5, 0x40, 0x3f, 0x9f, 0xc3, 0xc5, 0xbd, 0x4f, 0x45, 0x58, 0x95, 0x37, 0x15, 0x97, 0xa1, 0x30,
	0xb8, 0x40, 0x2b, 0x78, 0x1b, 0x70, 0xd7, 0x30, 0x98, 0x3e, 0xe8, 0xf7, 0xaf, 0x2c, 0xd3, 0x19,
	0xb2, 0x0b, 0x32, 0x14, 0x56, 0x5f, 0xc0, 0x16, 0x25, 0x4e, 0xd7, 0xb4, 0x9e, 0x8b, 0x0a, 0xb8,
	0x09, 0x35, 0x81, 0x99, 0x0e, 0x73, 0xfe, 0x67, 0xd9, 0xa8, 0x88, 0x1b, 0x00, 0x94, 0xd8, 0x84,
	0xbe, 0x27, 0x06, 0x7b, 0x8b, 0x4a, 0x4b, 0xfc, 0xdf, 0xd1, 0x2a, 0xd6, 0x60, 0xb3, 0x4f, 0xfa,
	0x27, 0x84, 0x32, 0x9b, 0xd8, 0xb6, 0x39, 0xb0, 0x18, 0x25, 0x5d, 0x63, 0x88, 0xca, 0x42, 0xb2,
	0x60, 0x4a, 0xb8, 0xba, 0xec, 0x11, 0x87, 0xa0, 0x35, 0x91, 0xab, 0x7e, 0xce, 0xce, 0x88, 0x45,
	0x6c, 0xd3, 0x96, 0x19, 0x0c, 0x51, 0x65, 0xc9, 0xf2, 0x3b, 0x54, 0x95, 0x5a, 0xbd, 0x81, 0x4d,
	0x98, 0x7e, 0x3e, 0xb3, 0x8d, 0x00, 0xaf, 0x43, 0xfd, 0x72, 0x60, 0x3b, 0x2c, 0x4f, 0x7d, 0x88,
	0x6a, 0x22, 0x4d, 0xf1, 0x30, 0x2b, 0xd1, 0x50, 0xfa, 0x27, 0x14, 0xa9, 0x22, 0x97, 0xb9, 0xc1,
	0x37, 0xc7, 0xa8, 0xbe, 0x0c, 0xbc, 0x45, 0x0d, 0x51, 0xc9, 0x27, 0xe3, 0x4c, 0x7a, 0x33, 0x50,
	0x13, 0xab, 0x50, 0x99, 0x9b, 0x47, 0xb2, 0x07, 0x39, 0xc7, 0xae, 0x2e, 0x8d, 0xae, 0x43, 0xd0,
	0xba, 0xf0, 0xa9, 0x9f, 0x33, 0xd9, 0x86, 0xb9, 0xd3, 0x21, 0xc2, 0xcb, 0x2e, 0xde, 0xa1, 0x8d,
	0x25, 0xe0, 0xe8, 0x10, 0x6d, 0x8a, 0xb4, 0x7a, 0x83, 0x33, 0xd3, 0x62, 0xce, 0x80, 0x5d, 0xdb,
	0xcc, 0x26, 0x5d, 0x07, 0x6d, 0x09, 0xd4, 0x76, 0xba, 0xd4, 0x59, 0x4c, 0x76, 0x7b, 0xcf, 0x81,
	0xda, 0xc2, 0x72, 0xe3, 0x3a, 0x54, 0x0d, 0xd3, 0x3e, 0xe9, 0x8a, 0x21, 0x41, 0x2b, 0x18, 0x43,
	0xa3, 0x7b, 0xdd, 0x35, 0x1d, 0xd3, 0x3a, 0x63, 0x7d, 0x42, 0xcf, 0x08, 0x52, 0x30, 0x40, 0x59,
	0x92, 0x06, 0x2a, 0x88, 0x34, 0x66, 0x23, 0x85, 0x8a, 0xb8, 0x02, 0xa5, 0x9e, 0xf9, 0x9e, 0xa0,
	0xd2, 0xde, 0x57, 0x0a, 0x54, 0xa5, 0x59, 0x31, 0x8b, 0x22, 0xc0, 0x6b, 0xd2, 0xeb, 0xb1, 0xd3,
	0x01, 0xed, 0x4b, 0xb3, 0xbf, 0x83, 0x17, 0xdd, 0x2b, 0xe7, 0x7c, 0x40, 0x99, 0x41, 0x2e, 0x89,
	0x65, 0x10, 0x4b, 0x1f, 0xb2, 0x6b, 0x6a, 0x3a, 0x0e, 0xb1, 0x90, 0x82, 0x77, 0x60, 0xbb, 0xab,
	0xeb, 0xbf, 0x24, 0x2b, 0x08, 0xd9, 0x52, 0x57, 0xd9, 0x7b, 0x42, 0xcd, 0x53, 0x53, 0xfa, 0xdf,
	0x06, 0x6c, 0xda, 0x4c, 0x3f, 0xef, 0x5a, 0x16, 0xe9, 0xcd, 0x9a, 0x8f, 0x4a, 0x47, 0x5f, 0x2b,
	0x50, 0x12, 0x47, 0x1c, 0x77, 0xa0, 0x22, 0x0f, 0xb9, 0xa0, 0x9f, 0x1d, 0xf7, 0x1d, 0x35, 0xff,
	0xaf, 0xc8, 0xea, 0xf0, 0x4f, 0x58, 0x1f, 0x44, 0x3c, 0x58, 0xfa, 0x0c, 0xc3, 0xdb, 0xf9, 0x57,
	0xc5, 0xb3, 0x6f, 0xb3, 0x9d, 0xea, 0xfc, 0x6b, 0xe3, 0x50, 0xc1, 0x1d, 0xa8, 0xc9, 0x97, 0xc9,
	0xf8, 0xd2, 0x8f, 0x38, 0x7e, 0x92, 0x2d, 0x7b, 0xe8, 0x28, 0x27, 0xe8, 0xdb, 0xcf, 0xbb, 0xca,
	0xa7, 0xcf, 0xbb, 0xca, 0xf7, 0x9f, 0x77, 0x95, 0x6f, 0x7e, 0xd8, 0x5d, 0xf9, 0x50, 0x96, 0xf7,
	0xec, 0xf8, 0xa7, 0x00, 0x00, 0x00, 0xff, 0xff, 0xad, 0x32, 0x74, 0xb6, 0x48, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RepoClient is the client API for Repo service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RepoClient interface {
	// Bootstraps a repo for a given member.
	SeedRepo(ctx context.Context, in *RepoSeed, opts ...grpc.CallOption) (*plan.Status, error)
	// Starts a new client member session.
	// The session ID returned from the resulting MsgOp_OK should be used for sending message to member session.
	OpenMemberSession(ctx context.Context, in *MemberSessionReq, opts ...grpc.CallOption) (Repo_OpenMemberSessionClient, error)
	// Sends msgs to channel session or the root member session itself, via Msg.SessID.
	// A client typically only needs one open call to this because all outbound channel traffic plus messages to the
	// session that control the member session.
	OpenMsgPipe(ctx context.Context, opts ...grpc.CallOption) (Repo_OpenMsgPipeClient, error)
}

type repoClient struct {
	cc *grpc.ClientConn
}

func NewRepoClient(cc *grpc.ClientConn) RepoClient {
	return &repoClient{cc}
}

func (c *repoClient) SeedRepo(ctx context.Context, in *RepoSeed, opts ...grpc.CallOption) (*plan.Status, error) {
	out := new(plan.Status)
	err := c.cc.Invoke(ctx, "/repo.Repo/SeedRepo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoClient) OpenMemberSession(ctx context.Context, in *MemberSessionReq, opts ...grpc.CallOption) (Repo_OpenMemberSessionClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Repo_serviceDesc.Streams[0], "/repo.Repo/OpenMemberSession", opts...)
	if err != nil {
		return nil, err
	}
	x := &repoOpenMemberSessionClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Repo_OpenMemberSessionClient interface {
	Recv() (*Msg, error)
	grpc.ClientStream
}

type repoOpenMemberSessionClient struct {
	grpc.ClientStream
}

func (x *repoOpenMemberSessionClient) Recv() (*Msg, error) {
	m := new(Msg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *repoClient) OpenMsgPipe(ctx context.Context, opts ...grpc.CallOption) (Repo_OpenMsgPipeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Repo_serviceDesc.Streams[1], "/repo.Repo/OpenMsgPipe", opts...)
	if err != nil {
		return nil, err
	}
	x := &repoOpenMsgPipeClient{stream}
	return x, nil
}

type Repo_OpenMsgPipeClient interface {
	Send(*Msg) error
	CloseAndRecv() (*plan.Status, error)
	grpc.ClientStream
}

type repoOpenMsgPipeClient struct {
	grpc.ClientStream
}

func (x *repoOpenMsgPipeClient) Send(m *Msg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *repoOpenMsgPipeClient) CloseAndRecv() (*plan.Status, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(plan.Status)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RepoServer is the server API for Repo service.
type RepoServer interface {
	// Bootstraps a repo for a given member.
	SeedRepo(context.Context, *RepoSeed) (*plan.Status, error)
	// Starts a new client member session.
	// The session ID returned from the resulting MsgOp_OK should be used for sending message to member session.
	OpenMemberSession(*MemberSessionReq, Repo_OpenMemberSessionServer) error
	// Sends msgs to channel session or the root member session itself, via Msg.SessID.
	// A client typically only needs one open call to this because all outbound channel traffic plus messages to the
	// session that control the member session.
	OpenMsgPipe(Repo_OpenMsgPipeServer) error
}

// UnimplementedRepoServer can be embedded to have forward compatible implementations.
type UnimplementedRepoServer struct {
}

func (*UnimplementedRepoServer) SeedRepo(ctx context.Context, req *RepoSeed) (*plan.Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SeedRepo not implemented")
}
func (*UnimplementedRepoServer) OpenMemberSession(req *MemberSessionReq, srv Repo_OpenMemberSessionServer) error {
	return status.Errorf(codes.Unimplemented, "method OpenMemberSession not implemented")
}
func (*UnimplementedRepoServer) OpenMsgPipe(srv Repo_OpenMsgPipeServer) error {
	return status.Errorf(codes.Unimplemented, "method OpenMsgPipe not implemented")
}

func RegisterRepoServer(s *grpc.Server, srv RepoServer) {
	s.RegisterService(&_Repo_serviceDesc, srv)
}

func _Repo_SeedRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepoSeed)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepoServer).SeedRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/repo.Repo/SeedRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepoServer).SeedRepo(ctx, req.(*RepoSeed))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repo_OpenMemberSession_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MemberSessionReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RepoServer).OpenMemberSession(m, &repoOpenMemberSessionServer{stream})
}

type Repo_OpenMemberSessionServer interface {
	Send(*Msg) error
	grpc.ServerStream
}

type repoOpenMemberSessionServer struct {
	grpc.ServerStream
}

func (x *repoOpenMemberSessionServer) Send(m *Msg) error {
	return x.ServerStream.SendMsg(m)
}

func _Repo_OpenMsgPipe_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RepoServer).OpenMsgPipe(&repoOpenMsgPipeServer{stream})
}

type Repo_OpenMsgPipeServer interface {
	SendAndClose(*plan.Status) error
	Recv() (*Msg, error)
	grpc.ServerStream
}

type repoOpenMsgPipeServer struct {
	grpc.ServerStream
}

func (x *repoOpenMsgPipeServer) SendAndClose(m *plan.Status) error {
	return x.ServerStream.SendMsg(m)
}

func (x *repoOpenMsgPipeServer) Recv() (*Msg, error) {
	m := new(Msg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Repo_serviceDesc = grpc.ServiceDesc{
	ServiceName: "repo.Repo",
	HandlerType: (*RepoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SeedRepo",
			Handler:    _Repo_SeedRepo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "OpenMemberSession",
			Handler:       _Repo_OpenMemberSession_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "OpenMsgPipe",
			Handler:       _Repo_OpenMsgPipe_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "repo/repo.proto",
}

func (m *MemberSessionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemberSessionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.WorkstationID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRepo(dAtA, i, uint64(len(m.WorkstationID)))
		i += copy(dAtA[i:], m.WorkstationID)
	}
	if len(m.CommunityID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRepo(dAtA, i, uint64(len(m.CommunityID)))
		i += copy(dAtA[i:], m.CommunityID)
	}
	if m.MemberEpoch != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRepo(dAtA, i, uint64(m.MemberEpoch.Size()))
		n1, err1 := m.MemberEpoch.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if len(m.Passhash) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRepo(dAtA, i, uint64(len(m.Passhash)))
		i += copy(dAtA[i:], m.Passhash)
	}
	if len(m.SessionToken) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRepo(dAtA, i, uint64(len(m.SessionToken)))
		i += copy(dAtA[i:], m.SessionToken)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChInvocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChInvocation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRepo(dAtA, i, uint64(len(m.ChID)))
		i += copy(dAtA[i:], m.ChID)
	}
	if len(m.ChAdapterDesc) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintRepo(dAtA, i, uint64(len(m.ChAdapterDesc)))
		i += copy(dAtA[i:], m.ChAdapterDesc)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Msg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Msg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRepo(dAtA, i, uint64(m.ID))
	}
	if m.Op != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRepo(dAtA, i, uint64(m.Op))
	}
	if m.ChSessID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRepo(dAtA, i, uint64(m.ChSessID))
	}
	if m.EntryInfo != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintRepo(dAtA, i, uint64(m.EntryInfo.Size()))
		n2, err2 := m.EntryInfo.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	if m.EntryState != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintRepo(dAtA, i, uint64(m.EntryState.Size()))
		n3, err3 := m.EntryState.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintRepo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.T0 != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRepo(dAtA, i, uint64(m.T0))
	}
	if m.FLAGS != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRepo(dAtA, i, uint64(m.FLAGS))
	}
	if len(m.BUF0) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRepo(dAtA, i, uint64(len(m.BUF0)))
		i += copy(dAtA[i:], m.BUF0)
	}
	if len(m.ITEMS) > 0 {
		for _, b := range m.ITEMS {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintRepo(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GenesisSeed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisSeed) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StorageEpoch != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRepo(dAtA, i, uint64(m.StorageEpoch.Size()))
		n4, err4 := m.StorageEpoch.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	if m.CommunityEpoch != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRepo(dAtA, i, uint64(m.CommunityEpoch.Size()))
		n5, err5 := m.CommunityEpoch.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RepoConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepoConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RepoSeed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepoSeed) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SignedGenesisSeed) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRepo(dAtA, i, uint64(len(m.SignedGenesisSeed)))
		i += copy(dAtA[i:], m.SignedGenesisSeed)
	}
	if len(m.SuggestedDirName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRepo(dAtA, i, uint64(len(m.SuggestedDirName)))
		i += copy(dAtA[i:], m.SuggestedDirName)
	}
	if len(m.Services) > 0 {
		for _, msg := range m.Services {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintRepo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MemberSeed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemberSeed) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RepoSeed != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRepo(dAtA, i, uint64(m.RepoSeed.Size()))
		n6, err6 := m.RepoSeed.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	if len(m.KeyTome) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRepo(dAtA, i, uint64(len(m.KeyTome)))
		i += copy(dAtA[i:], m.KeyTome)
	}
	if m.MemberEpoch != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRepo(dAtA, i, uint64(m.MemberEpoch.Size()))
		n7, err7 := m.MemberEpoch.MarshalTo(dAtA[i:])
		if err7 != nil {
			return 0, err7
		}
		i += n7
	}
	if m.OriginMemberID != 0 {
		dAtA[i] = 0x39
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.OriginMemberID))
		i += 8
	}
	if m.OriginSigningKey != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintRepo(dAtA, i, uint64(m.OriginSigningKey.Size()))
		n8, err8 := m.OriginSigningKey.MarshalTo(dAtA[i:])
		if err8 != nil {
			return 0, err8
		}
		i += n8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EntryState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntryState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRepo(dAtA, i, uint64(m.Flags))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRepo(dAtA, i, uint64(m.Status))
	}
	if len(m.LiveIDs) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintRepo(dAtA, i, uint64(len(m.LiveIDs)))
		i += copy(dAtA[i:], m.LiveIDs)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChMgrState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChMgrState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ValidationRev != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRepo(dAtA, i, uint64(m.ValidationRev))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChStoreState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChStoreState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChannelID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRepo(dAtA, i, uint64(len(m.ChannelID)))
		i += copy(dAtA[i:], m.ChannelID)
	}
	if len(m.ChProtocol) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRepo(dAtA, i, uint64(len(m.ChProtocol)))
		i += copy(dAtA[i:], m.ChProtocol)
	}
	if len(m.ValidatedUpto) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRepo(dAtA, i, uint64(len(m.ValidatedUpto)))
		i += copy(dAtA[i:], m.ValidatedUpto)
	}
	if m.MergeEnabled {
		dAtA[i] = 0x20
		i++
		if m.MergeEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ChannelInfo != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintRepo(dAtA, i, uint64(m.ChannelInfo.Size()))
		n9, err9 := m.ChannelInfo.MarshalTo(dAtA[i:])
		if err9 != nil {
			return 0, err9
		}
		i += n9
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IntSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ints) > 0 {
		dAtA11 := make([]byte, len(m.Ints)*10)
		var j10 int
		for _, num := range m.Ints {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintRepo(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	if m.From != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRepo(dAtA, i, uint64(m.From))
	}
	if m.To != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRepo(dAtA, i, uint64(m.To))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChDependency) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChDependency) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DepTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRepo(dAtA, i, uint64(m.DepTime))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintRepo(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MemberSessionReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WorkstationID)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	l = len(m.CommunityID)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.MemberEpoch != nil {
		l = m.MemberEpoch.Size()
		n += 1 + l + sovRepo(uint64(l))
	}
	l = len(m.Passhash)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	l = len(m.SessionToken)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChInvocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChID)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	l = len(m.ChAdapterDesc)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Msg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRepo(uint64(m.ID))
	}
	if m.Op != 0 {
		n += 1 + sovRepo(uint64(m.Op))
	}
	if m.ChSessID != 0 {
		n += 1 + sovRepo(uint64(m.ChSessID))
	}
	if m.EntryInfo != nil {
		l = m.EntryInfo.Size()
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.EntryState != nil {
		l = m.EntryState.Size()
		n += 1 + l + sovRepo(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.T0 != 0 {
		n += 2 + sovRepo(uint64(m.T0))
	}
	if m.FLAGS != 0 {
		n += 2 + sovRepo(uint64(m.FLAGS))
	}
	l = len(m.BUF0)
	if l > 0 {
		n += 2 + l + sovRepo(uint64(l))
	}
	if len(m.ITEMS) > 0 {
		for _, b := range m.ITEMS {
			l = len(b)
			n += 2 + l + sovRepo(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GenesisSeed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageEpoch != nil {
		l = m.StorageEpoch.Size()
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.CommunityEpoch != nil {
		l = m.CommunityEpoch.Size()
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepoConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepoSeed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SignedGenesisSeed)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	l = len(m.SuggestedDirName)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	if len(m.Services) > 0 {
		for _, e := range m.Services {
			l = e.Size()
			n += 1 + l + sovRepo(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemberSeed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RepoSeed != nil {
		l = m.RepoSeed.Size()
		n += 1 + l + sovRepo(uint64(l))
	}
	l = len(m.KeyTome)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.MemberEpoch != nil {
		l = m.MemberEpoch.Size()
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.OriginMemberID != 0 {
		n += 9
	}
	if m.OriginSigningKey != nil {
		l = m.OriginSigningKey.Size()
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EntryState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovRepo(uint64(m.Flags))
	}
	if m.Status != 0 {
		n += 1 + sovRepo(uint64(m.Status))
	}
	l = len(m.LiveIDs)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChMgrState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidationRev != 0 {
		n += 1 + sovRepo(uint64(m.ValidationRev))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChStoreState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChannelID)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	l = len(m.ChProtocol)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	l = len(m.ValidatedUpto)
	if l > 0 {
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.MergeEnabled {
		n += 2
	}
	if m.ChannelInfo != nil {
		l = m.ChannelInfo.Size()
		n += 1 + l + sovRepo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IntSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ints) > 0 {
		l = 0
		for _, e := range m.Ints {
			l += sovRepo(uint64(e))
		}
		n += 1 + sovRepo(uint64(l)) + l
	}
	if m.From != 0 {
		n += 1 + sovRepo(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovRepo(uint64(m.To))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChDependency) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DepTime != 0 {
		n += 1 + sovRepo(uint64(m.DepTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRepo(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRepo(x uint64) (n int) {
	return sovRepo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MemberSessionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemberSessionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemberSessionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkstationID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkstationID = append(m.WorkstationID[:0], dAtA[iNdEx:postIndex]...)
			if m.WorkstationID == nil {
				m.WorkstationID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunityID = append(m.CommunityID[:0], dAtA[iNdEx:postIndex]...)
			if m.CommunityID == nil {
				m.CommunityID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemberEpoch == nil {
				m.MemberEpoch = &pdi.MemberEpoch{}
			}
			if err := m.MemberEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passhash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Passhash = append(m.Passhash[:0], dAtA[iNdEx:postIndex]...)
			if m.Passhash == nil {
				m.Passhash = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionToken", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionToken = append(m.SessionToken[:0], dAtA[iNdEx:postIndex]...)
			if m.SessionToken == nil {
				m.SessionToken = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRepo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChInvocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChInvocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChInvocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChID = append(m.ChID[:0], dAtA[iNdEx:postIndex]...)
			if m.ChID == nil {
				m.ChID = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChAdapterDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChAdapterDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRepo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Msg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Msg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Msg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= MsgOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChSessID", wireType)
			}
			m.ChSessID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChSessID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EntryInfo == nil {
				m.EntryInfo = &pdi.EntryInfo{}
			}
			if err := m.EntryInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EntryState == nil {
				m.EntryState = &EntryState{}
			}
			if err := m.EntryState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field T0", wireType)
			}
			m.T0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.T0 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FLAGS", wireType)
			}
			m.FLAGS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FLAGS |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BUF0", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BUF0 = append(m.BUF0[:0], dAtA[iNdEx:postIndex]...)
			if m.BUF0 == nil {
				m.BUF0 = []byte{}
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ITEMS", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ITEMS = append(m.ITEMS, make([]byte, postIndex-iNdEx))
			copy(m.ITEMS[len(m.ITEMS)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRepo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisSeed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisSeed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisSeed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageEpoch == nil {
				m.StorageEpoch = &pdi.StorageEpoch{}
			}
			if err := m.StorageEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommunityEpoch == nil {
				m.CommunityEpoch = &pdi.CommunityEpoch{}
			}
			if err := m.CommunityEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRepo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRepo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoSeed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoSeed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoSeed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedGenesisSeed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignedGenesisSeed = append(m.SignedGenesisSeed[:0], dAtA[iNdEx:postIndex]...)
			if m.SignedGenesisSeed == nil {
				m.SignedGenesisSeed = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuggestedDirName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SuggestedDirName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, &plan.ServiceInfo{})
			if err := m.Services[len(m.Services)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRepo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemberSeed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemberSeed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemberSeed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoSeed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RepoSeed == nil {
				m.RepoSeed = &RepoSeed{}
			}
			if err := m.RepoSeed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyTome", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyTome = append(m.KeyTome[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyTome == nil {
				m.KeyTome = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemberEpoch == nil {
				m.MemberEpoch = &pdi.MemberEpoch{}
			}
			if err := m.MemberEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginMemberID", wireType)
			}
			m.OriginMemberID = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginMemberID = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginSigningKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginSigningKey == nil {
				m.OriginSigningKey = &ski.KeyInfo{}
			}
			if err := m.OriginSigningKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRepo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntryState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntryState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntryState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= EntryStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveIDs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiveIDs = append(m.LiveIDs[:0], dAtA[iNdEx:postIndex]...)
			if m.LiveIDs == nil {
				m.LiveIDs = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRepo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChMgrState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChMgrState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChMgrState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationRev", wireType)
			}
			m.ValidationRev = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidationRev |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRepo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChStoreState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChStoreState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChStoreState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelID = append(m.ChannelID[:0], dAtA[iNdEx:postIndex]...)
			if m.ChannelID == nil {
				m.ChannelID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChProtocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChProtocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatedUpto", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatedUpto = append(m.ValidatedUpto[:0], dAtA[iNdEx:postIndex]...)
			if m.ValidatedUpto == nil {
				m.ValidatedUpto = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MergeEnabled = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRepo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRepo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChannelInfo == nil {
				m.ChannelInfo = &pdi.ChannelInfo{}
			}
			if err := m.ChannelInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRepo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRepo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ints = append(m.Ints, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRepo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRepo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRepo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ints) == 0 {
					m.Ints = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRepo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ints = append(m.Ints, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ints", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRepo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChDependency) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChDependency: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChDependency: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepTime", wireType)
			}
			m.DepTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DepTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRepo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRepo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRepo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRepo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRepo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRepo
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthRepo
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRepo
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRepo(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthRepo
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRepo = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRepo   = fmt.Errorf("proto: integer overflow")
)
