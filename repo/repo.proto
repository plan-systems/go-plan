
// See http://github.com/plan-systems/plan-protobufs/


syntax = "proto3";

package repo;

import "github.com/plan-systems/go-plan/plan/plan.proto";
import "github.com/plan-systems/go-plan/ski/ski.proto";
import "github.com/plan-systems/go-plan/pdi/pdi.proto";







message SessionRequest {

    // Normally the empty string, this is used when an existing token is req'd
                bytes           session_token           = 1;

    // Which community this session wants to access
                bytes           community_id            = 2;

    // Identifies who is requesting the session (via pubkey)
                ski.KeyRef      client_id               = 3;

    // Additional keys, tokens, info, params
                plan.Block      params                  = 5;
}



message Msg {

    // Describes this msg in some way (optional)
                string          label                   = 1;

    // Reports any error/state condition.
                plan.Status     status                  = 2;

    // Holds arbitrary information/data
                plan.Block      body                    = 3;
}




service Repo {

    // Starts a new client member session.
    rpc         StartMemberSession(SessionReq)                      returns (SessionInfo);

    // Requests a sequence of txns within a specified time window and other query criteria.
    rpc         InvokeChannel(ChInvocation)                         returns (ChStatus);

    // Sends and receives blocks to/from a channel (via the given channel session). 
    rpc         ChSessionPipe(stream ChMsg)                         returns (stream ChMsg);

    // Pins the FS item identified by a hashname to a local file system parent dir.
    // When complete, a local pathname is returned containing the pinned FSItem/tree.
    // This is why the graphical client and repo are on the same machine. 
    // Maybe there could be such thing as a CFI node someday, but unlikely due to the pain
    //    that the member session/repo has all of the security info.
   // rpc         PinFSItem(FSItem)                               returns (stream PinStatus);

}




message SessionReq {

    // Identifies a workstation/client installation (metaphorical to a "dumb" terminal in the 70's and 80's).
    // Two different members could have member sessions with the same workstation ID into a given repo (but not at the same time).
                bytes           workstationID           = 1;

    // Which community this session wants to access
                bytes           communityID             = 2;

    // The member's community-given ID
                pdi.MemberEpoch member_epoch            = 3;

    // Optional -- used internally
     //           string          repo_path               = 4;

    //          bytes           prev_session_token      = 4;
    //          bytes           next_session_token      = 5;

    // This will evolve in time, but in general, the client authenticates by submitting a token, 
    //    which is a hash of biometric-based input (e.g. pin, password, key-fob, eye scan) plus 
    //    a secure token from the previous session.
    // This is used to create a symmetric key to encrypt/decrypt the member's primary key hive
    //    that resides on the host.
                bytes           passhash                = 5;

    // When the above symmetric key is created, it's placed it and other session info into a "secret box",
    //    and is locked with a key only the host has has, and sent back as the "session token".
    // This allows the client to present the session_token (until it expires) instead of the client 
    //    having to perform full biometric authentication.
                bytes           session_token           = 6;

}


message SessionInfo {

}




message ChInvocation {

                fixed64         ch_id              = 1;

                string          ch_adapter_desc    = 2;

}

message ChStatus {

                int32           ch_session_id           = 1;    

    // Reports any error/state condition.
                plan.Status     status                  = 2;
}


message ChMsg {

                int32           ch_session_id           = 1;

                plan.Block      content                 = 2;  
}





