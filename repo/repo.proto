
// See http://github.com/plan-systems/plan-protobufs/


syntax = "proto3";

package repo;

import "github.com/plan-systems/go-plan/plan/plan.proto";
import "github.com/plan-systems/go-plan/ski/ski.proto";
import "github.com/plan-systems/go-plan/pdi/pdi.proto";







message SessionRequest {

    // Normally the empty string, this is used when an existing token is req'd
                bytes               session_token               = 1;

    // Which community this session wants to access
                bytes               communityID                 = 2;

    // Identifies who is requesting the session (via pubkey)
                ski.KeyRef          clientID                    = 3;

    // Additional keys, tokens, info, params
                plan.Block          params                      = 5;
}



message Msg {

    // Describes this msg in some way (optional)
                string              label                       = 1;

    // Reports any error/state condition.
                plan.Status         status                      = 2;

    // Holds arbitrary information/data
                plan.Block          body                        = 3;
}




service Repo {

    // Starts a new client member session.
    rpc         StartMemberSession(SessionReq)                      returns (SessionInfo);

    // Requests a sequence of txns within a specified time window and other query criteria.
    rpc         InvokeChannel(ChInvocation)                         returns (ChStatus);

    // Sends and receives blocks to/from a channel (via the given channel session). 
    rpc         ChSessionPipe(stream ChMsg)                         returns (stream ChMsg);

    // Pins the FS item identified by a hashname to a local file system parent dir.
    // When complete, a local pathname is returned containing the pinned FSItem/tree.
    // This is why the graphical client and repo are on the same machine. 
    // Maybe there could be such thing as a CFI node someday, but unlikely due to the pain
    //    that the member session/repo has all of the security info.
   // rpc         PinFSItem(FSItem)                               returns (stream PinStatus);

}




message SessionReq {

    // Identifies a workstation/client installation (metaphorical to a "dumb" terminal in the 70's and 80's).
    // Two different members could have member sessions with the same workstation ID into a given repo (but not at the same time).
                bytes               workstationID               = 1;

    // Which community this session wants to access
                bytes               communityID                 = 2;

    // The member's community-given ID
                pdi.MemberEpoch     member_epoch                = 3;

    // Optional -- used internally
    //          string              repo_path                   = 4;

    //          bytes               prev_session_token          = 4;
    //          bytes               next_session_token          = 5;

    // This will evolve in time, but in general, the client authenticates by submitting a token, 
    //    which is a hash of biometric-based input (e.g. pin, password, key-fob, eye scan) plus 
    //    a secure token from the previous session.
    // This is used to create a symmetric key to encrypt/decrypt the member's primary key hive
    //    that resides on the host.
                bytes               passhash                    = 5;

    // When the above symmetric key is created, it's placed it and other session info into a "secret box",
    //    and is locked with a key only the host has has, and sent back as the "session token".
    // This allows the client to present the session_token (until it expires) instead of the client 
    //    having to perform full biometric authentication.
                bytes               session_token               = 6;

}


message SessionInfo {

}




message ChInvocation {

                fixed64             ch_id                       = 1;

                string              ch_adapter_desc             = 2;

}

message ChStatus {

                int32               ch_sessionID                = 1;    

    // Reports any error/state condition.
                plan.Status         status                      = 2;
}


message ChMsg {

                int32               ch_sessionID                = 1;

                plan.Block          content                     = 2;  
}



message GenesisSeed {
                pdi.StorageEpoch    storage_epoch               = 1;
                pdi.CommunityEpoch  community_epoch             = 2;
}


message RepoConfig {

}


message RepoSeed {
                bytes               signed_genesis_seed         = 1;
    // 
                string              suggested_dir_name          = 2;

    repeated    plan.ServiceInfo    services                    = 5;


}


// GuestInvite -- STEP 1
// A community issues this to a person they want to invite into their community.  A copy of this record is written to member registry channel.
// This is passed in the clear and is used by a prospective member or guest's client to connect to a community.
message MemberSeed {
                RepoSeed            repo_seed                   = 1;


                ski.KeyTome         key_tome                    = 3;    // Contains community keyring and first-issue sending, signing, and txn signing keys.

                pdi.MemberEpoch     member_epoch                = 6;

    // WHO sent this invitation (note: the member's signing key is used to create this invite)
                fixed64             origin_memberID             = 7;
                ski.KeyInfo         origin_signing_key          = 8;

    // A asym key used to encrypt an InvitationResponse
                ski.KeyInfo         reply_to                    = 9;

}


/*
New member steps:
1) Alice is community member of C and has member invite privs
2) Alice generates a new MemberSeed ("MS") and writes it to the member registry channel (Alice locks the MS with a password)
3) Alice gives Bob the MS (and the password)
4) Bob installs PLAN
5) Bob is prompted for a seed file and he selects it (and enters the decrypt password)
6) Bob's client can now seed a new repo R, rebuilding from scratch
7) When complete (when R sees the MemberEpoch record entry show up)
8) Bob's client prompts him to enter his alias, member info, etc -- and generates and inserts a new MemberEpoch into the Community member epoch channel
9) Bob picks up his lambo.

*/


/*****************************************************
** Internal
**/


enum ChEntryStatus {

    // This entry has yet to merged into the repo's channel subsystem. 
    AWAITING_MERGE              = 0;

    // The given entry is deferred as a result of one of many possibilities encountered during 
    // channel entry validation (see design-docs/PLAN-Proof-of-correctness.md). Specifically, 
    // this means ChEntryInfo.Flags lacks one or more req'd flags in order for the entry to be live.
    DEFERRED                    = 1;

    // The given entry is currently in conflict with another entry having equal authority.
    AMBIGUOUS_CONFLICT          = 2;

    // The given entry is considered authentic and a live operating part of the local community repo.
    // The corresponding ChEntryInfo.Flags contains all the flags required for an entry to be live.
    LIVE                        = 3;

    // The given entry has been confirmed to be associated with unauthorized activity, a security breach, or inappropriate behavior.
    DISBARRED                   = 4;


}



// ChEntryFlags are bit shift values (not actual values)
enum ChEntryFlag {

    // Set if author member ID + member epoch validates against the community's member registred
    AUTHOR_VALIDATED            = 0;

    // Set if this entry validates against the cited channel epoch ID
    CHANNEL_EPOCH_VALIDATED     = 1;

    // Set if this entry validates against the cited or implied governing ACC
    ACC_VALIDATED               = 2;

    // Set if the ChAgent regards this entry as well-formed.
    AGENT_VALIDATED             = 3;

    // If not set, one or more parts of this entry are not self-consistent and/or do not self-validate.
    // By definition, once this flag is cleared, it will never reappear.
    WELL_FORMED                 = 4;

    // Set if this entry is a genesis entry URID was white-listed (and can be verified)
    IS_GENESIS_ENTRY            = 5;

}




message ChEntryInfo {

    // See pdi.EntryInfo
                int64               time_authored               = 1;
                uint32              time_authored_frac          = 2;
                int64               time_received               = 3;
                pdi.EntryOp         entry_op                    = 4;
                uint64              channel_epochID             = 6;
                uint32              author_memberID             = 7;
                uint32              author_member_epoch         = 8;
                bytes               author_sig                  = 9;
                plan.Encoding       body_encoding               = 10;
                uint32              flags                       = 11;       // Union of ChEntryFlags


    // Allows a ChStore to "know" what entries need to be passed to the agent (the next time it appears)
                bool                processed_by_agent          = 20;

                ChEntryStatus       status                      = 30;   
                bytes               replaced_withURID           = 31;   // (only valid if EntryStatus == Replaced)

    /*****************************************************
    ** Regenerated Info (nil when encoding)
    **/

        // A hash digest of a packed and readied raw txn.  It is generated by TxnEncoder.EncodeToTxns()
    // This is nil in packaged txns since its hash digest isn't knowable until after the txn is packaged.
//                bytes               txn_hashname                = 21;


    // Binary URID of this entry, derived from time_authored and txn_hashname.
 //               bytes               URID                        = 22;

}

/*
message ChEntryState {

                ChEntryStatus       entry_status                = 10;   

}
*/


/*
message ChMgrState {

                uint64              num_ch_stores               = 1;

}
*/




message ChStoreState {

    // Only set when this channel is in the process of being created.
    //            bool                genesis_mode                = 1;

                uint64              channelID                   = 2;

    repeated    bytes               dep_channels                = 5;

                int64               validated_upto              = 6;

    // 
                int64               agent_informed_upto         = 7;

    // EpochHistory is list of all epochs for this channel since its creation (sorted with newer epochs appearing first) 
    repeated    pdi.ChannelEpoch    epoch_history               = 8;

                pdi.ChannelInfo     channel_info                = 9;
    

}




message MemberEpochRefList {
    repeated    uint32              memberIDs                   = 1;
    repeated    uint32              epochIDs                    = 2;
}


message IntSet {

    repeated    uint64              ints                        = 1;

    // Range: [From, To) 
                uint64              from                        = 2;
                uint64              to                          = 3;

}


// These represent (re)validation to be done
enum ChDependencyType {

    // ALL entries with the given timestamp and later are dependent.
    ALL_ENTRIES                 = 0;

    // Only channel entries with a matching author member ID and epoch
    BY_AUTHOR                   = 1;

    // Only channel entries with a matching channel epoch
    BY_CHANNEL_EPOCH            = 2;

    // Only channel entries with a matching parent ACC ID (Aa
    BY_ACC                      = 3;

    // T
    BY_BODY                     = 4;
}


message ChDependency {

    // Specifies how the fields in this struct are interpreted and applied
                ChDependencyType    dep_type                    = 1;

    // Time index (and later) of applicable channel entries 
                int64               time_index                  = 2;

    // if DepType == BY_AUTHOR_EPOCH:
                uint32              author_memberID             = 3;
                uint32              author_member_epoch         = 4;

    // if DepType == BY_CHANNEL_EPOCH:
                fixed64             channel_epochID             = 5;


}
