
// See http://github.com/plan-systems/plan-protobufs/


syntax = "proto3";

package repo;

import "github.com/plan-systems/go-plan/plan/plan.proto";
import "github.com/plan-systems/go-plan/ski/ski.proto";
import "github.com/plan-systems/go-plan/pdi/pdi.proto";







message SessionRequest {

    // Normally the empty string, this is used when an existing token is req'd
                bytes               session_token               = 1;

    // Which community this session wants to access
                bytes               communityID                 = 2;

    // Identifies who is requesting the session (via pubkey)
                ski.KeyRef          clientID                    = 3;

    // Additional keys, tokens, info, params
                plan.Block          params                      = 5;
}



message Msg {

    // Describes this msg in some way (optional)
                string              label                       = 1;

    // Reports any error/state condition.
                plan.Status         status                      = 2;

    // Holds arbitrary information/data
                plan.Block          body                        = 3;
}



// Repo is the service offered by a PLAN pnode, a headless daemon that serves one or more "seeded" communities to clients. 
service Repo {

    // Bootstraps a repo for a given member.
    rpc         SeedMember(MemberSeed)                              returns (plan.Status);

    // Starts a new client member session.
    rpc         StartMemberSession(SessionReq)                      returns (SessionInfo);

    // Opens/Starts a new chanel session for the given channel ID.
    rpc         OpenChannelSession(ChInvocation)                    returns (stream ChMsg);

    // Sends and receives blocks to/from a channel (via the given channel session). 
    rpc         ChSessionPipe(stream ChMsg)                         returns (plan.Status);



    // Pins the FS item identified by a hashname to a local file system parent dir.
    // When complete, a local pathname is returned containing the pinned FSItem/tree.
    // This is why the graphical client and repo are on the same machine. 
    // Maybe there could be such thing as a CFI node someday, but unlikely due to the pain
    //    that the member session/repo has all of the security info.
   // rpc         PinFSItem(FSItem)                               returns (stream PinStatus);

}




message SessionReq {

    // Identifies a workstation/client installation (metaphorical to a "dumb" terminal in the 70's and 80's).
    // Two different members could have member sessions with the same workstation ID into a given repo (but not at the same time).
                bytes               workstationID               = 1;

    // Which community this session wants to access
                bytes               communityID                 = 2;

    // The member's community-given ID
                pdi.MemberEpoch     member_epoch                = 3;

    // Optional -- used internally
    //          string              repo_path                   = 4;

    //          bytes               prev_session_token          = 4;
    //          bytes               next_session_token          = 5;

    // This will evolve in time, but in general, the client authenticates by submitting a token, 
    //    which is a hash of biometric-based input (e.g. pin, password, key-fob, eye scan) plus 
    //    a secure token from the previous session.
    // This is used to create a symmetric key to encrypt/decrypt the member's primary key hive
    //    that resides on the host.
                bytes               passhash                    = 5;

    // When the above symmetric key is created, it's placed it and other session info into a "secret box",
    //    and is locked with a key only the host has has, and sent back as the "session token".
    // This allows the client to present the session_token (until it expires) instead of the client 
    //    having to perform full biometric authentication.
                bytes               session_token               = 6;

}


message SessionInfo {

}




message ChInvocation {

                bytes               chID                        = 1;

                string              ch_adapter_desc             = 2;

    // Set when creating a new channel.
                pdi.ChannelEpoch    create_new_channel                 = 3;


}




enum ChMsgOp {

    // This ChMsg functionally does nothing but serves as a heartbeat to indicate the channel session is open and operating normally. 
    NO_OP                       = 0;

    // Closes the channel session associated with this channel ID.  Any subsequent ChMsgs bearing this session ID will be ignored/dropped.
    CLOSE_CHANNEL               = 1;

    // Reserved for future use (common to all channels)
    RESERVED_2                  = 2;
    RESERVED_3                  = 3;
    RESERVED_4                  = 4;
    RESERVED_5                  = 5;
    RESERVED_6                  = 6;
    RESERVED_7                  = 7;
    RESERVED_8                  = 8;
    RESERVED_9                  = 9;

    // Ops custom associated to a given channel session protocol. 
    AGENT_OP_0                  = 10;
    AGENT_OP_1                  = 11;
    AGENT_OP_2                  = 12;
    AGENT_OP_3                  = 13;

}




message ChMsg {

                ChMsgOp             op                          = 1;
                uint32              ch_sessionID                = 2;


                plan.Block          block                       = 3;  

}



message GenesisSeed {
                pdi.StorageEpoch    storage_epoch               = 1;
                pdi.CommunityEpoch  community_epoch             = 2;
}


message RepoConfig {

}


message RepoSeed {
                bytes               signed_genesis_seed         = 1;
    // 
                string              suggested_dir_name          = 2;

    repeated    plan.ServiceInfo    services                    = 5;


}


// A community issues this to a person they want to invite into their community.  A copy of this record is written to member registry channel.
// This is passed in the clear and is used by a prospective member or guest's client to connect to a community.
message MemberSeed {
                RepoSeed            repo_seed                   = 1;


                ski.KeyTome         key_tome                    = 3;    // Contains community keyring and first-issue sending, signing, and txn signing keys.

                pdi.MemberEpoch     member_epoch                = 6;

    // WHO sent this invitation (note: the member's signing key is used to create this invite)
                fixed64             origin_memberID             = 7;
                ski.KeyInfo         origin_signing_key          = 8;

    // A asym key used to encrypt an InvitationResponse
    //            ski.KeyInfo         reply_to                    = 9;

}


/*
New member steps:
1) Alice is community member of C and has member invite privs
2) Alice generates a new MemberSeed ("MS") and writes it to the member registry channel (Alice locks the MS with a password)
3) Alice gives Bob the MS (and the password)
4) Bob installs PLAN
5) Bob is prompted for a seed file and he selects it (and enters the decrypt password)
6) Bob's client can now seed a new repo R, rebuilding from scratch
7) When complete (when R sees the MemberEpoch record entry show up)
8) Bob's client prompts him to enter his alias, member info, etc -- and generates and inserts a new MemberEpoch into the Community member epoch channel
9) Bob picks up his lambo.

*/


/*****************************************************
** Internal
**/


enum ChEntryStatus {

    // The given entry has been confirmed to be associated with unauthorized activity, a security breach, or inappropriate behavior.
    DISBARRED                   = 0;

    // This entry has yet to merged into the repo's channel subsystem. 
    AWAITING_MERGE              = 1;

    // This entry has been merged into the channel. 
    MERGED                      = 2;

    // The given entry is deferred as a result of one of many possibilities encountered during 
    // channel entry validation (see design-docs/PLAN-Proof-of-correctness.md). Specifically, 
    // this means ChEntryInfo.Flags lacks one or more req'd flags in order for the entry to be live.
    DEFERRED                    = 3;

    // The given entry is currently in conflict with another entry having equal authority.
    //AMBIGUOUS_CONFLICT          = 2;

    // The given entry is considered authentic and a live operating part of the local community repo.
    // The corresponding ChEntryInfo.Flags contains all the flags required for an entry to be live.
    LIVE                        = 4;


}



// ChEntryFlags are bit shift values (not actual values)
enum ChEntryFlag {

/*
    // Set if author member ID + member epoch validates against the community's member registred
    AUTHOR_VALIDATED            = 0;

    // Set if this entry validates against the cited channel epoch ID
    CHANNEL_EPOCH_VALIDATED     = 1;

    // Set if this entry validates against the cited or implied governing ACC
    ACC_VALIDATED               = 2;

    // Set if the ChAgent regards this entry as well-formed.
    AGENT_VALIDATED             = 3;
*/


    // If not set, one or more parts of this entry are not self-consistent and/or do not self-validate.
    // By definition, once this flag is cleared, it will never reappear.
    WELL_FORMED                 = 0;

    // Set when this entry's dependencies have been written
    DEPENDENCIES_WRITTEN        = 1;

    // Set if this entry's URID appears in the community's list of genesis entries.
    GENESIS_ENTRY_VERIFIED      = 2;

}




message ChEntryInfo {

    /*****************************************************
    ** Fields copied from pdi.EntryInfo
    **/

                pdi.EntryOp         entry_op                    = 1;
                uint32              author_memberID             = 2;        // Creator (and signer) of this entry 
                bytes               TIDs                        = 3;
                bytes               supersedes_entryID          = 4;
                plan.Block          extensions                  = 6;       // Available for unrestricted client use.
                bytes               author_sig                  = 7;



        // A hash digest of a packed and readied raw txn.  It is generated by TxnEncoder.EncodeToTxns()
    // This is nil in packaged txns since its hash digest isn't knowable until after the txn is packaged.
//                bytes               txn_hashname                = 21;


    // Binary URID of this entry, derived from time_authored and txn_hashname.
 //               bytes               URID                        = 22;

}

enum LiveState {

    // This entry is live and the body TID its live with is the same as the entry TID (and .BodyID is nil)
    NORMAL_LIVE                 = 0;

    SUPERCEDED_LIVE             = 1;

}

message ChEntryState {

    // Incremented each time this entry is mutated.

                uint32              flags                       = 1;       // Union of ChEntryFlags

                ChEntryStatus       status                      = 2;

    // IF len() == 0, the implied body TID is the same as the entry info's TID (done to save space)
    // When entry 1 is superseded by entry 2, entry 2's TID appears in entry 1's ChEntryState.
                bytes               liveIDs                     = 10;

}




message ChMgrState {

    // Incremented each time an entry is reversed/overturned.
    // This supports revalidation bookkeeping (triggered by a reversed entry)
                int64               validation_rev              = 1;

}





message ChStoreState {

    // Only set when this channel is in the process of being created.
    //            bool                genesis_mode                = 1;

                bytes               channelID                   = 1;

                string              ch_protocol                 = 2;

    //repeated    bytes               dep_channels                = 4;

    // All entry TIDs up to this point (and including this TID) are not pending active validation.
                bytes               validated_upto              = 3;

    //  If not set, this channel is not yet able to validate entries (e.g. ChUnknown can't)
                bool                merge_enabled               = 4;

    // For the aboive ValidatedUpto value, this supporting revaslidation bookkeeping.
   //             int64               validation_rev              = 5;


    // "Validated" refers to revalidating *all* entries
    // "Retried" refers to only revalidate entries that are not live.
                //bytes               retried_upto              = 6;
    //            bytes               validated_upto              = 7;

    // 
    // EpochHistory is list of all epochs for this channel since its creation (sorted with newer epochs appearing first) 
    //repeated    pdi.ChannelEpoch    epoch_history               = 8;

                pdi.ChannelInfo     channel_info                = 9;
    

}






message MemberEpochRefList {
    repeated    uint32              memberIDs                   = 1;
    repeated    uint32              epochIDs                    = 2;
}


message IntSet {

    repeated    uint64              ints                        = 1;

    // Range: [From, To) 
                uint64              from                        = 2;
                uint64              to                          = 3;

}


/*
// These represent (re)validation to be done
enum ChDependencyType {

    // ALL entries with the given timestamp and later are dependent.
    ALL_ENTRIES                 = 0;

    // Only channel entries with a matching author member ID and epoch
    BY_AUTHOR                   = 1;

    // Only channel entries with a matching parent ACC ID (Aa
    BY_ACC                      = 2;

    // T
    BY_BODY                     = 3;
}
*/

message ChDependency {

    // Time index (and later) of applicable channel entries 
                int64               dep_time                    = 1;

    // if DepType == BY_AUTHOR_EPOCH:
    //            uint32              author_memberID             = 3;
    //            uint32              author_member_epoch         = 4;

    // if DepType == BY_CHANNEL_EPOCH:
     //           fixed64             channel_epochID             = 5;


}




/*

// CordProtocol describes the kind of coordinate data in this data set.
enum CordType {

    // Each coordinate is 
    GEO_LAT                     = 0;
    GEO_LONG                    = 1;
    GEO_ALTITUDE                = 2;
    ANGULAR_DEGREES             = 3;
    METERS                      = 4;
    UTC_SECS                    = 7;

    // Only channel entries with a matching author member ID and epoch
    ABSTRACT_X                  = 3;
    ABSTRACT_Y                  = 4;
    ABSTRACT_Z                  = 5;
    ABSTRACT_ANGLE              = 5;

    // Units are in UTC seconds

}


message CordComponent {

                CordType            cord_type                   = 1;
                string              label                       = 2;


}

message LocationList {

    // Place protocol (knowing which data sets inherently refer to the same place)
    // e.g. 
    //    earth/
    //    drews-desktop/
                string              place_protocol              = 1;

    // Coordinate protocol (interoperability amongst data sets and determines UX look and feed)
    // e.g. 
    //    geo/lat-long
    //    abstract/xyz
                CordProtocol        cord_protocol               = 2;

    
}

*/